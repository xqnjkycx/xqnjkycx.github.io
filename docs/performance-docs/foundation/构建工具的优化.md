# 构建工具的优化
站在用户的角度层面来说，构建工具对前端的优化主要也是解决这么两个问题：
- 减少请求次数
- 减少单次请求所花费的时间

这两个优化点是日常使用构建工具构建项目打包时非常常见的操作——**资源的压缩和合并**。

目前业内比较流行的两个主流工具分别是**webpack**和**vite**，主要有以下几个优化的点：

## Tree-Shaking
基于`import/export`的静态引用的特性，`Tree-Shaking`可以在编译时期就获取哪些模块没有被真正的使用，这些没用的代码会在最后打包的时候被去除掉。

假设主干文件有这么一段代码：
```js
import {methodA , methodB} from './utils'

methodA()
```
事实上methodB在这个文件中没有被使用，所以打包的时候会把这部分给删除掉。

Tree-Shaking 的针对性比较强，用于处理模块级别的冗余代码。至于**粒度更细**的冗余代码的去除，一般是在JS或CSS的压缩或分离的过程中进行。

**Tree-Shaking 可以直接使代码的体积减小，也就意味着在http传输过程中携带的文件体积减少，从而减少单次请求所花费的时间**

### webpack
为了利用Tree-Shaking的优势，最好确保：
- 使用 ESM 模块语法
- 确保没有编译器将ESM转换为CommonJS
- 在项目中的`package.json`文件中，添加`sideEffects`属性
- 使用`mode`为`production`的配置来启动Tree-Shaking

### vite
在使用Vite时，Tree-Shaking是自动开启的~

## 代码分割 - 按需加载
像项目中的一些路由，弹窗，不需立即加载的js文件，都需要做代码分割来形成按需加载，这样做的一个好处在于：
- 一次不加载所有的文件内容，只加载此刻需要用到的那部分内容
- 当需要更多内容时，再对用到的内容进行即时加载

总的来说，代码分离可以用于获取更小的bundle，控制资源加载的优先级，从而减小加载时间，**从而达到单次请求的时间减少**

### webpack
webpack中常用的代码分离方法有三种：
- **入口起点**:使用`entry`来手动配置分离代码
```js
const path = require('path');

// 将another-module这个模块分离出去
 module.exports = {
  mode: 'development',
  entry: {
    index: './src/index.js',
    another: './src/another-module.js',
  },
   output: {
    filename: '[name].bundle.js',
     path: path.resolve(__dirname, 'dist'),
   },
 };
```
手动入口chunk之间包含一些重复的模块，那么这些重复模块被引入到各个bundle之中，导致手动分离这些模块特别麻烦

- **SplitChunks**去重
`SplitChunks`配置选项后构建，可以将公共的依赖模块提取到已有的入口chunk中，或者提取到一个新生成的chunk。


```js
    optimization: {
      splitChunks: {
        /**
         * initial 入口 chunk，对于异步导入文件不处理
         * async 异步 chunk, 只对异步导入文件处理
         * all 全部 chunk
         */
        chunks: 'all',
        // 分割策略：只要命中了其中一条(vendor common)就会进行代码分割
        cacheGroups: {
          // 第三方模块
          vendor: {
            name: 'vendor', // chunk名称
            priority: -10, // 优先级，如果同时命中vendor和common规则，按照优先级高的分割
            test: /node_modules/, // 针对于来自 node_modules 的库
            minSize: 30000, // 大小限制 约30kb
            minChunks: 1 // 最少引用次数
          },
          // 公共代码块
          common: {
            name: 'common',
            priority: -20,
            minSize: 0,
            minChunks: 2
          }
        }
      },
      minimize: true,
      minimizer: [
        new TerserPlugin({
          exclude: /node_modules/
        })
      ]
    }
```
可以将一些第三库和公用文件分离到单独的`chunk`，并且将其从 main bunlde 中移除，减轻对 bundle 大小。

在webpack中也推荐使用`mini-css-extract-plugin`用于将CSS从主应用程序中分离。

- **动态导入**：使用`import()语法`的将实现动态导入

### vite
Vite实现了自动CSS代码分割的能力，即实现一个chunk对应一个css文件，这样做可以提升CSS文件的缓存复用率。而且，Vite基于Rollup的manualChunks API 可以实现应用自定义拆包策略，一般选择将较大的第三方组件库和共用文件进行配置才分出来：
```js
    build: {
      manifest: true,
      rollupOptions: {
        output: {
          manualChunks: {
            lodash: ['lodash-es'],
            echarts: ['echarts'],
            'aq-ui': ['aq-ui'],
            aqlabelview: ['aqlabelview']
          }
        }
      }
    },
```
当然动态使用`import()`也会被单独切分出来，如果Vite搭配Vue使用，更推荐在组件上考虑是否是异步组件，对异步组件进行动态导入，Vite也会将异步组件的内容单独切分出来。

## 压缩
对代码打包产物进行压缩是减少代码体积的非常明显有效的一种方式，它是直接减少了产物的体量，从而去提升**单次请求的响应速度**。

### webpack
- **JS**:webpack中可以选择`terser-webpack-plugin`并开启`prod`模式来实现JS的压缩。`terser-webpack-plugin`是webpack5最新的压缩插件。

使用方式也简单粗暴：
```js
    optimization: {
      minimize: true,
      minimizer: [
        new TerserPlugin({
          exclude: /node_modules/
        })
      ]
    }
```

- **CSS**:使用`css-minimizer-webpack-plugin`来做css代码的压缩，配置也很简单：
```js
const MiniCssExtractPlugin = require("mini-css-extract-plugin");
const CssMinimizerPlugin = require("css-minimizer-webpack-plugin");

module.exports = {
  module: {
    rules: [
      {
        test: /.s?css$/,
        use: [MiniCssExtractPlugin.loader, "css-loader", "sass-loader"],
      },
    ],
  },
  optimization: {
    minimizer: [
      // 在 webpack@5 中，你可以使用 `...` 语法来扩展现有的 minimizer（即 `terser-webpack-plugin`），将下一行取消注释
      // `...`,
      new CssMinimizerPlugin(),
    ],
  },
  plugins: [new MiniCssExtractPlugin()],
};
```
- **HTML**: html-minimizer-webpack-plugin:使用`html-minimizer-webpack-plugin`来对html代码进行压缩
```js
const HtmlMinimizerPlugin = require("html-minimizer-webpack-plugin");
  optimization: {
    minimize: true,
    minimizer: [
      // For webpack@5 you can use the `...` syntax to extend existing minimizers (i.e. `terser-webpack-plugin`), uncomment the next line
      // `...`
      new HtmlMinimizerPlugin(),
    ],
  },
```
### vite
vite对代码的压缩做了自动处理。如果想开启Gzip压缩的话，可以使用`vite-plugin-compression`插件来完成Gzip压缩
```js
import {defineConifg} from 'vite'
import viteCompression from 'vite-plugin-compression'
export default defineConfig({
    plugins:[
        viteCompression({
            algorihm:"gzip",
            threshold:10240,
            verbose:false,
            deleteOriginFile:true
        })
    ]
})
```
指定压缩算法为gzip之后，通过thresold指定文件大小10240b(10kb)时才压缩文件，最后会生成一堆`xxxx.js.gz`文件

:::tip 彩蛋
如果项目不是极端迷你的小型项目，可以尝试使用Gzip。

压缩Gzip服务端需要时间，解压Gzip浏览器需要花费时间，需要考虑其中的优化衡量。

一般来说Gzip压缩是服务端的事，由CPU来执行。压缩文件这个过程本身是需要花费时间的，可以理解为服务器压缩的时间开销和CPU处理的开销为代价，来节省传输时间过程中的开销。

CPU不是万能的，如果存在大量的压缩需求，服务器也会被拖垮。服务器一旦慢下来了，用户还是需要等待。像Webpack和Vite压缩操作的存在，事实上也是为了在构建过程中去做一部分服务器的工作，从而为服务器分压。
:::