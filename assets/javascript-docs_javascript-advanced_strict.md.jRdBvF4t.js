import{_ as s,c as i,o as a,U as t}from"./chunks/framework.PFQuerqu.js";const g=JSON.parse('{"title":"Strict","description":"","frontmatter":{},"headers":[],"relativePath":"javascript-docs/javascript-advanced/strict.md","filePath":"javascript-docs/javascript-advanced/strict.md","lastUpdated":1706532002000}'),n={name:"javascript-docs/javascript-advanced/strict.md"},e=t(`<h1 id="strict" tabindex="-1">Strict <a class="header-anchor" href="#strict" aria-label="Permalink to &quot;Strict&quot;">​</a></h1><p>JavaScript本身是一款比较宽松的语言，它允许编写的代码存在一些不规范的东西。这些不规范的东西可能造成一些问题，为了解决这些问题，<code>ES5</code>引入了strict模式。</p><p>strict 是一种执行模式，通过限制一些不规范的行为来提供更加严格的错误检查。在这种模式下一些不规范的语法和行为会被直接抛出异常，从而迫使代码更加的规范和可靠。</p><p>strict 模式可以直接添加到整个文件中，也可以只限定用于某些特定的函数。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;use strict&quot;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 开启strict模式</span></span></code></pre></div><h2 id="strict模式的影响" tabindex="-1">strict模式的影响 <a class="header-anchor" href="#strict模式的影响" aria-label="Permalink to &quot;strict模式的影响&quot;">​</a></h2><p>其影响的功能非常多，这里有几个典型案例：</p><h3 id="禁止对未声明的变量赋值" tabindex="-1">禁止对未声明的变量赋值 <a class="header-anchor" href="#禁止对未声明的变量赋值" aria-label="Permalink to &quot;禁止对未声明的变量赋值&quot;">​</a></h3><p>在严格模式下，所有的变量都必须先声明之后使用。如果使用没有声明的变量，将会抛出一个<code>ReferenceError</code>，这有助于避免拼写错误或者意外的全局变量污染而导致的错误。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">nonDeclaredVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></div><p>如果这要是在非严格模式下，那么整个变量会被赋值到全局对象上，即：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">globalThis.nonDeclaredVar </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // true</span></span></code></pre></div><p>这是一种不该发生的副作用</p><h3 id="禁止对不可写的属性赋值" tabindex="-1">禁止对不可写的属性赋值 <a class="header-anchor" href="#禁止对不可写的属性赋值" aria-label="Permalink to &quot;禁止对不可写的属性赋值&quot;">​</a></h3><p>不可写属性指的是一个对象的<code>writable=false</code>，或者为存取器类型，其中<code>set=undefined</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">create</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    name:{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        writable:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">false</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    age:{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;Jake&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.age </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 16</span></span></code></pre></div><p>在非严格模式下，整个操作是静默失败的，而且在控制台种不会有任何报错信息 如果在严格模式下，这种操作直接发生报错：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>Uncaught TypeError: Cannot assign to read only property &#39;name&#39; of object &#39;[object Object]&#39;</span></span>
<span class="line"><span>at</span></span></code></pre></div><h3 id="禁止删除变量-函数和函数参数" tabindex="-1">禁止删除变量，函数和函数参数 <a class="header-anchor" href="#禁止删除变量-函数和函数参数" aria-label="Permalink to &quot;禁止删除变量，函数和函数参数&quot;">​</a></h3><p>在严格模式下，使用delete操作符去删除变量，函数和函数参数会抛出一个<code>SyntaxError</code>。这样可以避免意外地删除重要的代码片段。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> bar</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  delete</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> arguments</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> bar</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">baz</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><h3 id="禁止重复的函数参数名" tabindex="-1">禁止重复的函数参数名 <a class="header-anchor" href="#禁止重复的函数参数名" aria-label="Permalink to &quot;禁止重复的函数参数名&quot;">​</a></h3><p>在严格模式下，函数的参数名必须是唯一的，如果出现重复参数名，将会抛出<code>SyntaxError</code>。有助于避免参数名重复而导致的混淆错误。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Person</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">age</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){}</span></span></code></pre></div><p>在非严格模式下，第二个name会覆盖第一个</p><h3 id="禁止使用八进制字面量" tabindex="-1">禁止使用八进制字面量 <a class="header-anchor" href="#禁止使用八进制字面量" aria-label="Permalink to &quot;禁止使用八进制字面量&quot;">​</a></h3><p>也是抛出<code>SynataxError</code>。因为八进制字面量在JS种容易混淆，不利于代码的阅读。 八进制有两种表示方法，旧的方式就是前面加一个0.但是前面有0的不一定就是八进制，也可能是10进制</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">( </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">071</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> , </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">078</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>所以现在新的八进制就是以<code>0o</code>为前缀，与二进制的<code>ob</code>和十六进制的<code>0x</code>形式上的统一。</p><h3 id="禁止使用-this-关键字指向全局对象" tabindex="-1">禁止使用 this 关键字指向全局对象 <a class="header-anchor" href="#禁止使用-this-关键字指向全局对象" aria-label="Permalink to &quot;禁止使用 this 关键字指向全局对象&quot;">​</a></h3><p>如果在函数内部使用this关键字，并且没有通过对象或者构造函数调用整个函数,this就会指向全局对象，在浏览器中是window，在node中就是global</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`this in foo\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//window</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span></code></pre></div><p>使用严格模式之后，this关键字变为undefined。有助于避免在函数内部意外地访问和修改全局变量。</p><h3 id="禁止在当前上下文创建新变量" tabindex="-1">禁止在当前上下文创建新变量 <a class="header-anchor" href="#禁止在当前上下文创建新变量" aria-label="Permalink to &quot;禁止在当前上下文创建新变量&quot;">​</a></h3><p>在非严格模式下，可以通过<code>eval(&quot;var newVariable&quot;)</code>的方式在当前上下文中创建变量，并且被后续代码使用</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">eval</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;var foo = 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo)</span></span></code></pre></div><p>严格模式直接把这个<code>eval</code>禁用了</p><div class="tip custom-block"><p class="custom-block-title">强烈建议</p><p>在一般情况下，都应该开启严格模式</p></div><h2 id="不同场合下的strict" tabindex="-1">不同场合下的strict <a class="header-anchor" href="#不同场合下的strict" aria-label="Permalink to &quot;不同场合下的strict&quot;">​</a></h2><p>不一定需要声明<code>use strict</code>，才能开启strict模式。可以看到这些情况：</p><ul><li><strong>ESM下一定是strict模式</strong> ：包括内链和外链，只要是Module环境，就被强制开启了 strict 模式。这种文件中写出上述违反 strict 的代码是不太可能的。</li><li><strong>class 代码一定是strict模式</strong>：class 是特殊的函数，显然它还相当于在函数体内强制声明了&quot;use strict&quot;语句。</li></ul>`,41),l=[e];function p(h,k,d,r,c,o){return a(),i("div",null,l)}const y=s(n,[["render",p]]);export{g as __pageData,y as default};
