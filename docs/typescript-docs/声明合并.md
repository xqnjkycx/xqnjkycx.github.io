# 声明合并
TypeScript**声明合并**可以将同一名称的两个声明合并在一起为一个声明。

合并声明之后同时拥有两个声明的特性。任何数量的声明都可以合并，并不局限于两个声明。

## 合并接口
接口的合并机制就是将双方成员放到同一个名称的接口里。
```ts
interface Box {
    height: number;
    width: number;
}

interface Box {
    scale: number;
}

let box: Box = {height: 5, width: 6, scale: 10};
```
要求接口里面的非函数成员必须是唯一的。如果不是唯一的，必须要求是同一类型的，否则编译器会报错。

对于函数成员，每个同名函数声明都会被当成这个函数的重载。注意的是，当接口A与后面的接口A合并，后面的接口有更高的优先级。

如下：
```ts
interface Cloner {
    clone(animal: Animal): Animal;
}

interface Cloner {
    clone(animal: Sheep): Sheep;
}

interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
}
```
这三个接口将会合并为一个：
```ts
interface Cloner {
    clone(animal: Dog): Dog;
    clone(animal: Cat): Cat;
    clone(animal: Sheep): Sheep;
    clone(animal: Animal): Animal;
}
```
:::tip
可以看到：每组接口里的声明顺序保持不变，但是各个接口之间，后面合并的接口会出现在靠前的位置
:::
这个顺序也有例外，当出现特殊的函数签名时。如果签名里有一个参数的类型是单一的字符串字面量，那么它将会被提升到重载列表的最顶端：

```ts
interface Document {
    createElement(tagName: any): Element;
}
interface Document {
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
}
interface Document {
    createElement(tagName: string): HTMLElement;
    createElement(tagName: "canvas"): HTMLCanvasElement;
}
```
合并之后，参数类型为**单一**字符串字面量的会排在前列：
```ts
interface Document {
    createElement(tagName: "canvas"): HTMLCanvasElement;
    createElement(tagName: "div"): HTMLDivElement;
    createElement(tagName: "span"): HTMLSpanElement;
    createElement(tagName: string): HTMLElement;
    createElement(tagName: any): Element;
}
```
## 合并命名空间
与接口相似，同名的命名空间也会合并其成员。命名空间会创建出命名空间和值。

对于命名空间的合并，模块导出的同名接口进行合并，构成单一的命名空间内含有合并后的接口。

对于命名空间里值得合并，如果当前已经存在给定名字得命名空间，那么后来得命名空间的导出成员会被加到已经存在的那个模块当中。

```ts
namespace Animals {
    export class Zebra { }
}

namespace Animals {
    export interface Legged { numberOfLegs: number; }
    export class Dog { }
}
```
这段代码其实等同于:
```ts
namespace Animals {
    export interface Legged { numberOfLegs: number; }

    export class Zebra { }
    export class Dog { }
}
```

除了这些合并之外，还需要了解非导出成员是怎么处理的。非导出成员仅仅在其原有的（合并前的）命名空间内可见。也就是说明合并之后，从其它命名空间合并进来的成员无法访问非导出成员。

比如说这个例子：
```ts
namespace Animal {
    let haveMuscles = true;

    export function animalsHaveMuscles() {
        return haveMuscles;
    }
}

namespace Animal {
    export function doAnimalsHaveMuscles() {
        return haveMuscles;  // Error, because haveMuscles is not accessible here
    }
}
```
因为`haveMuscles`并没有导出，只有`animalsHaveMuscles`函数共享了原始未合并的命名空间可以访问这个变量。`doAnimalsHaveMuscles`函数虽是合并命名空间的一部分，但是访问不了没有导出的成员。