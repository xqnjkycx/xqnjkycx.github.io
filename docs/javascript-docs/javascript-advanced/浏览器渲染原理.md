# 浏览器渲染原理

当浏览器的网络进程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。

在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。

![image](./assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86.png)

整个渲染流程的阶段，分别是：HTML解析，样式计算，布局，分层，绘制，分块，光栅化，画。最后得到像素信息。

每个阶段都有非常明确的输入和输出，上一个阶段的输出成为下一个阶段的输入：

![image](./assets/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%B5%81%E7%A8%8B.png)

## 解析HTML
浏览器会把HTML解析成 `HTML树` 和 `CSSOM树`。

![image](./assets/%E8%A7%A3%E6%9E%90HTML.png)

如果在渲染主线程时，有link这样的css代码，浏览器就会启动一个预解析线程率先下载并解析CSS代码：

![image](./assets/%E8%A7%A3%E6%9E%90link.png)

所以CSS代码是不会阻塞主线程的HTML解析的。

但是JS是会阻塞的，预解析虽然可以分担一些下载任务，但是因为JS代码的执行过程可能会修改当前DOM树，所以DOM树的解析必须暂停。

## 样式计算
主线程会遍历得到DOM树，依次为树中的每个节点计算出它的最后样式，称之为Computed Style。

在这个过程中很多预设值会发生改变，比如red变为rgb(255,0,0)；相对单位变为绝对单位，比如em变为px。

最后会产生一棵带有样式的DOM树

![image](./assets/%E6%A0%B7%E5%BC%8Ftree.png)

## 布局
在布局阶段，会将带有样式信息的Dom树去计算出一个布局树

Dom树和布局树不一定是一一对应的，因为有的元素可能被认为是“不显示”的，布局树就会少一个，或者有伪元素布局树就会多一个。

![image](./assets/%E5%B8%83%E5%B1%80tree.png)

## 分层
从下图可以看到，浏览器会对整个布局树进行**分层**。分层的好处在于如果某一个层发生改变之后，仅对当前层做后续处理，从而提升效率。滚动条，`transform`,`opacity`等样式都有可能导致结果分层，可以通过`will-change`来最大程度上的去影响分层结果。

![image](./assets/%E5%88%86%E5%B1%82.png)

## 绘制
浏览器为每一层生成一系列的绘制指令，类似于用中文来描述就是：**将画笔移动到（10，30）位置，画一个200*300的矩形，用红色填充矩形。**这个类似于Canvas的绘制指令一样。

至此，渲染主线程的基本工作到此为止，后续的步骤交给其他线程完成。
![image](./assets/%E7%BB%98%E5%88%B6%E6%B5%81%E7%A8%8B.png)

## 分块
合成线程首先会对每个图层进行分块，将其划分为更多的小型区域。分块工作会占用到多个**分块器**线程来完成。

分块可以优化后续处理，使得优先绘制视口内的块。

![image](./assets/%E5%88%86%E5%9D%97.png)

## 光栅化
光栅化将每个块转换为位图，优先处理靠近视口的块。

![image](./assets/%E5%85%89%E6%A0%85%E5%8C%96.png)

主要是计算每个块内部的像素信息，在这个阶段会切换到GPU进程，GPU进行计算之后返回给合成线程。

![image](./assets/%E5%85%89%E6%A0%85%E5%8C%96%E6%B5%81%E7%A8%8B.png)

## 画
合成线程拿到每个层，每个块的位图之后，生成一个个**指引（quad）**信息。指引会标识出每个位图应该画到屏幕的哪个位置，以及会考虑到旋转，缩放等变形。变形发生在合成线程，与渲染主线程无关，和就是`Transform`效率高的本质。合成线程会把quad提交给GPU进程，由GPU进程产生系统调用，提交给GPU硬件，完成最终的屏幕图像。