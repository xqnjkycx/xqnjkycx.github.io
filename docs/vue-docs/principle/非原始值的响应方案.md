# 非原始值的响应方案
实际上要实现完整的响应式数据，是要比想象中的难很多，并不是单纯地拦截 `getter` 和 `setter` 。而且 JS 中本身还存在大量的复杂数据类型，数组，`Map`，`Set`，`WeakMap`，`WeakSet` 等等。

## Proxy
`Proxy` 可以创建一个代理对象，它能够实现对 **其他对象** 的代理。 `Proxy` 的代理是对一个对象的 **基本语义** 的代理。也就是意味着允许 **拦截** 并 **重新定义** 对一个对象的 **基本操作**。

```js
obj.foo // 读取
obj.foo++ // 设置
```
读取和设置属性值这样的操作，就可以用 `Proxy` 来拦截

```js
const p = new Proxy(obj , {
  get(){
    //...
  }
  set(){
  	//...
  }
})
```
 记住，`Proxy` 只能拦截对一个对象的基本操作，某些 **复合操作** 就不能完成
 ```js
 obj.fn() // 复合操作
 ```
 实际上，调用一个对象下的方法，是由两个基本语义组成的。第一个基本语义是 get , 第二个基本语义是 函数调用。

## Reflect
`Reflect`是一个全局对象，它有许多方法：
```js
Reflect.get()
Reflect.set()
Reflect.apply()
// ...
```
对于`Reflect.get`方法，它的功能就是提供了访问一个对象属性的默认行为:
```js
const obj = { foo : 1}
obj.foo

// 等价于

Reflect.get(obj,'foo')
```
实际上，`Reflect`真正有价值的地方在于 它可以接受第三个参数 receiver ，它的作用在于 如果 `target` 对象中指定了`getter`，`receiver` 则为 `getter` 调用时的 `this` 值。

假如现在有这样的一个数据源：
```js
// 数据源
const obj = {
  foo : 1,
  // p.bar是一个访问器属性，因此执行getter函数。
  // 由于在 getter 函数中通过 this.foo 读取了 foo属性值
  // 因此想当然认为副作用函数与属性 foo 之间也会建立起联系
  get bar(){
    return this.foo
  }
}

const p = new Proxy(obj , {
  //...
})

effectRegister(()=>{
  console.log(p.bar) // 读取操作
})

p.foo++ // 发现并不会触发 trigger
```
显而易见，在代理对象 `p` 中的 `getter` 会拦截这次读取操作，通过 `target[key]` 返回属性值。其中 `target` 是原始对象 `obj`，而 `key` 就是字符串 `bar`，所以 `target[key]` 相当于 `obj.bar`。因此，当使用 `p.bar` 访问 `bar` 属性，`this` 的指向是原始对象数据源 `obj`，说明最终访问的是 `obj.foo`。通过原始对象访问它的某个属性是不会建立起响应联系的。所以需要 `Refelct` 的第三个参数 `receiver` 来做调整。

这其实等同于：
```js
// obj是原始对象而不是代理对象，这样的访问不能够建立起响应联系
effectRegister(()=>obj.foo)
```
这就需要`Reflect`来做修正了
```js
const p = new Proxy(obj,{
    // 拦截读取操作，接收第三个参数
    get(target,key,receiver){
        track(target,key)
        // 使用 Reflect.get 返回读取到的属性值
        return Reflect.get(target,key,receiver)
    }
})

const obj = {
    foo:1,
    get bar(){
        // 现在这里的this为代理对象p
        return this.foo
    }
}
```
可以看到，this由原始对象变成了代理对象p。很显然，这会在副作用函数与响应式之间建立起响应联系，从而达到收集依赖的效果

## JS对象
JS中有两类对象，一种是 **常规对象**，比如 `obj`，另一种是 **异质对象**，比如 `Proxy`，数组。

实际上，在JS中，对象的实际语义是由对象的 **内部方法** 指定的。所谓的内部方法，指的是当对一个对象进行操作时在引擎内部调用的方法，当然这些方法对于JS 使用者是不可见的。

在 **ECMAScript** 规范中使用  `[[xxx]]` 来代表内部方法或内部槽。一个对象能被称为对象的前提是要实现必须的内部方法

```text
// 以下是必须部署的11个必要的内部方法
[[ GetPrototypeOf ]]    
[[ SetPrototypeOf ]]    
[[ IsExtensible ]]      
[[ PreventExtensions ]] 
[[ GetOwnProperty ]]    
[[ DefineOwnProperty ]] 
[[ HasProperty ]]       
[[ Get ]]              
[[ Set ]]               
[[ Delete ]]
[[ OwnPropertyKeys ]]    
```
除此之外，还有两个额外的内部方法：
```text
[[ Call ]]
[[ Construct ]]
```
如果一个对象需要作为函数调用，那么这个对象就必须部署内部方法 `[[ call ]]`。这也就是区分普通对象和函数的根本标准。函数对象会部署`[[ call ]]`，而普通对象则不会部署。

**内部方法具有多态性**

不同类型的对象可以部署相同的内部方法，但是方法的实现完全不同。比如 `Proxy` 对象的内部方法 `[[Get]]`，它也实现了这样的内部槽，如果在创建代理对象时没有制定拦截函数也就是 `getter` ，`get()` 拦截函数，那么当通过代理对象访问属性值时，代理对象的内部方法 `[[Get]]` 会调用原始对象的内部方法`[[Get]]`来获取属性值，这也是代理透明性质。

创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身的内部方法和行为的，而不是指定被代理对象的内部方法和行为的。

```text
内部方法                             处理器函数(拦截函数)

[[ GetPrototypeOf ]]    ----    getPrototypeOf
[[ SetPrototypeOf ]]    ----    setPrototypeOf
[[ IsExtensible ]]      ----    isExtensible
[[ PreventExtensions ]] ----    preventExtensions
[[ GetOwnProperty ]]    ----    getOwnPropertyDescriptor
[[ DefineOwnProperty ]] ----    defineProperty
[[ HasProperty ]]       ----    has
[[ Get ]]               ----    get
[[ Set ]]               ----    get
[[ Delete ]]            ----    deleteProperty
[[ OwnPropertyKeys ]]   ----    ownKeys   
```
## 代理Object
对于一个对象来说，“读取” 情况实际上应该分为三类：
- 访问属性`obj.foo`
- 判断对象或原型上是否存在给定的key：`key in obj`
- 使用`for-in`循环遍历对象：`for(const key in obj){}`

对于访问属性`obj.foo`是比较好理解的，这样的读取操作可以被 `Proxy` 的 `get` 拦截器给拦截到

而对于 `key in obj` ，其中`in`操作符的运算结果是通过调用一个叫作`HasProperty`的抽象方法得到的，而这个抽象方法的返回值通过调用对象的内部槽`[[HasProperty]]`而得到的，其中`Proxy`的`has`就是内部槽`[[HasProperty]]`的拦截函数

```js
const obj = { foo : 1}
const p = new Proxy(obj , {
  has(target,key){
    track(target,key)
  	return Reflect.has(target,key)
  }
})

effectRegister(()=>{
  'foo' in p  // 之后将会建立依赖关系
})
```
最后是 for-in循环遍历，它对应的拦截函数是 `ownKeys`

```js
const obj = { foo :1 }
const ITERATE_KEY = Symbol()

const p = new Proxy(obj,{
  ownKeys(target){
    // 副作用函数与 ITERATE_KEY 关联
    track(target.ITERATE_KEY)
    return Reflect.ownKeys(target)
  }
})
```
里有个特殊的点，就是对于 `for-in` 循环来说，需要设置一个唯一量`ITERATE_KEY`来作为追踪key，这是因为拦截函数`ownKeys`和`set/get`函数很不一样，`set/get`函数可以拦截到具体操作的`key`，但在`ownKeys`中，只能拿到目标对象`target`，明显，`ownKeys`用于获取一个对象的所有属于自己的键值，这个操作明显不会和任何的键进行绑定。所以可以构造一个唯一的键作为标识，即 `ITERATE_KEY`。

这样之后，就能在副作用函数中进行for-in操作时触发与`ITERATE_KEY`相关联的副作用函数。
```js
const obj = { foo : 1 }
const p = new Proxy(obj , { /*....*/ })

effect(()=>{
  for(const key in p){
    console.log(key) // 建立联系
  }
})

p.bar = 2 // 不能触发副作用函数的执行
```
此时向`p`新增一个`bar`属性并不会直接触发`for-in`的响应式。

因为当为对象p添加新的bar属性时，会触发set拦截函数执行。此时set拦截函数接收到的key就是字符串`bar`，因此最终调用`trigger`函数也只触发与`bar`相关的副作用函数重新执行。因为`for...in`循环在副作用函数只与`ITERATE_KEY`之间建立联系，这和`bar`一点儿关系都没有。

比较好的解决方案就是在添加属性触发`set`的时候把`ITERATE_KEY`相关联的副作用函数也取出来执行，但是需要注意的一点是，如果本身只是改变了原有的值，比如：`obj.foo = 100`，也将`ITERATE_KEY`的关联副作用函数取出来执行的话就很浪费性能了，所以在代码设计上，还需要区分**新增属性**和**原有属性变值**之间的区别，实现的代码基本如下：
```js
// 将 新增属性添加 和 原由属性变值 抽象成一个枚举值
const TriggerType = {
  SET:'SET',
  ADD:'ADD'
}

const p = new Proxy(data, {
  get(target, key) {
    track(target, key);
    return target[key];
  },
  set(target, key, newVal,receiver) {
    // 判断这个key是不是原始对象上已经存在的，存在--‘SET’,不存在--’ADD‘
    const type = 
      Object.prototype.hasOwnProperty.call(target,key)
      ? TriggerType.SET 
      : TriggerType.ADD
    const res = Reflect.set(target,key,newVal,receiver)
    target[key] = newVal;
    trigger(target,key,type);
    return res;
  },
});

function trigger(target, key, type) {
  const depsMap = bucket.get(target);
  if (!depsMap) return;
  // 存储依赖结合
  const effects = depsMap.get(key);
  // 运行依赖集合
  const effectsToRun = new Set();
  effects &&
    effects.forEach((effectFn) => {
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn);
      }
    });
  // 如果是新增属性,将ITERATE_KEY对应的副作用函数取出来放入运行依赖集合中益气执行
  if (type === TriggerType.ADD) {
    // 取得与 ITERATE_KEY 相关联的副作用函数
    const iterateEffects = depsMap.get(ITERATE_KEY);
    iterateEffects &&
      iterateEffects.forEach((effectFn) => {
        if (effectFn !== activeEffect) {
          effectsToRun.add(effectFn);
        }
      });
  }

  effectsToRun.forEach((effectFn) => {
    if (effectFn.options.scheduler) effectFn.options.scheduler(effectFn);
    else effectFn();
  });
}
```
对于删除也是同理，当操作类型为 `ADD`或 `DELETE`时，也需要触发与`ITERATE_KEY`相关联的副作用函数重新执行，当然对于`Proxy`来说，需要使用`deleteProperty`拦截函数去拦截`delete`操作符
```js
const p = new Proxy(obj,{
  deleteProperty(target,key){
    // 检查被操作属性是否是对象自己的属性
    const hadKey = Object.prototype.hasOwnProperty.call(target,key)
    // 使用 Reflect.deleteProperty 完成属性的删除
    const res = Reflect.deleteProperty(target,key)
    if(res && hadKey) trigger(target,key,'DELETE')
    return res
  }
})
```
## 深响应与浅响应
现在设计一个`reactive`函数对`Proxy`进行简单的封装
```js
function reactive(obj){
  return new Proxy(obj,{
    //...
  })
}
```
`reactive`函数目前是浅响应的
```js
const obj = reactive( { foo: { bar : 1 } )

effectRegister(()=>{
  console.log(obj.foo.bar)
})

// 修改 obj.foo.bar 的值，并不能触发响应
obj.foo.bar = 2
```
因为读取`obj.foo.bar`需要通过`Reflect`，`Reflect`在先读取`obj.foo`时返回的一个普通对象`{ bar : 1}`，这不是一个响应式对象，所以无法正确建立响应联系。根据需求，现在可以设计两个函数`reactive`负责深响应，`shallowReflect`负责浅响应。

```js
function createReactive(obj,isShallow){
  return new Proxy(obj,{
    // 拦截 读取
    get(target, key, reciever){
      const res = Reflect.get(target, key, receiver)
      track(target, key)
      if(isShallow) return res
      if(typeof res === 'object' && res !== null) return reactive(res)
      return res
    }
  })
}

function reactive(obj){
  return createReactive(obj)
}

function shallowReactive(obj){
	return createReactive(obj, true)
}
```
## 只读和浅只读
某些数据希望是只读的，用户修改只读数据时，就会收到一条警告信息，其形式如下：
```js
const obj = readonly({foo:1})
obj.foo = 2 // 修改数据，得到警告
```
同时，既然一个数据是只读的，就意味着任何方式都不能去修改它，也就没有必要为只读数据建立响应联系，也就是在`get`拦截函数中不需要调用`track`函数去追踪响应
```js
function createReactive(obj, isShallow = false , isReadonly = true){
  
  get(target, key, reciver){
    if(!isReadonly){
      track(target,key)
    }
    const res = Reflect.get(target,key,reciever)
    if(isShallow) return res
    if(typeof res === 'object' && res !== null){
      return isReadonly ? readonly(res) : reactive(res)
    }
    return res
  }

  set(target ,key ,newVal ,receiver){
    if(isReadOnly){
      console.warn(`属性${key}是只读的`)
      return true
    }
    //...
  }
}

// 使用
function readOnly(obj){
  return createReactive(obj, false, true)
}
function shallowReadOnly(obj){
  return createReactive(obj , true , true)
}
```
实际开发中，`ReadOnly`帮助我们可以设置一些“纯静态对象”，它内部的值是不可被改变的，`const`只能设置一些不变的原始值，而`ReadOnly`通过`Proxy`包装，拦截`set`函数来完成这一目标。

## 代理数组
前文提过，在JS中存在两种对象：**常规对象** 和 **异质对象**，数组就属于一类**异质对象**，原因在于数组对象的`[[DefineOwnProperty]]`内部方法与常规对象不同。如果只是通过索引读取和设置元素的值，那么`set`和`get`是完全够用的，但是数组相比普通对象来说，还是多了很多不同的“读取”操作：
- 访问数组的长度`.length`
- 数组当作对象同样使用`for...in`循环
- 使用`for...of`迭代遍历
- 数组的原型方法`concat` `join` `every` `some` `find` `findIndex` `inlcudes`

先来探讨一下数组的长度和索引之间的关系，其实数组的`[[Set]]`内部槽其实是依赖于`[[DefineOwnProperty]]`，原因有以下两点：如果直接通过索引设置元素实际上会隐式修改到数组的`.length`属性，所以在触发响应时，也应该触发与`length`属性相关联的副作用函数重新执行。
```js
const arr = reactive(['foo'])
makeEffect(()=>{
  console.log(arr.length)
})
arr[10] = 'bar' // 这里隐式修改到了arr的length属性
```
为了实现对`length`属性的监听拦截，应该增加一个对数组类型的判断。如果设置的索引值大于数组的长度，则被视为ADD操作，如果设置的索引值小于数组长度，则被视为SET操作。
```js
  set(target, key, newVal,receiver) {
    if(isReadOnly){
      console.warn(`属性${key}是只读的`)
      return true
    }
    // 如果属性不存在，则说明是在添加新的属性，否则是设置已有属性
    const type = Array.isArray(target) ?
      // 如果代理目标是数组，则检测被设置的索引值是否小于数组长度
      // 如果是，则视作 SET 操作，否则是 ADD 操作
          Number(key) < target.length ? TriggerType.SET : TriggerType.ADD
        : Object.prototype.hasOwnProperty.call(target,key) ? TriggerType.SET 
      	: TriggerType.ADD
    const res = Reflect.set(target,key,newVal,receiver)
    target[key] = newVal;
    trigger(target,key,type);
    return res;
  }

trigger(target,key,type){
  // ...
	if(type === 'ADD' && Array.isArray(target)){
    // 取出 length 相关联的副作用函数
    const lengthEffects = depsMap.get('length')
    // 将这些副作用函数添加到 effectsToRun 中
    lengthEffects && lengthEffects.forEach(effectFn => {
      if(effectFn !== activeEffect){
        effctsToRun.add(effectFn)
      }
    })
  }
  // ...
}
```
同理反向思考一下，修改数组的`length`属性也会隐式地影响数组元素。
```js
const arr = reactive(['foo','bar'])
makeEffect(()=>{
  console.log(arr.length = 1) // bar属性消失了
})
```
当然并非所有对`length`属性的修改都会影响数组中的已有元素，如果将`length`属性设置为15，那么无论如何上影响不到15之前的元素，那么15之前的元素对应的副作用函数就没必要执行。解决方案为，在`set`函数中触发`trigger`时，传入新值，然后对于索引大于或等于新的length值的元素，把所有相关联的副作用函数取出并添加到`effectsToRun`中等待执行
```js
set(){
  //...
  trigger(target,key,type,newVal)
  //...
}

// 为 trigger 函数增加第四个参数，newVal，新值
trigger(target,key,type,newVal){
  //...
	if(Array.isArray(target) && key === 'length'){
    // 对于索引大于或等于新的length值的元素
    // 需要把所有相关联的副作用函数取出并添加到 effectsToRun 中执行
  	depsMap.forEach((effects,key)=>{
      if(key >= newVal){
        effects.forEach(effectFn => {
          //...执行
        })
      }
    })
  }
  //...
}
```
这样差不多就完成了，现在再来讨论一下数组的遍历操作，如果使用for...in遍历，那么和前文的遍历常规对象并无差异，因此同样可以使用ownKeys拦截函数来进行拦截。不同的是，前文中对象通过ITERATE_KEY作为key，且只有在新增属性和删除属性才会触发循环重新执行，但是数组添加新元素和修改数组长度，只要和length属性沾边的，都需要重新进行执行，那么对于ownKeys拦截函数需要做一些修改
```js
ownKeys(target){
  track(target,Array.isArray(target) ? 'length' : ITERATE_KEY)
  return Reflect.ownKeys(target)
}
```
对于`for...of`遍历，实际上内部通过迭代器进行实现，迭代数组时，只需要在副作用函数与数组长度和索引之间建立响应联系就能实现响应式的`for...of`迭代，实际上前文已经实现了，但也同时因为内部实现原因，`for...of`循环会读取数组的`Symbol.iterator`属性。该属性是一个`symbol`值，为了避免发生意外的错误以及对性能上的考虑，不应该在副作用函数与`Symbol.iterator`这样的`symbol`值之间建立响应联系。所以，需要在触发`track`函数的时候注意提前一个判断即可。

:::tip
最后，其实数组的方法内部基本上都依赖了对象的基本语义。所以大部分情况下，是不太需要做特殊处理的
:::