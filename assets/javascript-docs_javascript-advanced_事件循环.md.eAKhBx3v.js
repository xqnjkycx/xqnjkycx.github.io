import{_ as t,c as i,o as l,U as a}from"./chunks/framework.qUHj8-gn.js";const s="/assets/浏览器进程.olctsXb4.png",r="/assets/消息队列.KnC2R1Ry.png",o="/assets/同步阻塞.nHTw4WKN.png",e="/assets/异步执行.SqpeH2ps.png",S=JSON.parse('{"title":"事件循环","description":"","frontmatter":{},"headers":[],"relativePath":"javascript-docs/javascript-advanced/事件循环.md","filePath":"javascript-docs/javascript-advanced/事件循环.md","lastUpdated":1708443052000}'),n={name:"javascript-docs/javascript-advanced/事件循环.md"},c=a('<h1 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h1><p>浏览器是一个多进程多线程的应用程序：<strong>浏览器进程</strong>，<strong>网络进程</strong>，<strong>渲染进程</strong> 等等。 <img src="'+s+'" alt="image"></p><ul><li>浏览器进程负责浏览器的页面展示，用户交互（click），子进程管理。浏览器内部会启动多个线程来处理不同的任务。</li><li>网络进程 负责加载网络资源。网络进程内部会启动多个线程来处理不同的网络任务</li><li><strong>渲染进程</strong>：渲染进程启动后，会开启一个渲染主线程，主线程负责执行HTML，CSS，JavaScript代码，每个标签页会开启一个新的渲染进程</li></ul><h2 id="渲染主线程如何工作" tabindex="-1">渲染主线程如何工作 <a class="header-anchor" href="#渲染主线程如何工作" aria-label="Permalink to &quot;渲染主线程如何工作&quot;">​</a></h2><p>渲染主线程非常繁忙，它需要处理的任务包括但不限于：</p><ul><li>解析HTML</li><li>解析CSS</li><li>计算样式</li><li>布局</li><li>处理图层</li><li>每秒把页面画60次</li><li>执行JS代码</li><li>执行事件处理函数</li><li>执行计时器的回调函数</li><li>......</li></ul><p>对于浏览器来说：</p><ul><li>代码执行好好的，此时用户点击了按钮，应该执行当前代码还是用户点击的代码？</li><li>代码执行好好的，一个计时任务到达了，应该执行当前代码还是执行计时任务代码？</li></ul><p>需要去设计一个好的调度任务的机制，最经典的方式就是<strong>消息队列：</strong><img src="'+r+'" alt="image"></p><ul><li>在最开始时，渲染主线程会进行一个无限循环</li><li>每一次循环会检查消息队列是否有任务。如果有，取出来执行，执行之后再进入到下一次循环，否则进入休眠状态</li><li>其他所有线程（或者其他进程的线程）可以随时向消息队列的队尾添加任务。如果主线程是休眠的，那么唤醒主线程</li></ul><p><strong>这么一个过程就可以被称之为事件循环</strong></p><h2 id="什么是异步" tabindex="-1">什么是异步 <a class="header-anchor" href="#什么是异步" aria-label="Permalink to &quot;什么是异步&quot;">​</a></h2><p>代码执行过程中，会存在一些无法立即处理的任务，比如：</p><ul><li>计时任务 — setTimeout，setInterval</li><li>网络通信 — XHR，fetch</li><li>用户操作后需要执行的任务 — addEventListener 如果让渲染主线程等待这些任务的时机达到，主线程上会长期处于<strong>阻塞</strong>的状态： <img src="'+o+'" alt="image"><strong>可以看到阻塞了太长时间，所以渲染主线程千万不能被阻塞，因为它承担了很多重要的任务</strong></li></ul><p><strong>所以需要使用异步的方式，使得主线程永不阻塞：</strong></p><p><img src="'+e+'" alt="image"></p><h2 id="任务存在优先级" tabindex="-1">任务存在优先级 <a class="header-anchor" href="#任务存在优先级" aria-label="Permalink to &quot;任务存在优先级&quot;">​</a></h2><p>其实任务没有优先级，毕竟都是进队列先进先出</p><p>但是消息队列是有优先级的</p><ul><li>每个任务都有一个任务类型，同一个类型的任务必须在一个队列中，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取出任务执行</li><li>浏览器必须准备好一个微队列，微队列的任务优先于其他任务的执行</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>随着浏览器的复杂度提高，W3C不再使用宏队列这种说法</p></div><p>在目前的 chrome 的实现中，包含了至少三种队列：</p><ul><li>延时队列：用于存放计时器达到后的回调任务，优先级<strong>中</strong></li><li>交互队列：存放用户操作后产生的事件处理任务，优先级<strong>高</strong></li><li>微队列：放微任务，优先级<strong>最高</strong></li></ul>',23),p=[c];function d(_,g,u,m,h,v){return l(),i("div",null,p)}const b=t(n,[["render",d]]);export{S as __pageData,b as default};
