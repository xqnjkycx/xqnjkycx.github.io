import{_ as s,c as i,o as a,U as e}from"./chunks/framework.PFQuerqu.js";const n="/assets/commonjs.SDlmXRp3.png",p="/assets/Node引入模块流程.64Q76-1C.png",t="/assets/node文件定位流程.GNK4QwV1.png",l="/assets/module引用关系.jUFOtcXG.png",h="/assets/应用程序和操作系统的异步关系.xr-fUJ8Z.png",o="/assets/异步IO流程.kHt9g-kt.png",C=JSON.parse('{"title":"深入浅出NodeJS","description":"","frontmatter":{},"headers":[],"relativePath":"nodejs-docs/深入浅出NodeJS.md","filePath":"nodejs-docs/深入浅出NodeJS.md","lastUpdated":1708786968000}'),d={name:"nodejs-docs/深入浅出NodeJS.md"},k=e(`<h1 id="深入浅出nodejs" tabindex="-1">深入浅出NodeJS <a class="header-anchor" href="#深入浅出nodejs" aria-label="Permalink to &quot;深入浅出NodeJS&quot;">​</a></h1><p>这篇笔记主要是来源于我读的《深入浅出Node.js》一书中的记录的知识点📝</p><p>我非常推荐你去读一下原书，会对自己的成长特别大。</p><p>我在这本书里面基本理清了Node背后的运行机制和工作原理，其中关于异步方面的代码设计非常优秀，我借鉴了其中的 <strong>中间件</strong> 思想，去设计了工作中的图片列表组件（虽然说组件是Web端的，但是其中的设计思想是共同的😛）</p><p><a href="https://blog.songqingbo.cn/pdf/nodejs/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BANode.js.pdf" target="_blank" rel="noreferrer">我推荐给你的深入浅出Node.js原版pdf</a></p><div class="tip custom-block"><p class="custom-block-title">温馨提示</p><p>呃呃，这本书内容有点多，这个pdf加载会比较慢，我会选择打开网站后去倒杯咖啡🥄</p></div><p>👌我们走起</p><h2 id="简述一下node特点" tabindex="-1">简述一下Node特点 <a class="header-anchor" href="#简述一下node特点" aria-label="Permalink to &quot;简述一下Node特点&quot;">​</a></h2><p>了解Node之前，需要好好清楚Node相较于其它语言的一些特别的点。</p><h3 id="异步io" tabindex="-1">异步IO <a class="header-anchor" href="#异步io" aria-label="Permalink to &quot;异步IO&quot;">​</a></h3><p>在Node中绝大多数的操作都是以异步的方式去进行调用，Node的底层构建了很多的异步I/O的API，从文件读取到网络请求等。这样的意义在于，在Node中，可以非常自然的进行并行I/O操作。每个调用之间不需要等待前面的I/O调用结束。可以在编程模型上极大地提升效率，比如</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/path1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 文件1读取完成</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/path2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 文件2读取完成</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>对于同步I/O来说，它们的耗时任务是两个任务的耗时之和。但是对于异步来说，就是取决于耗时最慢的那一个。</p><h3 id="事件机制与回调函数" tabindex="-1">事件机制与回调函数 <a class="header-anchor" href="#事件机制与回调函数" aria-label="Permalink to &quot;事件机制与回调函数&quot;">​</a></h3><p>通过事件和回调函数，配合异步I/O，将事件发生点暴露给业务逻辑。就比如给读取文件绑定一个读取后的事件，在文件读取完毕之后，只需要关心文件读完后你需要执行的业务逻辑就可以了。</p><p>事件的编程方式具有轻量级，松耦合，关注业务点这些优点。但是事件与事件之间是独立的，如果在多个异步任务下，想要两个不同的事件进行协作就需要一些额外的操作了。</p><p>同时可以看到Node中到处都是回调函数，这主要是还是因为JavaScript语言可以将函数作为参数传递给方法进行调用，自然而然就成为了一种接受异步调用返回结果的最好的方式，但是问题在于，代码编写顺序和执行顺序没有关系，如果习惯了同步编程，由于穿插了异步方法和回调函数，那么在流程控制方面就需要多思考如何编写了。</p><h3 id="单线程" tabindex="-1">单线程 <a class="header-anchor" href="#单线程" aria-label="Permalink to &quot;单线程&quot;">​</a></h3><p>Node的单线程最大好处在于<strong>不用考虑像多线程编程那样去处处在意状态同步的问题，没有锁这种概念，也没有线程上下文交换所带来的性能上的开销。</strong></p><p>但是单线程也有一定的缺点：</p><ul><li>无法利用多核CPU</li><li>错误会引起整个应用退出</li><li>大量计算占用CPU导致无法继续调用异步IO</li></ul><p>像在浏览器的渲染主线程一样，大量的JS计算会阻塞UI的渲染，但是可以通过Web Workers来创建其它工作线程完成计算任务。</p><p>在Node中，如果占满了CPU计算，也会导致完成异步I/O的回调函数没得到及时的执行。Node也有<em>child_process</em>。通过将计算分发到各个子进程中，将大量的计算给分解掉，然后再通过进程之间的事件消息来传递结果，可以很好地保持应用模型的简单和依赖。</p><h2 id="commonjs的模块规范" tabindex="-1">CommonJS的模块规范 <a class="header-anchor" href="#commonjs的模块规范" aria-label="Permalink to &quot;CommonJS的模块规范&quot;">​</a></h2><p>CommonJS对模块的定义十分简单，主要还是分为模块引用，模块定义和模块标识这3个地方。</p><h3 id="模块引用" tabindex="-1">模块引用 <a class="header-anchor" href="#模块引用" aria-label="Permalink to &quot;模块引用&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> math </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;math&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>在CJS中，使用<code>require</code>方法来接受模块标识，以此引入一个模块的API到当前的上下文中。</p><h3 id="模块定义" tabindex="-1">模块定义 <a class="header-anchor" href="#模块定义" aria-label="Permalink to &quot;模块定义&quot;">​</a></h3><p>上下文中提供了<code>exports</code>对象用于导出当前模块的方法或者变量，并且它是唯一的出口。</p><p>在模块中，还存在一个module对象，它代表模块自身，而exports是module的属性。在Node里，一个文件就是一个模块，将方法挂载到exports对象上作为属性即可定义出导出的方式：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="模块标识" tabindex="-1">模块标识 <a class="header-anchor" href="#模块标识" aria-label="Permalink to &quot;模块标识&quot;">​</a></h3><p>标识就是传递给<code>require()</code>方法的参数，它必须是符合小驼峰命名的字符串，或者以.，..开头的相对路径，或者绝对路径。它可以没有文件名后缀.js。</p><p><img src="`+n+`" alt="image"></p><h2 id="为什么esm可以import引入cjs模块-而cjs反过来不行" tabindex="-1">为什么ESM可以import引入CJS模块，而CJS反过来不行？ <a class="header-anchor" href="#为什么esm可以import引入cjs模块-而cjs反过来不行" aria-label="Permalink to &quot;为什么ESM可以import引入CJS模块，而CJS反过来不行？&quot;">​</a></h2><p>这里的本质问题是因为<strong>模块加载的同异步机制问题</strong>。CommonJS的<code>require</code>机制是机制是完全同步的，而ESM的<code>import</code>机制规则是完全异步的。</p><p><code>import</code>是异步的，那么在内部去通过同步的方式模拟一个<code>require</code>流程是可以实现的，但是反过来却不好弄，一个同步的东西是很难加载异步内容的，至少无法通过比较正统的方式解决。</p><p>虽然CommonJS无法通过<code>require</code>去加载一个ESM，但不意味着它就完全不能加载ESM，实际上CommonJS支持<code>import()</code>函数。所以仍然是可以通过<code>import()</code>函数来加载一个ESM</p><p>虽然<code>import * as mod from &#39;xxx&#39;</code>的语法中看起来像是同步的，其实在引擎内部帮助处理了异步的部分。然而在<code>import()</code>函数中，异步依然需要自己处理，它的返回值是一个<code>Promise</code></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xxx&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">mode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><h2 id="nodejs引入模块时-发生了什么" tabindex="-1">NodeJS引入模块时，发生了什么？ <a class="header-anchor" href="#nodejs引入模块时-发生了什么" aria-label="Permalink to &quot;NodeJS引入模块时，发生了什么？&quot;">​</a></h2><p>在Node中引入模块，实际上是需要经历如下3个步骤：</p><ul><li>路径分析</li><li>文件定位</li><li>编译执行</li></ul><p>在完全理解Node的模块引入机制之前，你必须了解<strong>两件关键的事情：</strong></p><p><strong>第一件事：</strong> 在Node中，模块被分为两类，一类是Node提供的模块，称为核心模块。另一类是用户编写的模块，称为文件模块。</p><p>核心模块，在Node源代码的编译过程中，就编译进了二进制执行文件。在Node启动时，部分核心模块就被直接加载进了内存中去，所以这类核心模块在被引入时，文件定位和编译执行这两步其实直接被跳过了，并且在路径分析中被优先判断。所以它的加载速度是最快的。</p><p>文件模块，是运行时动态加载的，需要经过完整的 路径分析👉文件定义👉编译执行 过程。所以速度较核心模块慢。</p><p><img src="`+p+'" alt="image"></p><p><strong>第二件事</strong>：和前端浏览器一样，Node也会有缓存机制来提升性能，Node对于引入过的模块都会进行缓存，从而减少二次引入带来的开销，与前端浏览器不同的是，<strong>浏览器缓存的是静态脚本文件</strong>，而<strong>Node缓存的是编译和执行之后的对象</strong>。不论是核心模块还是文件模块，<code>require</code>方法对于相同的模块的二次加载一律采用缓存优先的方式，并且这是最高级优先级的。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>当然核心模块的缓存检查 优先于 文件模块的缓存检查。</p></div><h3 id="路径分析" tabindex="-1">路径分析 <a class="header-anchor" href="#路径分析" aria-label="Permalink to &quot;路径分析&quot;">​</a></h3><p><code>require</code>接受标识符来定义要引入的模块，但标识符号的形式不同，模块的查找和定位都有不同程度上的差异。</p><p>模块标识符在Node中主要分为以下几类：</p><ul><li>核心模块，如 http，fs，path 模块</li><li>. 或 .. 开头的相对路径文件模块</li><li>以 / 开始的绝对路径文件模块</li><li>非路径形式的文件模块，如自定义的 connect 模块</li></ul><p><strong>核心模块</strong> 核心模块的加载仅次于缓存加载，如果试图加载一个与核心模块标识符相同的自定义模块，那么会失败。假如自己编写了一个http用户模块，想要加载成功，必须选择一个不同的标识符或换用路径的方式加载。由于二机制执行代码已经被Node编译了，所以加载速度最快</p><p><strong>路径形式存在的文件模块</strong> require方法会将路径转换为真实的路径，并以真实路径作为索引，将编译执行后的结果放入到缓存中，以便于二次加载时更快，由于路径指明了具体的文件位置，所以加载速度慢于核心模块</p><p><strong>自定义模块</strong> 自定义模块指的是非核心模块，也不是路径形式的标识符，比如<code>const express = require(&#39;express&#39;)</code>。 它是一种特殊的文件模块，可能是一个文件或者包的形式。这类模块的查找是最费时的，也是所有方式中最慢的一种。</p><p>因为它要Node去通过标识符去生成模块路径，而模块路径的生成规则如下：</p><ul><li>当前文件目录下的node_modules目录</li><li>父目录下的node_modules目录</li><li>父目录的父目录下的node_modules目录</li><li>路径沿上递归，直到根目录下的node_modules目录</li></ul><p>它的生成方式与JS中的原型链或作用链的查找方式十分类似。Node会在加载过程中，逐个尝试模块路径中的路径，直到找到目标文件位置。</p><h3 id="文件定位" tabindex="-1">文件定位 <a class="header-anchor" href="#文件定位" aria-label="Permalink to &quot;文件定位&quot;">​</a></h3><p>在文件定位过程中，Node还进行了包括文件扩展名的分析，目录和包的处理</p><p><strong>文件扩展名解析</strong><code>require</code>在分析标识符的过程中，会出现标识符中不包含文件扩展名的情况。这种情况下，Node会按照 .js .json .node 的顺序去补充扩展名，进行以此尝试。</p><p>在尝试过程中，需要调用fs模块同步阻塞式地判断文件是否存在。</p><div class="tip custom-block"><p class="custom-block-title">提升性能的小技巧</p><p>因为Node是单线程的，如果是 .node 和 .json 文件，在传递require的标识符中带上扩展名，会加快一点速度。</p></div><p><strong>目录分析和包</strong> 在分析标识符的过程中，<code>require()</code>通过分析文件扩展名之后，可能没有查找到对应的文件，但是却得到了一个目录，此时Node会将目录当作一个包处理。</p><p>这个过程中，Node在当前目录下查找<code>package.json</code>，通过<code>JSON.parse()</code>解析出包的描述对象，从中取出main属性来制定文件名进行定位。如果main指定的文件名错误，或者根本就没有<code>package.json</code>文件，Node将 index 当作默认文件名，然后依次查找<code>index.js</code>，<code>index.json</code>，<code>index.node</code>。如果还没找到直接报错。</p><p><img src="'+t+`" alt="image"></p><h3 id="解析编译" tabindex="-1">解析编译 <a class="header-anchor" href="#解析编译" aria-label="Permalink to &quot;解析编译&quot;">​</a></h3><p>在Node中，每个文件模块都是一个对象，它的定义如下</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">id</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">parent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.id </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> id;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.exports </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {};</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(parent </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> parent.children){</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    parent.children.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.filename </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.loaded </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.children </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>编译和执行是引入文件模块的最后一个阶段，对于不同的文件扩展名，其载入方法也不同，这里具体拿js文件做解释😘。</p><p>对于js文件，通过fs模块同步读取文件后进行编译执行。每一个编译成功的模块都会将其文件路径作为索引缓存在<code>Module._cache</code>对象上，用来提高二次引入的性能。</p><p>在编译过程中，Node对获取的js文件内容进行<strong>头尾函数</strong>包装，一个正常的JS文件内容会被包装为如下的样子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> exports </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 这个很重要哦</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">__filename</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">__dirname</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> math </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;math&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  exports</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">area</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">radius</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">PI</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> radius </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> radius;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>这样每个模块文件之间都进行了作用域隔离，当前模块对象的<code>exports</code> <code>require</code> <code>module</code>以及在文件定位中得到的完整路径文件路径和文件目录<code>__filename</code>和<code>__dirname</code>作为参数传入这个函数中。</p><p>这就是为什么这些变量并没有定义在每个模块文件中，却能直接使用的原因。在执行之后，模块的exports属性返回给了调用方。exports属性上的任何一个方法和属性都可以被外部调用到。</p><p>也是为什么存在exports的情况下，还存在module.exports，理想情况下，只要赋值给exports上的属性即可。</p><div class="warning custom-block"><p class="custom-block-title">不要直接复制给exprots</p><p>这样赋值会切断exports对module.exports的引用关系，最后导致失败</p></div><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 错误的做法</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="核心模块为什么快" tabindex="-1">核心模块为什么快？ <a class="header-anchor" href="#核心模块为什么快" aria-label="Permalink to &quot;核心模块为什么快？&quot;">​</a></h2><p>因为大部分核心模块要么全部被C/C++编写，要么通过C/C++模块完成主要核心，由JavaScript实现封装。这样的话综合了脚本语言开发速度快，而静态语言编译性能快。在进行文件编译时候，这些核心模块可以很快编译为二进制文件加载到内存中，不需要经过上面的<strong>路径解析</strong>，<strong>文件定位</strong>，<strong>编译</strong>的过程了</p><h2 id="npm与包的关系" tabindex="-1">NPM与包的关系 <a class="header-anchor" href="#npm与包的关系" aria-label="Permalink to &quot;NPM与包的关系&quot;">​</a></h2><p>Node组织了自身的核心模块，也使得第三方文件模块可以有序地编写和使用。但是在第三方模块中，模块和模块之间依然是散落的，相互之间不能之间引用。而在模块之外，包和NPM则是将模块联系起来的一种机制。</p><p>Node对模块规范的实现，一定程度上解决了变量依赖，依赖关系等代码组织性问题。包的出现，则是在模块的基础上进一步组织了JS代码。</p><p><img src="`+l+`" alt="module的引用关系"></p><p>CommonJS的包规范和定义其实非常简单，它由包结构和包描述文件两部分组成，前者用于组织包中的各种文件，后者描述包的相关信息。</p><h3 id="包结构" tabindex="-1">包结构 <a class="header-anchor" href="#包结构" aria-label="Permalink to &quot;包结构&quot;">​</a></h3><p>一个完全符合CommonJS规范的包目录应该包含如下这些文件</p><ul><li>package.json : 包描述文件</li><li>bin : 用于存放可执行二进制文件的目录</li><li>lib：用于存放JavaScript代码的目录</li><li>doc : 用于存放文档的目录</li><li>test : 用于存放单元测试用例的代码</li></ul><h3 id="包描述文件" tabindex="-1">包描述文件 <a class="header-anchor" href="#包描述文件" aria-label="Permalink to &quot;包描述文件&quot;">​</a></h3><p>包描述文件就是<code>package.json</code>文件，这里介绍一下必需常见的字段：</p><ul><li>name 包名。包名必须是唯一的，以免对外公布时产生重名冲突的误解</li><li>description 包简介</li><li>version 版本号</li><li>keywords 关键词数组 NPM中主要用用户可以快速找到你编写的包</li><li>dependencies 使用当前包所需要依赖的包列表，NPM会通过这个熟悉帮助自动加载依赖的包</li><li>scripts 脚本说明对象，它主要被包管理器用来安装，编译，测试和卸载包，就像如下</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:{</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;install&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;install.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;uninstall&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;uninstall.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;build&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;build.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;doc&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;make-doc.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &quot;test&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;test.js&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ul><li>author 包作作者</li><li>bin 一些包作者希望包可以作为命令行工具使用。<strong>配置好bin字段后，通过npm install package_name -g命令可以将脚本添加到执行路径，之后可以在命令行中直接执行。通过-g命令安装的模块包称为全局模式，比如npm install express -g安装express后，就可以在命令行中使用express命令了</strong></li><li>main 模块引用方法<code>require</code>在引入包时，会优先检查这个字段，并将其作为包中其余模块的入口。如果不存在，就像前面说过，它会·查找包目录下的<code>index.js</code> <code>index.node</code> <code>index.json</code>这些文件</li><li>devDependencies 一些模块只在开发时需要依赖。</li></ul><h3 id="npm" tabindex="-1">NPM <a class="header-anchor" href="#npm" aria-label="Permalink to &quot;NPM&quot;">​</a></h3><p>CommonJS包规范是理论，而NPM是其中一种实践。对于Node而言，NPM帮助完成了第三方模块的发布，安装和依赖。借助NPM，Node与第三方模块之间形成了很好的一个生态系统。</p><h2 id="企业内部npm仓库" tabindex="-1">企业内部NPM仓库 <a class="header-anchor" href="#企业内部npm仓库" aria-label="Permalink to &quot;企业内部NPM仓库&quot;">​</a></h2><p>在企业内部应用中使用NPM与开源社区中的使用由一定差别。企业的限制在于，一方面需要享受到模块开发带来的低耦合和项目组织上的好处，另一方面也要考虑到模块保密性的问题。</p><p>为了同时能够享受到NPM上的包，同时对自己的包进行保密和限制，就需要搭建本地npm仓库了。</p><p>企业的npm仓库的好处在于，局部npm仓库可以选择不同步官方源仓库中的包。对于企业内部而言，私有的可重用模块可以打包到局域NPM仓库中，这样可以保持更新的中心化，不至于让各个小项目各自维护相同功能的模块，杜绝通过复制粘贴实现代码共享的行为。</p><h2 id="node为什么选择异步i-o" tabindex="-1">Node为什么选择异步I/O <a class="header-anchor" href="#node为什么选择异步i-o" aria-label="Permalink to &quot;Node为什么选择异步I/O&quot;">​</a></h2><p>Node使用异步I/O主要从<strong>用户体验</strong>和<strong>资源分配</strong>这两个方面来考虑的</p><h3 id="用户体验" tabindex="-1">用户体验 <a class="header-anchor" href="#用户体验" aria-label="Permalink to &quot;用户体验&quot;">​</a></h3><p>因为Node是单线程的。在Node服务中，假如一个资源来自于两个不同位置的数据的返回，第一个资源需要M毫秒的耗时，第二个资源需要N毫秒的耗时。如果采用同步的方式，代码大致如下：</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>// 消费时间M</span></span>
<span class="line"><span>getData(&#39;from_db&#39;, result=&gt;{})</span></span>
<span class="line"><span>// 消费时间N</span></span>
<span class="line"><span>getData(&#39;from_remote_api&#39;, result=&gt;{})</span></span></code></pre></div><p>那么消耗的时间为<code>M+N</code></p><p>如果采用异步的方式，第一个资源的获取并不影响第二个资源，第二个资源的请求开始并不依赖第一个资源的结束。如此，就可以享受到并发的优势:</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>getData(&#39;from_db&#39;, result=&gt;{</span></span>
<span class="line"><span>  // 消费时间M</span></span>
<span class="line"><span>})</span></span>
<span class="line"><span>getData(&#39;from_remote_api&#39;, result=&gt;{</span></span>
<span class="line"><span>  // 消费时间N</span></span>
<span class="line"><span>})</span></span></code></pre></div><p>那么消耗的时间为<code>max(M,N)</code>，那么随着应用复杂性的增加，同步的方式将会爆炸，只有让后端能够快速响应资源，才能让前端更有体验。</p><h3 id="资源分配" tabindex="-1">资源分配 <a class="header-anchor" href="#资源分配" aria-label="Permalink to &quot;资源分配&quot;">​</a></h3><p>在资源的层面异步I/O也有很强的必要性。</p><p>如果在业务场景中存在一组互不相关的任务需要完成，主流的方法是：</p><ul><li>单线程串行依次完成</li><li>多线程并行完成</li></ul><p>如果创建线程的开销远小于并行执行，那么多线程依然是首选的。多线程的代价在于创建线程和执行期线程上下文切换的开销较大，如果在很复杂的业务中，多线程编程需要面临锁，状态同步等问题，但多线程在多核CPU上能够有效提升CPU同步的问题。</p><p>而串行执行的缺点在于性能，任意一个耗时任务都会导致后续执行代码被阻塞，导致服务资源不能被很好的利用。</p><p>所以Node在两者之间给出了一个好的方案：利用单线程原理避免多线程的锁，状态同步问题。利用异步原理任务阻塞，更好的利用资源。</p><p>这样可以力求在单线程上将资源分配的更高效。同时Node，为了弥补单线程无法利用多核CPU的缺点，Node也提供了类似前端浏览器中的Web Workers的子进程，该子进程可以通过工作进程高效地利用CPU和I/O。</p><p><img src="`+h+'" alt="image"></p><h2 id="node如何实现异步i-o" tabindex="-1">Node如何实现异步I/O <a class="header-anchor" href="#node如何实现异步i-o" aria-label="Permalink to &quot;Node如何实现异步I/O&quot;">​</a></h2><p>完成整个完整的异步I/O环节主要依靠以下四个方面:</p><ul><li>事件循环</li><li>观察者</li><li>请求对象</li><li>执行回调</li></ul><h3 id="事件循环" tabindex="-1">事件循环 <a class="header-anchor" href="#事件循环" aria-label="Permalink to &quot;事件循环&quot;">​</a></h3><p>在Node进程启动时，实际上会创建一个类似于<code>while(true)</code>的循环，每次执行循环体都可以被看成一次<strong>Tick</strong>，每个<strong>Tick</strong>的过程就是查看是否有事件待处理，如果有，就需要取出事件和相关的回调函数。如果存在相关联的回调函数，就执行它们，然后进入下一个循环。</p><h3 id="观察者" tabindex="-1">观察者 <a class="header-anchor" href="#观察者" aria-label="Permalink to &quot;观察者&quot;">​</a></h3><p>在每个Tick中，需要观察者来判断事件是否需要处理。</p><p>每个事件循环中有一个或多个观察者，而判断是否有事件要处理的过程就是向这些观察者查询是否要处理的事件。<strong>前端的浏览器也有类似的机制，事件可能来自用户的点击或者加载某些文件时产生，这些产生都有对应的观察者，比如<code>addEventListener</code></strong>，在Node里面，事件主要来自于网络请求，文件I/O等等，这些事件就对应了观察者有文件I/O观察者，网络I/O观察者等。</p><p>事件循环本身是一个典型的 <em>生产者/消费者</em> 模型。异步I/O，网络请求等则是事件的生产者，源源不断的为Node提供不同类型的事件，这些事件被传递到对应的观察者里去，事件循环就从观察者那里取出事件来进行处理。</p><h3 id="请求对象" tabindex="-1">请求对象 <a class="header-anchor" href="#请求对象" aria-label="Permalink to &quot;请求对象&quot;">​</a></h3><p>对于Node的异步I/O的调用而言,回调函数不由开发者来调用。而是由系统等待到时机之后在执行调用，中间有个过程，也就是JavaScript发起调用到内核执行完I/O操作的过渡过程中，存在一种名为<strong>请求对象</strong>的产物。</p><p>比如调用<code>fs.open(path,flags,mode,callback)</code>时，当调用到底层的Node的内建模块时，会创建一个请求对象，<strong>其中JavaScript层传入的参数和当前callback都被封装到这个请求对象上</strong>。</p><p>这个对象包装完毕时，就被推入到底层的线程池去等待，由于当前I/O操作在线程池中等待执行，不管是否阻塞I/O，反正不会影响到后续的JavaScript线程的执行了，从而达到了异步的目的。</p><h3 id="执行回调" tabindex="-1">执行回调 <a class="header-anchor" href="#执行回调" aria-label="Permalink to &quot;执行回调&quot;">​</a></h3><p>在每次Tick中，事件循环的I/O观察者，都会去检查底层的线程池是否有执行完的请求，如果存在会将请求对象加入到观察者的队列中，然后将其当作事件处理，然后把请求对象上的回调函数取出来执行就行了。 <img src="'+o+`" alt="image"></p><h2 id="process-nexttick" tabindex="-1">process.nextTick <a class="header-anchor" href="#process-nexttick" aria-label="Permalink to &quot;process.nextTick&quot;">​</a></h2><p>在不完全了解<code>process.nextTick</code>之前，不少人会为了立即执行一个异步任务，通过<code>setTimeout</code>来达到这种效果：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...todo</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">TIP</p></div>`,139),r=[k];function c(E,g,u,y,m,F){return a(),i("div",null,r)}const q=s(d,[["render",c]]);export{C as __pageData,q as default};
