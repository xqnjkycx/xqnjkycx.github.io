# 模块化
随着代码量的增加，**复用**是提升开发和运行效率的必需途径。

在早期的 JavaScript 开发中，由于缺少了模块化的支持，开发者需要将所有的代码都写到一个文件中去。这种方式存在很多问题：
- **命名冲突**:所有的代码都存在一个作用域，不同的代码可能会使用相同的变量名，导致命名的冲突问题。
- **全局污染**:所有的代码都在全局作用域中执行，可能会污染全局的变量。
- **难以维护**:代码量过于庞大，上下翻阅麻烦和难以维护。

后期也陆续出现了一些模块化的解决方案，比如CommonJS，AMD和CMD等。
- CommonJS：常用于服务端的模块化规范，主要的特点是同步加载模块，用`require`和`exports`来导入和导出模块。
- AMD：常用于浏览器端的模块化规范，主要特点是异步加载模块，使用`define`和`require`来导入和导出模块。
- UMD：一种兼容 CommonJS 和 AMD 的模块化规范，可以在浏览器端和服务端中通用。

这些模块化规范在一定的程度上解决了模块化的问题，但是由于它们都是基于特定的语法和加载器实现的，所以没有纳入标准只中。而且大多数在浏览器环境中，其本质还是需要靠 window 全局共享作为媒介。

## ESM的基本语法
ESM 是ECMAScript 官方的模块化标准规范。

### 导出模块
在ESM中，可以使用`export`关键字将模块中的变量，函数或类导出为一个模块。比如：
```js
// 导出一个变量
export const name = 'John';

// 导出一个函数
export function sayHello() {
  console.log('Hello!');
}

// 导出一个类
export class Person {
  constructor(name) {
    this.name = name;
  }
}

// 批量导出
export {
    var1, var2
};
```

### 导入模块
可以使用 `import` 关键字来导入其他模块中的变量。例如：
```js
// 导入一个变量
import { name } from './module.js';

// 别名
import { name as myName } from './module.js';

// 聚合
import * as person from './module.js';
```
不仅仅 JavaScript 文件可以被 import 导入，那么在实际项目中使用过导入图片，视频，JSON等。这些虽然基本都是依靠构建工具来完成的，但也不完全是，其中 **JSON** 就可以作为 JavaScript 的补充，并且被原生支持，在Node 环境里也可以直接使用，甚至实现了[import assertions](https://v8.dev/features/import-assertions)

```js
import data from './data.json' assert { type: 'json' };

// dynamic
import('./foo.json', { assert: { type: 'json' }});
```

### 默认导出
在ESM中可以使用`export default`语法来导出一个模块的默认值。一个模块只能存在一个默认导出。比如
```js
// 导出一个默认值
export default function() {
  console.log('Default export');
}

// 导入一个默认值
import myFunc from './module.js';
```

### 动态导入
ESM 也可以支持动态导入，可以在运行时根据条件来导入模块，这样有利于异步导入：
```js
// 动态导入一个模块
import('./module.js')
  .then(module => {
    // 使用导入的模块
    console.log(module.name);
  })
  .catch(error => {
    console.error(error);
  });
```

## ESM的特性
### 静态引用
ESM本身具有很多优点，其中最重要的在于它的**对依赖的静态引用。**
**静态引用**的反例就是Node的 `require`
```js
const fn = require(`lodash/${fn}.js`);
```
`require`由于是动态引入，也就是在代码执行时才引入模块。导致无法提前知道这个文件有哪些依赖。

这对于服务端环境还好，因为文件都存在于本地，即时访问比较快，但是对于浏览器却不行，因为**无法通过静态分析得到足够完整的依赖图谱**，导致不能实现提前的模块加载。

如果不能提前加载，那么意味着就会存在明显的串行请求阻塞，从而拖慢了页面的加载速度。

所以，现代的构建工具，比如Vite，都会默认把依赖项声明到`link preload`中，从而实现预加载。
![image](./assets/%E9%A2%84%E5%8A%A0%E8%BD%BD.png)
由于注定是对其依赖的声明都是静态的，或者说是固定的，那么就既不能在import语句中使用变量，也不能把import声明到非顶端的位置：

```js
import a from `${path}` // ❌

var fn; import m from './m'; // ❌
```
静态依赖分析的好处就在于`Tree Shaking`。

对这个特性应用得比较强的是著名的大包工具`Rollup`。它能实现的`Tree Shaking`的前提条件就是代码需要是ESM格式。

### 引用传递
**引用传递** 是ESM与其他传统模块化方案的一项关键区别。

比如在CommonJS中
```js
exports.bar = 23;

exports.getBar = function() {
    return bar;
}

exports.setBar = function(v) {
    bar = v;
}
```
```js
const { bar, setBar, getBar } = require('./bar.js');
console.log(bar); // 23
setBar(34);
console.log(bar, getBar()); // 23 34
```
bar中的变量发生变化之后，不会影响到 index 中导入的值，除非使用函数来访问。这是因为const关键字说明了导入的bar像被复制了一份，只不过是index内的变量。

然而ESM却表现的很不同：
```js
export let bar = 23;

export const getBar = function() {
    return bar;
}

export const setBar = function(v) {
    bar = v;
}
```
```js
import { bar, setBar, getBar } from './bar.mjs';
console.log(bar); // 23
setBar(34);
console.log(bar, getBar()); // 34 34
```
就算是基本引用类型，ESM也会选择导入引用。

本质原因是作用域中的**Environment Records**的概念，存在一个子类名为`Module Environment Records`，代表了上下文。ESM 对 Import 变量的引用相当于进入到另一个 Module 的内部去访问，只不过只能访问那些被目标Module主动声明的变量。

传递引用的特性可以被CommonJS所模拟，大概的实现为：
```js
var _bar = require("./bar.mjs");
console.log(_bar.bar); // 23
(0, _bar.setBar)(34);
console.log(_bar.bar, (0, _bar.getBar)());
```
虽然 bar 本身是引用，但是把它挂载到一个对象下，作为属性，所以每次访问自然也是引用，从而模拟特性。

最后，ESM内部是可以完全访问到全局变量的。其次它也有 this 变量，只不过始终是 undefined，想要访问全局变量，必须用window或`globalThis`

## HTML与ESM
由于与传统JS代码存在很大的差异性，在HTML页面上引用ESM格式的JS需要的特殊指令，在`<script>`上需要添加`type="module"`:

```js
<script type="module" src="./module.js"></script>
```
这是必须的，即便是文件后缀用`.mjs`也是仍然必须的。但是`dynamic import`语法却不受限制：
```js
<script>
    import('./module.mjs').then(...
</script>
```
`type="module"`的脚本还有一个特性：它等价开启了`defer`指令。也就是说，ESM代码总是不会阻塞HTML的解析，但是会在`DOMContentLoaded`之前完成加载和执行