import{_ as e,c as t,o,U as s}from"./chunks/framework.qUHj8-gn.js";const a="/assets/vite-bundle-1.J7qVAujh.png",d="/assets/vite-bundle-2.z1cqSEGL.png",p="/assets/vite-bundle-3.CqksYZV-.png",i="/assets/vite-bundle-4.SRmAF6nM.png",c="/assets/vite-bundle-5.OnUl3dpL.png",V=JSON.parse('{"title":"依赖预构建","description":"","frontmatter":{},"headers":[],"relativePath":"bundle-tool-docs/vite/依赖预构建.md","filePath":"bundle-tool-docs/vite/依赖预构建.md","lastUpdated":1715266250000}'),n={name:"bundle-tool-docs/vite/依赖预构建.md"},l=s('<h1 id="依赖预构建" tabindex="-1">依赖预构建 <a class="header-anchor" href="#依赖预构建" aria-label="Permalink to &quot;依赖预构建&quot;">​</a></h1><p>Vite是一个提倡<code>no-bundle</code>的构建工具，相对于webpack，它能做到开发时的模块按需编译，而不是先打包后再加载。</p><p>对于模块代码来说，其实应该分为两个部分，一部分是源代码，也就是业务代码，另一部分是第三方依赖的代码，即<code>node_modules</code>中的代码。所谓的<code>no-bundle</code>是对于源代码而言，对于第三方依赖而言，Vite依然选择bundle(打包)，并且使用速度极快的打包器Esbuild来完成这个过程，达到秒级的依赖编译速度。</p><h2 id="为什么需要依赖预构建" tabindex="-1">为什么需要依赖预构建？ <a class="header-anchor" href="#为什么需要依赖预构建" aria-label="Permalink to &quot;为什么需要依赖预构建？&quot;">​</a></h2><p>不使用依赖预构建，会有哪些问题？</p><p>首先 Vite 是基于浏览器原生ES模块规范实现的Dev Server，不论是应用代码，还是第三方依赖的代码，理应符合 ESM 规范才能正常运行</p><p><img src="'+a+'" alt="image"> 但是，但是，现在的很多第三方库没有这个标准，所以CommonJS格式的代码在Vite中必须转换成ESM格式的产物，否则无法直接运行。</p><p>再转换代码格式这一步，就需要使用预构建去做转换</p><p>另外还有一个重要的问题，就是<strong>请求瀑布流问题</strong>，比如知名的<code>lodash-es</code>库本身是有ES版本产物的，可以在Vite中直接运行。但实际上，它在加载时会发出特别多的请求，导致页前加载的前几秒几乎都处于卡顿状态</p><p><img src="'+d+'" alt="image"></p><p>之所以会出现这样的问题，就是因为代码中调用了<code>debounce</code>方法，而这个方法同时又依赖了很多工具函数导致的</p><p>每个<code>import</code>都会触发一次新的文件请求，因此在这种 <strong>依赖层级深 涉及模块数量多</strong> 的情况下会触发成百上千个网络请求，巨大的请求量加上Chrome对同一个域名下只能同时支持6个HTTP并发请求限制，在进行<strong>依赖预先构建后</strong>，<code>lodash-es</code>这个库的代码被打包成为一个文件，这样请求的数量会骤然减少，页面加载也快了很多</p><p>总而言之，在依赖预构建阶段，Vite做了这么两件事情：</p><ul><li>将其他格式的产物转换为ESM格式，使其在浏览器通过<code>&lt;script type=&quot;module&quot;&gt;&lt;script&gt;</code>的方式正常加载</li><li>打包第三方库的代码，将各个第三方库分散的文件合并在一起，减少HTTP请求数量，避免页面加载性能劣化</li></ul><p>这两件事情全部由性能优异的Esbuild (底层golang实现) 开发完成，而不是传统的Webpack/Rollup，所以不会有很明显的打包性能问题，反而是Vite项目启动飞快的核心原因</p><h2 id="强制缓存" tabindex="-1">强制缓存 <a class="header-anchor" href="#强制缓存" aria-label="Permalink to &quot;强制缓存&quot;">​</a></h2><p>在进行依赖预构建之后，可以在<code>node_modules</code>中的<code>.vite</code>的<code>deps</code>中查看到被缓存构建的产物被放在其中</p><p><img src="'+p+'" alt="image"></p><p>可以看见第三方包的引入路径被重写了</p><p><img src="'+i+'" alt="image"></p><p>对于依赖的请求结果，其实上是设置强缓存了</p><p><img src="'+c+'" alt="image"></p><p>缓存过期时间被设置为了一年，表示缓存过期前浏览器对vite的预构建产物的请求不会经过Vite Dev Server，而是直接使用缓存结果</p>',23),r=[l];function _(m,u,g,h,b,v){return o(),t("div",null,r)}const f=e(n,[["render",_]]);export{V as __pageData,f as default};
