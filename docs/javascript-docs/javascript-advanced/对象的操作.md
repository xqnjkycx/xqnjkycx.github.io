# 对象的操作
对象操作涉及到了 类型判断，对象锁定，对象合并，对象比较等等...

## 类型判断
判断一个对象o是否是类C的实例，会用到`instanceof`运算符：
```js
o instanceof C
```
`instanceof`的总体逻辑依然被分为了`Symbol.hasInstance`和**原型链**两个分支。

:::tip 注意
`Symbol.hasInstance` 是一个预定义的Symbol常量
:::
- 第一步，判断C是否含有`[Symbol.hasInstance]`这个函数，它需要定义在构造函数身上，而不是实例上:

```js
class MyString {
  static [Symbol.hasInstance](instance) {
    return 'string' === typeof instance;
  }
}

console.log('abc' instanceof MyString); // true
```
如果存在这个函数，就调用它，传入`instanceof`左边的值。像上文的代码，声明了一个自定义类型，在`instanceof`下成功利用(覆写)`Symbol.hasInstance`把字符串伪装为了实例。

- 第二步 判断C是否是一个`bind`之后的函数，像`C = Foo.bind(ko)`。一个函数在经过`bind`后，它的`name`属性会有`bound`的字样
```js
function Foo(){}

const C = Foo.bind("this",1,2,3)

C.name // "bound Foo"
```
经过bind后的函数会把原始函数记录在`[[BoundTargetFunction]]`内部属性中，结构大概如下：
```js
{
  [[BoundTargetFunction]]:Foo,
  [[BoundThis]]:"this",
  [[BoundArguments]]:[1,2,3]
}
```
拿到原始函数之后，问题就变为o instanceof F了，接下来开始顺着原型链查找了，**顺着o的原型链查找，如果能找到 F.prototype，就返回true，否则返回false，直到找到null才停止**

用伪代码表示：
```js
o.__proto__.__proto__.__proto__... === F.prototype
```
这里手写一个`instanceof`的实现
```js
function myInstanceof(o, C) {
    let current  = o;
    while(current)
        const proto = Object.getPrototypeOf(current);
        if (proto && proto === C.prototype) {
            return true;
        }
        current = proto;
    }
    return false;
}
```
仍然要注意一些边界条件：
- C如果不是对象，就需要抛出异常，比如null，undefined，true，5，“abc”...
- 除非命中`[Symbol.hasInstance]`逻辑，否则C还必须是一个函数
- 如果o不是对象，返回false，这里的对象也指的是非基础类型，比如`"str" instanceof String === false`
- 如果C没有对象类型的`prototype`，抛出异常

因为原型链本身是脆弱的，因此`instanceof`的结果**严格**来讲也不能反应对象o和构造函数C之间的关系。即便不使用`Symbol.hasInstance`这种后门，也可以通过一些操作，让o看上去是C的实例:
```js
var o = {};
function Foo() {}

Object.setPrototypeOf(o, Foo.prototype);

o instanceof Foo // true
```
只能说，`instanceof`代表的不过就是一种判定规则，并不真的代表对象o就是C的实例。

## 锁定对象
通过`configurable`配合`writable`可以在一定程度上锁定对象的结构，但不能拦截`Object.defineProperty`的`value`修改。
ECMAScript提供了另外三个静态函数：`Object.preventExtensions`，`Object.seal`，`Object.freeze`，提供了三种不同级别的锁定能力。

### 阻止对象扩展
`Object.preventExtensions`用于禁止给对象新增属性，它将对象内部的`[[Extensible]]`标志位设成false。

`[[Extensible]]`影响到了多种操作的结构，这些行为是不允许的：
```js
var o = {};

Object.preventExtensions(o);

// 不允许设置原型
Object.setPrototypeOf(o, null);

// 不允许定义新属性
Object.defineProperty(o, 'foo', {
    value: 2
});

// 不允许创建新属性
o.bar = 3
```
由于有原型，原型对象没有被`preventExtensions`的话，可以在原型对象上新增属性，这样对象相当于“围魏救赵”的新增属性...

判断一个对象是否可扩展，可以使用`Object.isExtensible(o)`静态函数。

### 密封对象
`Object.seal()`用于密封对象。就是不扩展的升级版，除了不能新增属性之外，现有的属性都需要变为不可配置。
- 执行`preventExtensions`
- 遍历所有属性，修改`configurable`为false
判断一个对象是否被密封，使用`Object.isSealed(o)`静态函数

### 冻结对象
`Object.freeze`用于冻结对象。不能新加属性，现有属性不可配置，`writable`变为false

判断一个对象是否被密封，可以使用`Object.isFrozen`

| 操作 | 状态判断 | 可新增属性 | 现有属性可配置 | 数据属性可写 |
|-------|-------|-------|-------|-------|
| preventExtensions | isExtensible() | ❌ | ✔ | ✔ |
| seal | isSealed() | ❌ | ❌ | ✔ |
| freeze | isFrozen() | ❌ | ❌ | ❌ |

:::warning 注意！
尽管是最严格的`freeze`操作，在面对存取器属性时，也不能将属性变成“只读”，看下面这个例子
:::
```js
const o = {}

let value = ''

Object.defineProperty(o,'value',{
    get(){
        return value
    },
    set(newVal){
        value = newVal
    }
})

Object.freeze(o)

o.value = 123

o.value = 4

console.log(o.value) //4
```

### 对象合并
合并对象的常见操作为`Object.assign`和`Object Spread（对象展开操作）`

这两者的根本上的原理就存在不同：
- Object.assign 以 set 的方式赋值属性
- Object Spread 以 defineProperty 的方式定义属性
可以用代码来说明：
```js
function assign(dest, src) {
    for (let key in src) {
        // 跳过非自身属性
        if (!src.hasOwnProperty(key)) continue;
        // set
        dest[key] = src[key];
    }
}

function spread(dest, src) {
    for (let key in src) {
        // 跳过非自身属性
        if (!src.hasOwnProperty(key)) continue;
        // defineProperty
        Object.defineProperty(dest, key, {
            value: src[key],
            writable: true,
            enumerable: true,
            configurable: true,
        })
    }
}

```
可以看出`Object.assign`将源对象的可枚举属性都取出来，直接赋值给目标对象；`Object Spread`语法也是将源对象的可枚举属性取出来，不过是在目标对象上定义一个数据属性。

- `Obejct.assign`可能会将数据赋值到目标对象的原型上，如果原型上有这个key的**存取器属性**的话；
- `Object Spread`抛去了源对象的属性描述，无论它是数据属性还是存取器属性，无论是可配置的还是不可配置，也无论是可枚举的还是不可枚举的，**最终都转换为目标对象上的一个可枚举，可配置，可写的数据属性**

以下两个例子证明：
```js
var _name = null;

var dest = Object.create({
    set name(n){
        _name = n;
    },
    get name(){
        return _name;
    },

});

Object.assign(dest, {
    name: 'bar'
});
console.log(dest.name); // "bar"
// Object.assign 赋值到了对象的原型上而非对象本身
console.log(Object.getOwnPropertyDescriptor(dest, 'name')); // undefined

```

```js
var source = Object.create(null, {
    name: {
        get() {
            return 'foo';
        },
        set(){},
        enumerable: true,
        configurable: false,
    },
});

const dest = { ...source };
// Object Spread 在目标对象上定义可配置的数据属性
console.log(Object.getOwnPropertyDescriptor(dest, 'name')); 
// { value: 'foo', writable: true, enumerable: true, configurable: true }

```

一般来说，只操作简单的对象的话，没什么差异。考虑到Object Spread只作用于对象字面量，而不能作用于变量，因此它无法将一个现存变量当作合并目标。

如果合并的目标对象是未知来源，那么`Object.assign`可能会引起报错的场景：
● 如果目标对象现存属性是只读的，Object.assign 就会失败
● 如果目标对象现存属性是不可配置的，或者对象不可扩展，那么Object.assign可能会失败

另外，由于两种方法都是操作批量属性，如果其中某一属性合并失败，那么之前已经合并的属性就会保留，不会回滚，**合并失败是可能产生未知的对象污染的**。
```js
var dest = Object.create(null, {
    a: {
        value: 'a',
        writable: true,
        enumerable: true,
        configurable: true,
    },
    b: {
        value: 'b',
        // 合并b会报错
        writable: false,
        enumerable: true,
        configurable: true,
    }
});

try {
    Object.assign(dest, {
        a: 'aa',
        b: 'bb'
    });
} catch {}

console.log(dest.a, dest.b); // aa b
```