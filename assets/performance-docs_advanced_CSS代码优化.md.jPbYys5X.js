import{_ as s,c as i,o as a,U as n}from"./chunks/framework.qUHj8-gn.js";const g=JSON.parse('{"title":"CSS代码优化","description":"","frontmatter":{},"headers":[],"relativePath":"performance-docs/advanced/CSS代码优化.md","filePath":"performance-docs/advanced/CSS代码优化.md","lastUpdated":1711641779000}'),e={name:"performance-docs/advanced/CSS代码优化.md"},l=n(`<h1 id="css代码优化" tabindex="-1">CSS代码优化 <a class="header-anchor" href="#css代码优化" aria-label="Permalink to &quot;CSS代码优化&quot;">​</a></h1><h2 id="css开发痛点" tabindex="-1">CSS开发痛点 <a class="header-anchor" href="#css开发痛点" aria-label="Permalink to &quot;CSS开发痛点&quot;">​</a></h2><p>css最显著的痛点就是<strong>可维护性差</strong>，具体表现在：</p><h3 id="语法简陋" tabindex="-1">语法简陋 <a class="header-anchor" href="#语法简陋" aria-label="Permalink to &quot;语法简陋&quot;">​</a></h3><p>CSS并非编程语言，其语法缺乏逻辑控制，变量，循环等特性，不便于编写复杂的动态样式，对如今业务逻辑复杂的前端应用来说，语法堪称简陋</p><h3 id="全局作用污染" tabindex="-1">全局作用污染 <a class="header-anchor" href="#全局作用污染" aria-label="Permalink to &quot;全局作用污染&quot;">​</a></h3><p>CSS默认运行在全局作用域，同时模块化能力又有限，类名样式对所有元素生效，导致类名难以避免，样式容易被覆盖</p><h3 id="选择器规则复杂" tabindex="-1">选择器规则复杂 <a class="header-anchor" href="#选择器规则复杂" aria-label="Permalink to &quot;选择器规则复杂&quot;">​</a></h3><p>CSS的类名选择符特性依赖优先级生效，但优先级计算规则又相当复杂，对开发者不友好</p><h3 id="代码关联性差" tabindex="-1">代码关联性差 <a class="header-anchor" href="#代码关联性差" aria-label="Permalink to &quot;代码关联性差&quot;">​</a></h3><p>CSS和JS，HTML配合紧密，代码又相互隔离，缺乏关联，导致开发者需要在3者之间频繁切换注意力，对开发效率和体验都有负面影响</p><p>避免开发者频繁切换注意力，从而提高开发效率，也是Vue.js提出单文件SFC</p><h3 id="样式生效依赖隐式规则" tabindex="-1">样式生效依赖隐式规则 <a class="header-anchor" href="#样式生效依赖隐式规则" aria-label="Permalink to &quot;样式生效依赖隐式规则&quot;">​</a></h3><p>CSS的样式最终是否生效，<strong>隐式</strong>的依赖许多难以控制的因素，例如：</p><ul><li>CSS规则声明的先后顺序：或者说<code>style</code>和<code>link</code>标签在HTML中的先后顺序</li><li>元素继承关系：部分CSS样式规则可以在应用在父元素后，通过继承关系，应用到子元素上</li></ul><p>这些因素在开发实践中通常<strong>难以控制</strong>，尤其是现代的前端工程大都依赖打包构建工具，将模块化的代码，合并成产物文件。对于有成百上千组件模块的前端项目，CSS代码合并后的顺序往往不能控制，甚至难以预测</p><h2 id="常见css开发体验优化方案" tabindex="-1">常见CSS开发体验优化方案 <a class="header-anchor" href="#常见css开发体验优化方案" aria-label="Permalink to &quot;常见CSS开发体验优化方案&quot;">​</a></h2><p>总结4类常见的解决方案，各有优劣哈</p><h3 id="类命名原则" tabindex="-1">类命名原则 <a class="header-anchor" href="#类命名原则" aria-label="Permalink to &quot;类命名原则&quot;">​</a></h3><p>这类方案约定俗成了一套编写CSS的原则，约定在开发时将CSS的类名class分成3部分：</p><ul><li>块<code>Block</code>：是一个抽象概念，表示使用这个字符串作为类名的元素，都属于一个部分，有相对独立的功能。例如<code>.block</code>, <code>.navbar</code>类名 -元素<code>Element</code>：块的组成部分，总是和块相连使用，以2个下划线作为分隔。例如<code>.block__element</code>, <code>.navbar__dropdown</code>类名 -修饰符<code>Modifier</code>：用于标识块和元素的细节外观，以2个中横线作为分隔。例如<code>.block-element--modifier</code>, <code>.navbar__dropdown--disabled</code>类名</li></ul><p>这3类概念组成的类名，对应的就是BEM的全称：Block Element Modifier</p><p>BEM规则通过提供统一的CSS class命名规范，让开发者使用统一的大小写规则和下划线等符号，实现为不同的组件和元素，命名不同的CSS类名class</p><p>同时致力于尽量让CSS类名选择符保存<strong>最低的优先级</strong>，只有一个类选择器，避免CSS缺乏作用域特性导致难以维护优先级的痛点</p><h4 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li><strong>BEM类名冗长</strong>：大量BEM类名会导致整个页面的HTML标签代码视觉上省略冗长，甚至混乱难以辨认。例如：<code>navigation__menu-item--active-with-submenu</code>，<code>.product__image-container--with-overlay-and-zoom</code>，这样的类名阅读起来太复杂了</li><li>**依赖开发者主观上遵守规范，可靠性不强：**但人又往往是不可靠因素，导致在实践中，对同一元素的类名容易因人而异，对块元素，修饰符定义出现分歧，必须要依赖于评审保持规则约束</li></ul><h3 id="css-处理器" tabindex="-1">CSS 处理器 <a class="header-anchor" href="#css-处理器" aria-label="Permalink to &quot;CSS 处理器&quot;">​</a></h3><p>第二类解决方案是最常见的CSS预处理，代表工具<code>Sass</code>和<code>Less</code></p><p>这类方案基于配套的代码编译工具，拓展了CSS的语法，通过为CSS增加变量，函数，嵌套等特性，来解决CSS可维护性较差的痛点</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// src/style/demo</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.less</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// 1. 函数 mixin</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.bordered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border-top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dotted</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> black</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border-bottom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> black</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// 2. 变量 variable</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@fontSize</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: 16px;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">// 3. 嵌套 nested</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">#header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: @fontSize;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>经过编译之后，后面的代码就是：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">.bordered</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border-top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">dotted</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> black</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  border-bottom</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">solid</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> black</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">#header</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h4 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><ul><li><strong>有额外学习成本</strong>：需要专门学习<code>Sass</code>和<code>Less</code>的语法，有一定时间成本</li><li><strong>不便于调试</strong>：使用<code>Sass</code>和<code>Less</code>编写的源码和最终浏览器中运行的产物CSS代码不一定能精确匹配，会增加开发调试的难度，一般需要额外配合<code>CSS sourcemap</code>使用</li><li><strong>拖慢构建耗时</strong>：用预处理器编写的<code>Sass</code>和<code>Less</code>代码，需要使用专用的编译器，例如<code>sass-loader</code>,<code>less-laoder</code>，编译后才能在生产环境中使用，会导致前端项目构建的耗时明显增加</li></ul><h3 id="css后处理器" tabindex="-1">CSS后处理器 <a class="header-anchor" href="#css后处理器" aria-label="Permalink to &quot;CSS后处理器&quot;">​</a></h3><p>第三类解决方案是后处理器。</p><p>和预处理器直接提供新语法、新特性不同，后处理器PostCSS通过提供一套类似Babel的CSS语法编译工具和插件系统，来对已有的CSS进行后置处理，更注重通过生态中的各类插件，实现特定功能，例如：</p><ul><li>嵌套语法插件：<a href="https://github.com/postcss/postcss-nested" target="_blank" rel="noreferrer">https://github.com/postcss/postcss-nested</a></li><li>自动增加浏览器兼容前缀插件：<a href="https://github.com/postcss/autoprefixer" target="_blank" rel="noreferrer">https://github.com/postcss/autoprefixer</a></li><li>CSS代码压缩：<a href="https://github.com/cssnano/cssnano" target="_blank" rel="noreferrer">https://github.com/cssnano/cssnano</a></li></ul><h4 id="缺点-2" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-2" aria-label="Permalink to &quot;缺点&quot;">​</a></h4><p>有额外学习成本和工具链配置成本：使用PostCSS的配置相对更加复杂，需要专门<code>postcss.config.js</code>配置文件，来设置使用的插件及其选项</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// postcss.config.js</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/** </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">@type</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> {import(&#39;postcss-load-config&#39;).Config}</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> */</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> config</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  plugins: [</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;autoprefixer&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">),</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;postcss-nested&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> config</span></span></code></pre></div><p>PostCSS为了实现对CSS语法树的编译解析并应用插件转化代码，有额外的编译开销，会导致构建耗时边长</p><h3 id="原子化css" tabindex="-1">原子化CSS <a class="header-anchor" href="#原子化css" aria-label="Permalink to &quot;原子化CSS&quot;">​</a></h3><p>第四类解决方案，是近两年在前端领域非常流行的原子化CSS方案</p><p>比如 Tailwind CSS</p><p>这类方案通过<strong>预定义</strong>和<strong>细粒度</strong>CSS样式和类名，来提高CSS的开发效率，减少自定义的样式和类名，从根本上尽可能避免CSS类名和样式容易冲突覆盖，难以维护的痛点。</p><p>以Tailwind为例，其特点有：</p><p>Tailwind提供的预定义CSS样式和类名，基于<strong>工具优化utility-first</strong>的思想，有独特的规律，例如：</p><div class="language-css vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  text-xs</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: font-size: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.75</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 12px / line-height: 1rem; / 16px */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  text-sm</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: font-size: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.875</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 14px / line-height: 1.25rem; / 20px */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  text-lg</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: font-size: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1.125</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 18px / line-height: 1.75rem; / 28px */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  w-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">4:width:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 16px */</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  w-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">8:width:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">rem</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* 32px */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h3 id="缺点-3" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-3" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>**有一定学习成本：**其预定义的CSS类名规则比较特性，想要灵活运用，需要一定的时间来熟悉</li><li>**可读性略差：**有很多开发者认为预定义的原子化CSS类名不够直观，难以理解，写出来的代码可读性不好</li></ul>`,51),t=[l];function h(p,k,r,d,o,c){return a(),i("div",null,t)}const C=s(e,[["render",h]]);export{g as __pageData,C as default};
