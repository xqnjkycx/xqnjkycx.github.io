import{_ as s,o as n,c as a,Q as o}from"./chunks/framework.6d94f49f.js";const F=JSON.parse('{"title":"类型判断","description":"","frontmatter":{},"headers":[],"relativePath":"javascript-docs/javascript-advanced/类型判断.md","filePath":"javascript-docs/javascript-advanced/类型判断.md","lastUpdated":1703605850000}'),l={name:"javascript-docs/javascript-advanced/类型判断.md"},p=o(`<h1 id="类型判断" tabindex="-1">类型判断 <a class="header-anchor" href="#类型判断" aria-label="Permalink to &quot;类型判断&quot;">​</a></h1><p>到ES2023为止，一共定义了7种变量类型:</p><ul><li>undefined</li><li>null</li><li>boolean</li><li>String</li><li>Symbol</li><li>Numeric( Number BigInt)</li><li>Object</li></ul><p>其中Object不是基本数据类型，前面的全是基本数据类型</p><h2 id="typeof" tabindex="-1">typeof <a class="header-anchor" href="#typeof" aria-label="Permalink to &quot;typeof&quot;">​</a></h2><p>typeof 不是一个函数，而是一个操作符，而且不能声明一个 typeof 的变量</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">var</span><span style="color:#E1E4E8;"> typeof </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// Unexpected token &#39;typeof&#39;</span></span>
<span class="line"><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> </span><span style="color:#6A737D;">// Unexpected end of input</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">var</span><span style="color:#24292E;"> typeof </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">3</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// Unexpected token &#39;typeof&#39;</span></span>
<span class="line"><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> </span><span style="color:#6A737D;">// Unexpected end of input</span></span></code></pre></div><p>typeof 返回值一定是这8种<strong>字符串</strong>的之一:</p><ul><li>&quot;undefined&quot;</li><li>&quot;string&quot;</li><li>&quot;boolean&quot;</li><li>&quot;number&quot;</li><li>&quot;bigint&quot;</li><li>&quot;symbol&quot;</li><li>&quot;object&quot;</li><li>&quot;function&quot; 首先是null会被typeof返回成object，同时这个原因和底层的机器码的实现有关。</li></ul><p>判断null类型，最好直接使用<code>if(foo === null)</code></p><h2 id="undefined" tabindex="-1">undefined <a class="header-anchor" href="#undefined" aria-label="Permalink to &quot;undefined&quot;">​</a></h2><p>一般来说，推荐使用<code>&quot;undefined&quot; === typeof foo</code>来判断是否是undefined</p><p>如果直接用全等<code>undefined === foo</code>也能实现，但是有意外</p><p>undefined还不是关键字，它可以在做为变量名在局部环境中进行声明(非严格模式)</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">1</span></span>
<span class="line"><span style="color:#E1E4E8;">  console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">undefined</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">//number</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">1</span></span>
<span class="line"><span style="color:#24292E;">  console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">undefined</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">//number</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><h2 id="典型对象的判断" tabindex="-1">典型对象的判断 <a class="header-anchor" href="#典型对象的判断" aria-label="Permalink to &quot;典型对象的判断&quot;">​</a></h2><p>typeof 基本上能解决 原始类型 变量的判断，一般在业务中，往往要去做几个典型类型的判断需求，比如数组Array和正则RegExp。</p><p>先来看数组</p><p>早期因为IE环境下跨ifreme调用时，<code>[] instanceof Array</code>是不成立的，所以推荐使用的是<code>Object.prototype.toString.call(arr) === &quot;[object Array]&quot;</code>，其实也可以使用<code>arr.constructor === Array</code></p><p>ES5之后又引入了<code>Array.isArray</code>来判断</p><p>这里推荐使用 <strong>Array.isArray比instanceof或者constructor能胜任对Proxy的判定工作。</strong></p><p>比如这段代码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">const</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">proxy</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">=</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Proxy</span><span style="color:#E1E4E8;">([],{</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">target</span><span style="color:#E1E4E8;">,</span><span style="color:#FFAB70;">p</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&#39;constructor&#39;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> p) </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> String;</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> Reflect.</span><span style="color:#B392F0;">get</span><span style="color:#E1E4E8;">(target,p);</span></span>
<span class="line"><span style="color:#E1E4E8;">  },</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#B392F0;">getPrototypeOf</span><span style="color:#E1E4E8;">(){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">null</span></span>
<span class="line"><span style="color:#E1E4E8;">  }</span></span>
<span class="line"><span style="color:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`Array.isArray(proxy)\`</span><span style="color:#E1E4E8;">,Array.</span><span style="color:#B392F0;">isArray</span><span style="color:#E1E4E8;">(proxy)); </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`proxy instanceof Array\`</span><span style="color:#E1E4E8;">, proxy </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Array</span><span style="color:#E1E4E8;">); </span><span style="color:#6A737D;">//false</span></span>
<span class="line"><span style="color:#E1E4E8;">console.</span><span style="color:#B392F0;">log</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">\`proxy.constructor === Array\`</span><span style="color:#E1E4E8;">, proxy.</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Array); </span><span style="color:#6A737D;">//false</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">const</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">proxy</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">=</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Proxy</span><span style="color:#24292E;">([],{</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(</span><span style="color:#E36209;">target</span><span style="color:#24292E;">,</span><span style="color:#E36209;">p</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&#39;constructor&#39;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> p) </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> String;</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> Reflect.</span><span style="color:#6F42C1;">get</span><span style="color:#24292E;">(target,p);</span></span>
<span class="line"><span style="color:#24292E;">  },</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#6F42C1;">getPrototypeOf</span><span style="color:#24292E;">(){</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">null</span></span>
<span class="line"><span style="color:#24292E;">  }</span></span>
<span class="line"><span style="color:#24292E;">})</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`Array.isArray(proxy)\`</span><span style="color:#24292E;">,Array.</span><span style="color:#6F42C1;">isArray</span><span style="color:#24292E;">(proxy)); </span><span style="color:#6A737D;">//true</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`proxy instanceof Array\`</span><span style="color:#24292E;">, proxy </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Array</span><span style="color:#24292E;">); </span><span style="color:#6A737D;">//false</span></span>
<span class="line"><span style="color:#24292E;">console.</span><span style="color:#6F42C1;">log</span><span style="color:#24292E;">(</span><span style="color:#032F62;">\`proxy.constructor === Array\`</span><span style="color:#24292E;">, proxy.</span><span style="color:#005CC5;">constructor</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Array); </span><span style="color:#6A737D;">//false</span></span></code></pre></div><p>但是在其他对象类型上，可能就没这种待遇了，比如正则表达式RegExp，除了它有自己独立的字面量语法之外，RegExp，Date，Argument等等.</p><p>但是通常也有三种方法来做判断：</p><ul><li>第一种办法，判断其构造函数，不过对象的constructor属性一般是可以被覆写的，也有被伪造的可能</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isAnimal</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">foo</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> foo?.</span><span style="color:#79B8FF;">constructor</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> Animal</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isAnimal</span><span style="color:#24292E;">(</span><span style="color:#E36209;">foo</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> foo?.</span><span style="color:#005CC5;">constructor</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> Animal</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>第二种办法，用 instanceof 做原型链判别，不过对象的原型链也是可以被篡改的</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isAnimal</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">foo</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> foo </span><span style="color:#F97583;">instanceof</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Animal</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isAnimal</span><span style="color:#24292E;">(</span><span style="color:#E36209;">foo</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> foo </span><span style="color:#D73A49;">instanceof</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Animal</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><ul><li>第三种办法，使用对象基类的toString方法</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isAnimal</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">foo</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">	</span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Object</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.toString.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(foo) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;[object Animal]&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isAnimal</span><span style="color:#24292E;">(</span><span style="color:#E36209;">foo</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">	</span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Object</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.toString.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(foo) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;[object Animal]&quot;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div><p>比较难受的是,js的构造函数，甚至class语法本身都是语法糖，原型链基本上可以被修改。</p><h2 id="primitive-的对象封装" tabindex="-1">Primitive 的对象封装 <a class="header-anchor" href="#primitive-的对象封装" aria-label="Permalink to &quot;Primitive 的对象封装&quot;">​</a></h2><p>除了 null 和 undefined 之外，其余的 基本数据 类型都可以封装为Object</p><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#e1e4e8;">Object(123) // new Number(123)</span></span>
<span class="line"><span style="color:#e1e4e8;">Object(123n) // new BigInt(123n)</span></span>
<span class="line"><span style="color:#e1e4e8;">Object(&quot;str&quot;) // new String(&quot;str&quot;)</span></span>
<span class="line"><span style="color:#e1e4e8;">Object(true) // new Boolean(true)</span></span>
<span class="line"><span style="color:#e1e4e8;">Object(Symbol(&quot;sym&quot;))</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292e;">Object(123) // new Number(123)</span></span>
<span class="line"><span style="color:#24292e;">Object(123n) // new BigInt(123n)</span></span>
<span class="line"><span style="color:#24292e;">Object(&quot;str&quot;) // new String(&quot;str&quot;)</span></span>
<span class="line"><span style="color:#24292e;">Object(true) // new Boolean(true)</span></span>
<span class="line"><span style="color:#24292e;">Object(Symbol(&quot;sym&quot;))</span></span></code></pre></div><p>虽然这些值在 typeof 下一定都返回 &quot;object&quot;，但是依然具有原本语义</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">3</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">Number</span><span style="color:#E1E4E8;">(</span><span style="color:#79B8FF;">4</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// 7</span></span>
<span class="line"><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;a&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">+</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">new</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">String</span><span style="color:#E1E4E8;">(</span><span style="color:#9ECBFF;">&quot;b&quot;</span><span style="color:#E1E4E8;">) </span><span style="color:#6A737D;">// &quot;ab&quot;</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">3</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">Number</span><span style="color:#24292E;">(</span><span style="color:#005CC5;">4</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// 7</span></span>
<span class="line"><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;a&quot;</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">+</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">new</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">String</span><span style="color:#24292E;">(</span><span style="color:#032F62;">&quot;b&quot;</span><span style="color:#24292E;">) </span><span style="color:#6A737D;">// &quot;ab&quot;</span></span></code></pre></div><p>如果要实现一个<code>concatString(a,b)</code>函数，a和b除了应该是string类型之外，也允许字符串对象才行</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#F97583;">function</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">isString</span><span style="color:#E1E4E8;">(</span><span style="color:#FFAB70;">str</span><span style="color:#E1E4E8;">){</span></span>
<span class="line"><span style="color:#E1E4E8;">  </span><span style="color:#F97583;">return</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;string&quot;</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#F97583;">typeof</span><span style="color:#E1E4E8;"> str </span><span style="color:#F97583;">||</span><span style="color:#E1E4E8;"> </span><span style="color:#79B8FF;">Object</span><span style="color:#E1E4E8;">.</span><span style="color:#79B8FF;">prototype</span><span style="color:#E1E4E8;">.toString.</span><span style="color:#B392F0;">call</span><span style="color:#E1E4E8;">(str) </span><span style="color:#F97583;">===</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;[object String]&quot;</span></span>
<span class="line"><span style="color:#E1E4E8;">}</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#D73A49;">function</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">isString</span><span style="color:#24292E;">(</span><span style="color:#E36209;">str</span><span style="color:#24292E;">){</span></span>
<span class="line"><span style="color:#24292E;">  </span><span style="color:#D73A49;">return</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;string&quot;</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#D73A49;">typeof</span><span style="color:#24292E;"> str </span><span style="color:#D73A49;">||</span><span style="color:#24292E;"> </span><span style="color:#005CC5;">Object</span><span style="color:#24292E;">.</span><span style="color:#005CC5;">prototype</span><span style="color:#24292E;">.toString.</span><span style="color:#6F42C1;">call</span><span style="color:#24292E;">(str) </span><span style="color:#D73A49;">===</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;[object String]&quot;</span></span>
<span class="line"><span style="color:#24292E;">}</span></span></code></pre></div>`,39),e=[p];function t(c,r,y,E,i,u){return n(),a("div",null,e)}const g=s(l,[["render",t]]);export{F as __pageData,g as default};
