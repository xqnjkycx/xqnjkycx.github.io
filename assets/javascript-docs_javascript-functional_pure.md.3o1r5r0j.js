import{_ as s,c as i,o as a,U as n}from"./chunks/framework.PFQuerqu.js";const t="/assets/隐式输入.lRGtQ2j6.png",y=JSON.parse('{"title":"纯函数 副作用","description":"","frontmatter":{},"headers":[],"relativePath":"javascript-docs/javascript-functional/pure.md","filePath":"javascript-docs/javascript-functional/pure.md","lastUpdated":1711268195000}'),l={name:"javascript-docs/javascript-functional/pure.md"},p=n(`<h1 id="纯函数-副作用" tabindex="-1">纯函数 副作用 <a class="header-anchor" href="#纯函数-副作用" aria-label="Permalink to &quot;纯函数 副作用&quot;">​</a></h1><p>在函数式编程中，<strong>纯函数是函数式编程的一个重要的前提，也是函数式编程这一体系的根基。</strong></p><h2 id="纯函数的特征" tabindex="-1">纯函数的特征 <a class="header-anchor" href="#纯函数的特征" aria-label="Permalink to &quot;纯函数的特征&quot;">​</a></h2><p>凡是满足以下两个特征的函数，就可以被认为是纯函数：</p><ul><li>对于相同的输入，总是要得到相同的输出</li><li>在执行过程中没有语义上可观察的副作用</li></ul><h2 id="副作用的特征" tabindex="-1">副作用的特征 <a class="header-anchor" href="#副作用的特征" aria-label="Permalink to &quot;副作用的特征&quot;">​</a></h2><p>如果一个函数除了计算之外，还对它的执行上下文和执行宿主等外部环境造成了一些其它的影响，那么这个影响就被称为<strong>副作用</strong>。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>维基百科如此评价：</strong> 在计算机科学中，函数副作用指的是当调用函数时，除了返回可能的函数值之外，还对主调用函数产生了附加影响。</p></div><h2 id="纯函数示例" tabindex="-1">纯函数示例 <a class="header-anchor" href="#纯函数示例" aria-label="Permalink to &quot;纯函数示例&quot;">​</a></h2><h3 id="加法运算" tabindex="-1">加法运算 <a class="header-anchor" href="#加法运算" aria-label="Permalink to &quot;加法运算&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 20</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个函数是纯函数吗？</p><p><strong>不是！</strong></p><p>因为对于不同的输入，它得到了不同的输出：如果首次调用 <code>add</code> 方法，会得到<code>30</code>，一旦修改<code>a = 100 ; b = 200</code> ;时，输出就变为了<code>300</code></p><p>这里需要强调的是，“输入”指的是<strong>函数的入参</strong>，对于<code>add</code>函数来说，它的输入永远为<code>void</code>。</p><p>修改<code>add</code>为纯函数</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">a</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">b</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这下就满足了纯函数的两个条件了</p><ul><li>对于相同的输入，总会有相同的输出👌</li><li>执行过程中没有语义上可观察的副作用：<code>add</code>函数除了加法计算外，并没有处理其他事务👌</li></ul><h3 id="姓名处理" tabindex="-1">姓名处理 <a class="header-anchor" href="#姓名处理" aria-label="Permalink to &quot;姓名处理&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">firstName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">secondName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fullName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}-\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">secondName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`i am \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fullName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fullName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个函数是纯函数吗？</p><p><strong>不是！</strong></p><p><code>console.log</code>会在控制台上打印一行文字，这其实改变了浏览器的控制台，也属于影响了外部世界，可以明确的说<strong>processName 函数在执行过程中产生了副作用</strong>。</p><p>要把它改回纯函数也非常简单，将<code>console.log</code>提取出去就可以了</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> processName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">firstName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">secondName</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> fullName</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">firstName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}-\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">secondName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> fullName</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`i am \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fullName</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h3 id="网络请求" tabindex="-1">网络请求 <a class="header-anchor" href="#网络请求" aria-label="Permalink to &quot;网络请求&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> getData</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">url</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> response</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> await</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(url)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">	const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">data</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> response</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> data</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这个函数是纯函数吗？</p><p><strong>不是！因为一个引用了网络请求的函数，从严格意义上来说就不是纯的</strong></p><p>原因如下：</p><ul><li>请求获取到的<code>response</code>是动态的，需要通过网络请求获取的数据往往是动态的，<strong>对于相同的<code>url</code>输入，服务端未必能确保给出相同的输出</strong></li><li>请求可能出错：既然网络请求，那就一定要考虑失败率的问题，请求过程中未经捕获的<code>Error</code>会阻断代码的执行，本身就是一种副作用。</li><li>当请求方法为<code>post</code> <code>delete</code>等具有“写”能力的类型时，网络请求将会执行对外部数据的写操作，这会使函数更加“不纯”。</li></ul><h2 id="纯-的本质" tabindex="-1">“纯”的本质 <a class="header-anchor" href="#纯-的本质" aria-label="Permalink to &quot;“纯”的本质&quot;">​</a></h2><p>这里直接给出定义：<strong>纯函数---有且仅有【显式】数据流。</strong></p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><strong>维基百科上也有这样的解释</strong>:纯函数(Pure Function) ---- 输入输出数据流全是显式的函数</p></div><p>所谓的“显式”，就是约束数据的来源（<strong>入参</strong>）和出口（<strong>形参</strong>）</p><p>说的通透一点：<strong>纯函数是 输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其他形式和外界进行数据交换的函数。</strong></p><p>显示数据流就代表了 ———— 函数除了入参和返回值之外，不准以任何其他形式与外界进行数据交换。</p><h2 id="不纯-的原因" tabindex="-1">“不纯” 的原因 <a class="header-anchor" href="#不纯-的原因" aria-label="Permalink to &quot;“不纯” 的原因&quot;">​</a></h2><p>在 加法运算 的例子中，它的不纯是因为<strong>隐式的数据输入</strong>导致的，观察<code>add</code>函数的入参声明，并不能发现两个数据源的存在</p><p><img src="`+t+`" alt="image"></p><p><strong>而一个纯函数在执行工程中应该只有横向的显示数据流，不应该有纵向的隐示数据流。</strong></p><h2 id="从数学角度看纯函数" tabindex="-1">从数学角度看纯函数 <a class="header-anchor" href="#从数学角度看纯函数" aria-label="Permalink to &quot;从数学角度看纯函数&quot;">​</a></h2><p>其实数学家和程序员有一个公共的特点：数学家们和程序员在解决问题的时候，都在进行问题抽象和寻找复用。</p><p>很多人第一次接触<strong>函数</strong>这一概念，应该是在初高中学数学的时候。数学中的函数与程序中的函数是不能画全等号的，对于严谨的数学来说，函数的定义及其严格和简洁：<strong>对于一个给定的自变量 x，总是会有且仅有一个因变量 y 与它对应，同一个输入，同一个输出。</strong></p><p>而程序中的函数，却不规范很多，因为影响函数的执行的外界因素太多了:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}    </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 3</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)   </span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出 12</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>程序中的函数允许函数去读写外部变量，允许函数产生副作用。</p><p>而<strong>纯函数</strong>这一概念就是向数学层面上的函数靠近，说白了**纯函数就是为了纯粹的计算，其他事情一律不做。**这样一看纯函数的优势开始出现：</p><ul><li>极高的确定性，副作用函数风险就在于它是确定的，同样的输入在不同情况下却出现不同的输出，拿单元测试举例，单元测试的核心就是测试输入和输出。如果对于同样的输入，函数不能够给到确定的输出，测试的难度将会陡然上升。<strong>不确定性意味着风险，而风险就代表了程序易碎。</strong></li><li>消除副作用，纯函数没有并行竞争的问题，因为不纯的函数可能访问同一资源会出现混乱的竞争态，而纯函数则不存在这种问题，纯函数的计算完全发生在函数的内部，它不会对外部资源产生任何影响，因此纯函数的并行计算总是安全的。关于这一点，Vue3的<code>watch</code>就有<strong>竞态</strong>的问题，是一个很典型的例子。</li><li>极高的灵活性，类比数学，数学中的<strong>公式</strong>就是就是极度灵活的“纯函数”，它可以应用的任何领域且保证输入输出唯一，具有副作用的函数往往被特定的环境给困死，难以抽离，而纯函数是高度灵活的函数，它的计算逻辑在任何上下文里都是成立的。</li><li>符合设计模式思想，之前设计模式中提到一个概念要将<strong>变与不变</strong>的地方所分离，而纯函数也讲究将<strong>计算与副作用</strong>分离，这样程序的“外部影响”和“内部计算”解耦了。</li></ul><h2 id="副作用一无是处" tabindex="-1">副作用一无是处? <a class="header-anchor" href="#副作用一无是处" aria-label="Permalink to &quot;副作用一无是处?&quot;">​</a></h2><p>对于纯函数来说，副作用就是头等“敌人”。</p><p>但对于程序来说，副作用函数在程序内部中也是至关重要的，实践纯函数的目的并不是消灭副作用，而是将计算逻辑与副作用做合理的分层解耦，从而提升我们的编码质量和执行效率。</p><p>在Vue3的响应式里面，会发现数据驱动视图时，需要去修改外界的DOM元素，那么这些函数，基本上全是副作用函数，所以不要“敌视”副作用函数。</p><h2 id="引用类型破坏-纯-度" tabindex="-1">引用类型破坏“纯”度 <a class="header-anchor" href="#引用类型破坏-纯-度" aria-label="Permalink to &quot;引用类型破坏“纯”度&quot;">​</a></h2><p>在JS中，当为一个变量赋值为引用类型时，实际上赋值的是“引用”</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> a</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  foo:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;bar&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> b</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">b.foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;baz&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(a.foo) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &#39;baz&#39;</span></span></code></pre></div><p>正因如此，引用类型常常会“偷袭”程序，因为你无法完全保证，你当前修改的这个引用类型变量a，是否会在未来或者就是当前，在程序的某处没有被另一个变量所引用。</p><p>这就是引用类型在函数中使用时，使得程序中出现了<strong>不确定性</strong></p><p>并且在开发中时常出现这样的问题，当为程序添加一段代码时，修改了某个引用类型的某个属性，且没有注意函数执行时的顺序，导致以前某个正常的函数中发生错误。</p><p>校验一个函数有效性的关键依据，永远是 <strong>“针对已知的输入，能否给出符合预期的输出”</strong> ，然而引用类型的出现，很明显的原因是因为它使得函数出现了 <strong>隐式的输出</strong>。</p><p>可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。</p><p>对于这样的问题，可以通过<strong>拷贝</strong>的方法来产生一个副本，使用原则：<strong>对于引用类型，不要盲目修改，而是拷贝。</strong></p><p>不要修改源，而是修改源的副本</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newObj </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	newObj.name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;new Obj&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> newObj</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>拷贝的目的就是为了：<strong>确保外部数据是只读的，而内部数据是可写的。</strong></p><p>但是显而易见的问题也出现了，如果通过拷贝来解决未免就太暴力了，假设存在一个上千字段的对象，只是为了在函数中修改其中一两个字段，那么拷贝的代价也太大了。对于<strong>数据规模巨大、数据变化频繁</strong>的对象，拷贝绝对是下下策。</p>`,67),h=[p];function k(e,r,d,E,o,g){return a(),i("div",null,h)}const F=s(l,[["render",k]]);export{y as __pageData,F as default};
