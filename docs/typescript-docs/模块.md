# 模块
TS中的模块使用与JS中的模块使用没什么大不同

## 导出
### 导出声明
任何声明（比如变量，函数，类，类型别名或接口）都能够通过添加`export`关键字导出

比如在`StringValidator.ts`文件中导出一个接口：
```ts 
export interface StringValidator {
  isAcceptable(s: string): boolean;
}
```

并在`ZipCodeValidator.ts`文件中引入并使用这个接口:
```ts
import { StringValidator } from "./StringValidator";

export const numberRegexp = /^[0-9]+$/;

export class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
```
### 导出语句
导出语句很遍历，有时需要对导出的部分进行重命名，所以可以在`ZipCodeValidator.ts`中这样来写：
```ts
class ZipCodeValidator implements StringValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
export { ZipCodeValidator };
export { ZipCodeValidator as mainValidator };
```
### 重新导出
有时候可能经常会去扩展其它模块，并且只导出那个模块的部分内容。重新导出功能并不会在当前模块导入那个模块或定义一个新的局部变量。

比如在一个新的文件`ParseIntBasedZipCodeValidator.ts`
```ts
export class ParseIntBasedZipCodeValidator {
    isAcceptable(s: string) {
        return s.length === 5 && parseInt(s).toString() === s;
    }
}

// 导出原先的验证器但做了重命名
export {ZipCodeValidator as RegExpBasedZipCodeValidator} from "./ZipCodeValidator";
```
或者说一个模块可以包裹多个模块，并把他们导出的内容联合在一起通过语法：`export * from "module"`
```ts
export * from "./StringValidator"; // exports 'StringValidator' interface
export * from "./ZipCodeValidator";  // exports 'ZipCodeValidator' and const 'numberRegexp' class
export * from "./ParseIntBasedZipCodeValidator";
//exports the 'ParseIntBasedZipCodeValidator' class 
//and re-exports 'RegExpBasedZipCodeValidator' as alias
// of the 'ZipCodeValidator' class from 'ZipCodeValidator.ts'
```

## 导入
模块的导入操作和导出一样简单。可以使用`import`这样的形式来导入其它模块中的导出内容。

### 导入一个模块中的某个导出内容
```ts
import { ZipCodeValidator } from "./ZipCodeValidator";

let myValidator = new ZipCodeValidator();
```
也可以队这个内容进行重命名
```ts
import { ZipCodeValidator as ZCV } from "./ZipCodeValidator";
let myValidator = new ZCV();
```
### 将这个模块导入到一个变量，并通过它来访问模块的导出部分
```ts
import * as validator from "./ZipCodeValidator";
let myValidator = new validator.ZipCodeValidator();
```

### 具有副作用的导入模块
尽管不推荐这么做，但是一些模块会设置一些全局状态来供其它模块使用。这些模块可能没有任何的导出或者使用者根本就不关心它的导出。那么可以使用下面这样的方法来导入这类模块。
```ts
import "./my-module.js";
```

### 默认导出
每个模块都可以有一个`default`导出。默认导出使用`default`关键字标记；并且一个模块只能够有一个`default`导出。需要使用一种特殊的导入形式来导入`default`导出。

`default`导出十分便利。比如，像JQuery这样的类库可能有一个默认导出`JQuery`或`$`。

```ts
// JQuery.d.ts
declare let $: jQuery;
export default $;

// App.ts
import $ from 'jQuery'
$("button.continue").html("Next Step...")
```
类和函数声明可以直接被标记为默认导出。标记为默认导出的类和函数的名字是可以直接省略的。
```ts
// ZipCodeValidator.ts
export default class ZipCodeValidator {
    static numberRegexp = /^[0-9]+$/;
    isAcceptable(s: string) {
        return s.length === 5 && ZipCodeValidator.numberRegexp.test(s);
    }
}

// Test.ts
import validator from "./ZipCodeValidator";

let myValidator = new validator();
```
或者
```ts
// StaticZipCodeValidator.ts
const numberRegexp = /^[0-9]+$/;

export default function (s: string) {
    return s.length === 5 && numberRegexp.test(s);
}
// Test.ts
import validate from "./StaticZipCodeValidator";

let strings = ["Hello", "98052", "101"];

// Use function validate
strings.forEach(s => {
  console.log(`"${s}" ${validate(s) ? "matches" : "does not match"}`);
});
```
当然`default`导出也可以是一个值
```ts
export default "123";

import num from "./OneTwoThree";

console.log(num); // "123"
```

## export= 和 import=require()
CommonJS 和 AMD 的环境里都有一个`exports`变量，这个变量包含了一个模块的所有导出内容。
CommonJS 和 AMD 的`exports`都可以被赋值为一个**对象**，在这种情况下其作用就类似于**es6**语法里的默认导出，即`export default`的语法。虽然作用相似，但是`export default`语法并不能兼容CommonJS和AMD的exports。
为了兼容这种情况，TS提供了`export =`的语法。
`export =`语法定义了一个模块的导出**对象**。这里的**对象**一词指的是类，接口，命名空间，函数或枚举。
若使用`export =`导出一个模块，则必须使用特定的语法`import module = require("module")`来导入这个模块。

```ts
// ZipCodeValidator.ts
let numberRegexp = /^[0-9]+$/;
class ZipCodeValidator {
    isAcceptable(s: string) {
        return s.length === 5 && numberRegexp.test(s);
    }
}
export = ZipCodeValidator;
```
```ts
// Test.ts
import zip = require("./ZipCodeValidator");

// Some samples to try
let strings = ["Hello", "98052", "101"];

// Validators to use
let validator = new zip();

// Show whether each string passed each validator
strings.forEach(s => {
  console.log(`"${ s }" - ${ validator.isAcceptable(s) ? "matches" : "does not match" }`);
});
```