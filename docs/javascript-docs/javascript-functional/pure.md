# 纯函数 副作用
在函数式编程中，**纯函数是函数式编程的一个重要的前提，也是函数式编程这一体系的根基。**

## 纯函数的特征
凡是满足以下两个特征的函数，就可以被认为是纯函数：
- 对于相同的输入，总是要得到相同的输出
- 在执行过程中没有语义上可观察的副作用

## 副作用的特征
如果一个函数除了计算之外，还对它的执行上下文和执行宿主等外部环境造成了一些其它的影响，那么这个影响就被称为**副作用**。

:::tip
**维基百科如此评价：** 在计算机科学中，函数副作用指的是当调用函数时，除了返回可能的函数值之外，还对主调用函数产生了附加影响。
:::
 
## 纯函数示例
### 加法运算
```js
let a = 10
let b = 20
function add(){
  return a + b
}
```
这个函数是纯函数吗？

**不是！**

因为对于不同的输入，它得到了不同的输出：如果首次调用 `add` 方法，会得到`30`，一旦修改`a = 100 ; b = 200` ;时，输出就变为了`300`

这里需要强调的是，“输入”指的是**函数的入参**，对于`add`函数来说，它的输入永远为`void`。

修改`add`为纯函数

```js
let a = 10
let b = 10

function add(a,b){
	return a + b;
}
```
这下就满足了纯函数的两个条件了
- 对于相同的输入，总会有相同的输出👌
- 执行过程中没有语义上可观察的副作用：`add`函数除了加法计算外，并没有处理其他事务👌

### 姓名处理
```js
function processName(firstName,secondName){
	const fullName = `${firstName}-${secondName}`
  console.log(`i am ${fullName}`)
  return fullName
}
```
这个函数是纯函数吗？

**不是！**

`console.log`会在控制台上打印一行文字，这其实改变了浏览器的控制台，也属于影响了外部世界，可以明确的说**processName 函数在执行过程中产生了副作用**。

要把它改回纯函数也非常简单，将`console.log`提取出去就可以了
```js
function processName(firstName,secondName){
  const fullName = `${firstName}-${secondName}`
  return fullName
}
console.log(`i am ${fullName}`)
```
### 网络请求
```js
function getData(url){
  const response = await fetch(url)
	const { data } = response
  return data
}
```
这个函数是纯函数吗？

**不是！因为一个引用了网络请求的函数，从严格意义上来说就不是纯的**

原因如下：
- 请求获取到的`response`是动态的，需要通过网络请求获取的数据往往是动态的，**对于相同的`url`输入，服务端未必能确保给出相同的输出**
- 请求可能出错：既然网络请求，那就一定要考虑失败率的问题，请求过程中未经捕获的`Error`会阻断代码的执行，本身就是一种副作用。 
- 当请求方法为`post` `delete`等具有“写”能力的类型时，网络请求将会执行对外部数据的写操作，这会使函数更加“不纯”。

## “纯”的本质
这里直接给出定义：**纯函数---有且仅有【显式】数据流。**

:::tip
**维基百科上也有这样的解释**:纯函数(Pure Function) ---- 输入输出数据流全是显式的函数
:::
所谓的“显式”，就是约束数据的来源（**入参**）和出口（**形参**）

说的通透一点：**纯函数是 输入只能够以参数形式传入，输出只能够以返回值形式传递，除了入参和返回值之外，不以任何其他形式和外界进行数据交换的函数。**

显示数据流就代表了 ———— 函数除了入参和返回值之外，不准以任何其他形式与外界进行数据交换。

## “不纯” 的原因
在 加法运算 的例子中，它的不纯是因为**隐式的数据输入**导致的，观察`add`函数的入参声明，并不能发现两个数据源的存在

![image](./assets/%E9%9A%90%E5%BC%8F%E8%BE%93%E5%85%A5.png)

**而一个纯函数在执行工程中应该只有横向的显示数据流，不应该有纵向的隐示数据流。**

## 从数学角度看纯函数
其实数学家和程序员有一个公共的特点：数学家们和程序员在解决问题的时候，都在进行问题抽象和寻找复用。

很多人第一次接触**函数**这一概念，应该是在初高中学数学的时候。数学中的函数与程序中的函数是不能画全等号的，对于严谨的数学来说，函数的定义及其严格和简洁：**对于一个给定的自变量 x，总是会有且仅有一个因变量 y 与它对应，同一个输入，同一个输出。**

而程序中的函数，却不规范很多，因为影响函数的执行的外界因素太多了:

```js
let a = 1  

function add(x) {
  return a + x
}    

// 输出 3
add(2)   

a = 10

// 输出 12
add(2)
```
程序中的函数允许函数去读写外部变量，允许函数产生副作用。

而**纯函数**这一概念就是向数学层面上的函数靠近，说白了**纯函数就是为了纯粹的计算，其他事情一律不做。**这样一看纯函数的优势开始出现：
- 极高的确定性，副作用函数风险就在于它是确定的，同样的输入在不同情况下却出现不同的输出，拿单元测试举例，单元测试的核心就是测试输入和输出。如果对于同样的输入，函数不能够给到确定的输出，测试的难度将会陡然上升。**不确定性意味着风险，而风险就代表了程序易碎。**
- 消除副作用，纯函数没有并行竞争的问题，因为不纯的函数可能访问同一资源会出现混乱的竞争态，而纯函数则不存在这种问题，纯函数的计算完全发生在函数的内部，它不会对外部资源产生任何影响，因此纯函数的并行计算总是安全的。关于这一点，Vue3的`watch`就有**竞态**的问题，是一个很典型的例子。
- 极高的灵活性，类比数学，数学中的**公式**就是就是极度灵活的“纯函数”，它可以应用的任何领域且保证输入输出唯一，具有副作用的函数往往被特定的环境给困死，难以抽离，而纯函数是高度灵活的函数，它的计算逻辑在任何上下文里都是成立的。
- 符合设计模式思想，之前设计模式中提到一个概念要将**变与不变**的地方所分离，而纯函数也讲究将**计算与副作用**分离，这样程序的“外部影响”和“内部计算”解耦了。

## 副作用一无是处?
对于纯函数来说，副作用就是头等“敌人”。

但对于程序来说，副作用函数在程序内部中也是至关重要的，实践纯函数的目的并不是消灭副作用，而是将计算逻辑与副作用做合理的分层解耦，从而提升我们的编码质量和执行效率。

在Vue3的响应式里面，会发现数据驱动视图时，需要去修改外界的DOM元素，那么这些函数，基本上全是副作用函数，所以不要“敌视”副作用函数。

## 引用类型破坏“纯”度
在JS中，当为一个变量赋值为引用类型时，实际上赋值的是“引用”
```js
const a = {
  foo:'bar'
}

const b = a
b.foo = 'baz'

console.log(a.foo) // 'baz'
```
正因如此，引用类型常常会“偷袭”程序，因为你无法完全保证，你当前修改的这个引用类型变量a，是否会在未来或者就是当前，在程序的某处没有被另一个变量所引用。

这就是引用类型在函数中使用时，使得程序中出现了**不确定性**

并且在开发中时常出现这样的问题，当为程序添加一段代码时，修改了某个引用类型的某个属性，且没有注意函数执行时的顺序，导致以前某个正常的函数中发生错误。

校验一个函数有效性的关键依据，永远是 **“针对已知的输入，能否给出符合预期的输出”** ，然而引用类型的出现，很明显的原因是因为它使得函数出现了 **隐式的输出**。

可变数据的存在，要求我们不得不在调用一个函数之前，先去了解它的逻辑细节、定位它对外部数据的依赖情况和影响情况，由此来确保调用动作的安全性。

对于这样的问题，可以通过**拷贝**的方法来产生一个副本，使用原则：**对于引用类型，不要盲目修改，而是拷贝。**

不要修改源，而是修改源的副本

```js
function foo(obj) {
  let newObj = {...obj}
	newObj.name = 'new Obj'
  return newObj
}
```
拷贝的目的就是为了：**确保外部数据是只读的，而内部数据是可写的。**

但是显而易见的问题也出现了，如果通过拷贝来解决未免就太暴力了，假设存在一个上千字段的对象，只是为了在函数中修改其中一两个字段，那么拷贝的代价也太大了。对于**数据规模巨大、数据变化频繁**的对象，拷贝绝对是下下策。