# 回流重绘的优化
很多时候，对DOM的操作都不会局限于访问上，而是为了修改它，当对DOM修改会引起它外观（样式）上的改变时，就会触发**回流**或**重绘**。

发生这个问题的根本原因在于是对DOM的修改触发了布局树的变化而导致的。

- **回流：** 对DOM的修改引发了DOM几何尺寸的变化(比如修改元素的宽，高或隐藏元素等)时，浏览器需要重新计算元素的几何属性（其他元素的几何属性和位置也会因此收到影响），然后再将计算的结果绘制出来，这个过程就叫做回流

- **重绘：** 对DOM的修改导致了样式的变化，却并没有影响其几何属性时，浏览器不需要重新计算元素的几何属性，直接为该元素绘制新的样式。这个过程就叫做重绘。

一般来说可以考虑以下几个优化点：
### 文档碎片
文档碎片模型DocumentFragment的思路：JS层面上的事情，让JS自己去进行处理，处理好了之后再和DOM进行操作。

:::tip
DocumentFragment 接口表示一个没有父级文件的最小文档对象。它被当做一个轻量版的 Document 使用，用于存储已排好版的或尚未打理好格式的XML片段。因为 DocumentFragment 不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。
:::
这样做的好处在于可以脱离真实DOM树的容器出现，用于缓存批量化的DOM操作。

DOM Fragment可以帮助更好的结构化的方式去达成同样的目的，从而在维持性能的同时，让代码的可扩展和可维护性。现在用DOM Fragment来改写上面的例子:
```js
let container = document.getElementById('container')
// 创建一个DOM Fragment对象作为容器
let content = document.createDocumentFragment()
for(let count=0;count<10000;count++){
  // span此时可以通过DOM API去创建
  let oSpan = document.createElement("span")
  oSpan.innerHTML = '我是一个小测试'
  // 像操作真实DOM一样操作DOM Fragment对象
  content.appendChild(oSpan)
}
// 内容处理好了,最后再触发真实DOM的更改
container.appendChild(content)

```
可以看出，DOM Fragment 对象允许像操作真实 DOM 一样去调用各种各样的 DOM API，代码质量因此得到了保证。并且它的身份也非常纯粹：当试图将其 append 进真实 DOM 时，它会交出自身缓存的所有后代节点后全身而退，完美地完成一个容器的使命，而不会出现在真实的 DOM 结构中。这种结构化、干净利落的特性，使得 DOM Fragment 作为经典的性能优化手段在vue的源码中也有所体现。

### 离线DOM
一旦我们给元素设置 `display: none`，将其从页面上“拿掉”，那么我们的后续操作，将无法触发回流与重绘——这个将元素“拿掉”的操作，就叫做 DOM 离线化
```js
let container = document.getElementById('container')
container.style.display = 'none'
container.style.width = '100px'
container.style.height = '200px'
container.style.border = '10px solid red'
container.style.color = 'red'
...（省略了许多类似的后续操作）
container.style.display = 'block'
```
虽然拿掉一个元素再将其放回去，也会触发一次昂贵的回流，但是拿下去之后后续不管操作多少编，都不会引起回流重绘了，当有元素将进行批量的复杂的DOM操作时，DOM离线化的优越性就变得特别明显了。此时“拿下”和“放回”的开销看起来也就比较值得了。

### 推荐使用transform
要对元素进行一些动画，尽量使用`transform`，而不是直接改变元素的尺寸，位置或布局。

这是因为`transform`发生在合成线程中，所以不会被主线程所阻塞，而且有效减少回流的操作。

```css
/* 使用 transform 和 opacity 进行动画 */
.element {
  transform: translateX(100px);
  opacity: 0.5;
}

/* 避免使用直接改变布局的属性 */
.element {
  /* 避免直接改变尺寸、位置等属性 */
}
```

### will-change
对于会明确进行复杂的动画的区域，可以使用`will-change`来标记这一块区域，那么在渲染时，会大概率将这个区域分离到一个单独的图层，从而提高了重绘和重排的效率
```js
.element {
  will-change: transform, opacity;
}
// 在动画之前添加上述代码，以启用硬件加速
```