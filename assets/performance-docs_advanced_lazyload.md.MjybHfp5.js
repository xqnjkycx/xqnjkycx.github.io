import{_ as s,c as a,o as i,U as e}from"./chunks/framework.PFQuerqu.js";const t="/assets/VPA.Pg3lGX18.png",n="/assets/vendors102ee.vruegYLY.png",l="/assets/debugger.Tcqwlm3v.png",y=JSON.parse('{"title":"Lazy Load","description":"","frontmatter":{},"headers":[],"relativePath":"performance-docs/advanced/lazyload.md","filePath":"performance-docs/advanced/lazyload.md","lastUpdated":1710950539000}'),p={name:"performance-docs/advanced/lazyload.md"},o=e('<h1 id="lazy-load" tabindex="-1">Lazy Load <a class="header-anchor" href="#lazy-load" aria-label="Permalink to &quot;Lazy Load&quot;">​</a></h1><p>Lazy Load 是指将部分资源延迟加载，从而去优化页面渲染用户体验的一种手段。懒加载的优化目标可以是浏览器中的一切需要HTTP请求的资源。</p><p>举个例子，在Vue的官方文档中，就对渲染搜索框组件的JS代码模块进行了懒加载优化，这部分组件并分割为了一个独立的文件<code>VPAlgoliaSearchBox.d8791224.js</code>文件，并延迟到页面渲染后，用户点击搜索框时才加载。</p><p><img src="'+t+'" alt="image"></p><h2 id="模块懒加载核心原理" tabindex="-1">模块懒加载核心原理 <a class="header-anchor" href="#模块懒加载核心原理" aria-label="Permalink to &quot;模块懒加载核心原理&quot;">​</a></h2><p>代码模块懒加载的实现核心基于2项原理：</p><ul><li>代码模块化</li><li>动态导入语法<code>import()</code></li></ul><h3 id="代码模块化" tabindex="-1">代码模块化 <a class="header-anchor" href="#代码模块化" aria-label="Permalink to &quot;代码模块化&quot;">​</a></h3><p>现代前端工程普遍都是基于Webpack，Rollup等工具的打包能力，实现源代码模块化，把源代码分割为多个独立的模块Module，对应独立的JS，CSS文件，可以很方便地隔离命名空间，封装代码，复用模块，管理依赖～</p><p>现在的前端主要模块化规范就是2类：</p><ul><li>ES Module：注意依赖于<code>import</code>和<code>export</code></li><li>Common JS Module：主要依赖于<code>require</code>和<code>module.exports</code></li></ul><h3 id="构建工具-模块动态导入特性" tabindex="-1">构建工具 模块动态导入特性 <a class="header-anchor" href="#构建工具-模块动态导入特性" aria-label="Permalink to &quot;构建工具 模块动态导入特性&quot;">​</a></h3><p>Webpack这样的前端构建工具的<a href="https://webpack.js.org/guides/code-splitting/#dynamic-imports" target="_blank" rel="noreferrer">Dynamic Import()</a> 动态导入 的特性就是依赖于JS的懒加载，动态导入在ES模块化的基础上增加了<code>import()</code>这样的语法：</p><ul><li>导入语句会返回一个<code>Promise</code>实例，模块加载成功之后会变为<code>fullfilled</code>状态，加载失败则为<code>failed</code>状态</li><li>在构建时，对应模块会被拆分为独立的区块<code>chunk</code>，生成独立的产物文件</li><li>在运行时，会在模块需要加载执行时，通过动态添加<code>script</code>标签，来触发下载并运行对应的产物文件</li></ul><table><thead><tr><th></th><th>普通写法</th><th>懒加载写法</th></tr></thead><tbody><tr><td>代码示例</td><td>import LoginPage from &#39;../pages/login&#39;</td><td>const LoginPage = import(&#39;../pages/login&#39;)</td></tr></tbody></table><p>在Webpack中，还可以通过魔法注释来配置动态导入的方式，文件名等细节，详细的配置如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> LoginPage</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackChunkName:&quot;login&quot; */</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;../pages/login&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>使用<code>/* webpackChunkName:&quot;login&quot; */</code>可以指定产出文件的名称。那么如果为多个不同动态导入的模块，备注同一个 <code>webpackChunkName</code>，那么这些模块就会被合并为同一个区块，最终合并到同一个大包产物中，这个技巧可以用于把多个模块合并为一个产物文件。</p><h2 id="确定懒加载目标" tabindex="-1">确定懒加载目标 <a class="header-anchor" href="#确定懒加载目标" aria-label="Permalink to &quot;确定懒加载目标&quot;">​</a></h2><p>这里提供两种常用的懒加载优化思路</p><h3 id="按路由" tabindex="-1">按路由 <a class="header-anchor" href="#按路由" aria-label="Permalink to &quot;按路由&quot;">​</a></h3><p>第一种思路是按照前端路由分析懒加载的目标。</p><p>常见的单页应用SPA前端项目就会基于前端路由，形成许多路由路径对应的页面组件，例如登陆页<code>/login</code>的对应的模块，源码主要写在<code>login.vue</code>文件中</p><p>那么用户访问时，一般只需要渲染1个路由，其余的路由暂时不需要加载运行，那么就可以对这些攒不运行的页面组件进行懒加载优化</p><p>以一般的项目为例，路由路径和对应页面组件有：</p><ul><li><code>/login</code>:<code>&#39;@/pages/login.vue&#39;</code></li><li><code>/registration</code>:<code>&#39;@/pages/registration&#39;</code></li><li><code>/home:&#39;@/pages/home&#39;</code></li><li><code>/article</code>:<code>&#39;@/pages/article&#39;</code></li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这些页面组件模块都可以进行懒加载优化，延迟加载其代码，推迟到组件需要渲染时再加载，从而减轻页面初始化时的性能负担</p></div><h3 id="按模块体积" tabindex="-1">按模块体积 <a class="header-anchor" href="#按模块体积" aria-label="Permalink to &quot;按模块体积&quot;">​</a></h3><p>这种思路一般按照<strong>模块体积大小</strong>来分析懒加载的目标，选择使用<code>webpack-bundle-analyzer-plugin</code>生成的可视化图表，来观察每个模块的体积，把较大的模块作为懒加载优化的目标。 <img src="'+n+`" alt="image"> 其中大多数都是项目初始化的核心依赖模块，例如<code>react-dom</code>，<code>axios</code>，没有这些模块。前端页面也就无法完成渲染，所以强烈不建议进行懒加载优化处理～</p><p>但是<code>react-hook-form/dist/index.esm.mjs</code>、<code>mardown-to-jsx/dist/index.modern.js</code>这2个模块，则并非页面初始化渲染所必须的模块，可以进行懒加载优化。</p><h3 id="添加懒加载逻辑" tabindex="-1">添加懒加载逻辑 <a class="header-anchor" href="#添加懒加载逻辑" aria-label="Permalink to &quot;添加懒加载逻辑&quot;">​</a></h3><p>比如在Vue中，就可以使用自带的路由懒加载和异步组件来完成懒加载导入：</p><div class="language-jsx vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">jsx</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. vue-router 路由组件懒加载</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 文档：https://router.vuejs.org/guide/advanced/lazy-loading.html</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> UserDetails</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./views/UserDetails.vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> router</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> createRouter</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // ...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  routes: [{ path: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/users/:id&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, component: UserDetails }],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Vue.js 组件懒加载</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 文档：https://vuejs.org/guide/components/async.html</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">import { defineAsyncComponent } from &#39;vue&#39;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">const AdminPage = defineAsyncComponent(() =&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  import(&#39;./components/AdminPageComponent.vue&#39;)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">AdminPage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><h2 id="懒加载的常见问题" tabindex="-1">懒加载的常见问题 <a class="header-anchor" href="#懒加载的常见问题" aria-label="Permalink to &quot;懒加载的常见问题&quot;">​</a></h2><h3 id="遗留直接导入导致目标模块没有被拆分" tabindex="-1">遗留直接导入导致目标模块没有被拆分 <a class="header-anchor" href="#遗留直接导入导致目标模块没有被拆分" aria-label="Permalink to &quot;遗留直接导入导致目标模块没有被拆分&quot;">​</a></h3><p>第一类问题的表现是：修改为动态导入<code>import()</code>后不生效，打包构建的产物中，目标模块没有被拆分为独立文件。</p><p>这个问题常见的原因是目标模块有多处直接导入<code>（import * from &#39;module&#39;）</code>，只改了部分目标模块的直接导入，仍然遗留了部分。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>解决方案可以先考虑全局搜索，再在目标模块中加入<code>debugger</code>，在开发环境运行后，根据调用栈来排查哪些组件有导入目标模块</p></div><p><img src="`+l+'" alt="image"></p><h3 id="被其他代码拆分规则覆盖导致懒加载不生效" tabindex="-1">被其他代码拆分规则覆盖导致懒加载不生效 <a class="header-anchor" href="#被其他代码拆分规则覆盖导致懒加载不生效" aria-label="Permalink to &quot;被其他代码拆分规则覆盖导致懒加载不生效&quot;">​</a></h3><p>第二类问题的表现也是动态导入<code>import()</code>不生效，目标模块没有被拆分为独立文件。</p><p>但是原因却不同，一般是有其他代码拆分规则，例如Webpack配置的缓存组<code>splitChunk.cacheGroup</code>命中了动态导入模块，导致目标模块不能被拆分为独立区块<code>（chunk）</code>，也就不能产生独立的产物文件。</p><p>可行的解决方案是：检查<code>cacheGroups</code>配置，确认是否有缓存组的匹配规则（test属性）匹配到了目标模块。</p><p>如果有，将其<code>chunks</code>区块类型属性从<code>&#39;all&#39;</code>改为<code>&#39;initial&#39;</code>，表示这个<code>cacheGroups</code>只包含<code>initial</code>类型的模块，即直接导入的模块。动态导入的模块，将会被排除出<code>cacheGroups</code>，从而将目标模块拆分成独立的产物文件。</p><h3 id="预期之外的非目标模块被懒加载处理" tabindex="-1">预期之外的非目标模块被懒加载处理 <a class="header-anchor" href="#预期之外的非目标模块被懒加载处理" aria-label="Permalink to &quot;预期之外的非目标模块被懒加载处理&quot;">​</a></h3><p>第三类问题的表现是预期之外的非优化目标模块却被打包进了拆分出的独立文件中。</p><p>可能的原因是多个模块之间导入、导出关系复杂，例如NPM包内部的依赖关系，非目标模块可能是目标模块依赖的依赖，从而被拆分到了独立产物文件。</p><p>通常来说，这种情况是符合预期的，因为非目标模块也算是目标模块依赖的一部分，被拆分出来不会对优化效果产生负面影响。</p><p>如果不希望非目标模块被拆分打包，可以考虑为这个模块，在其预期归属模块中，额外增加一处直接导入，从而避免被拆分到独立产物文件中</p>',49),d=[o];function h(c,r,k,g,E,u){return i(),a("div",null,d)}const b=s(p,[["render",h]]);export{y as __pageData,b as default};
