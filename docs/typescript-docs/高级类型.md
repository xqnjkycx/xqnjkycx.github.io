# 高级类型

## 交叉类型
交叉类型可以将多个类型合并为一个类型。这样可以使得把现有的多种类型叠在一起变为一种类型，它包含了所需的所有类型的特性。例如`Person & Serializable & Loggable`同时是`Person`和`Serializable`和`Loggable`。

也就是说这个类型的对象同时拥有了三种类型的成员。

```ts
function extend<First, Second>(first: First, second: Second): First & Second {
    // 联合First类型和Second类型
    const result: Partial<First & Second> = {};
    for (const prop in first) {
        if (first.hasOwnProperty(prop)) {
            (result as First)[prop] = first[prop];
        }
    }
    for (const prop in second) {
        if (second.hasOwnProperty(prop)) {
            (result as Second)[prop] = second[prop];
        }
    }
    // 遍历其所有的属性集合并进行返回
    return result as First & Second;
}

class Person {
    constructor(public name: string) { }
}

interface Loggable {
    log(name: string): void;
}

class ConsoleLogger implements Loggable {
    log(name) {
        console.log(`Hello, I'm ${name}.`);
    }
}

const jim = extend(new Person('Jim'), ConsoleLogger.prototype);
jim.log(jim.name);
```

## 联合类型
联合类型，可以让某种类型只要是A类型或B类型的一种即可。
```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}

padLeft("Hello world", 4); // returns "    Hello world"

```
但是如果一个值是联合类型，就只能访问这个联合类型的所有类型里共有的成员。
```ts
interface Bird {
    fly();
    layEggs();
}

interface Fish {
    swim();
    layEggs();
}

function getSmallPet(): Fish | Bird {
    // ...
}

let pet = getSmallPet();
pet.layEggs(); // okay
pet.swim();    // errors
```

## 类型守卫
联合类型适合用于那些值可以为不同类型的情况。如果不明确其中一个类型究竟有哪些属性，就会导致使用上会非常小心翼翼。
```ts
let pet = getSmallPet();

// 访问swim可能报错，因为不清楚pet是否有swim属性
if (pet.swim) {
    pet.swim();
}
// 访问fly可能报错，因为不清楚pet是否有fly属性
else if (pet.fly) {
    pet.fly();
}
```
为了让这段代码工作，就必须加上很多的类型断言
```ts
let pet = getSmallPet();

if ((pet as Fish).swim) {
    (pet as Fish).swim();
} else if ((pet as Bird).fly) {
    (pet as Bird).fly();
}
```

### 用户自定义的类型守卫
在上面的例子中，不得不多次使用类型断言。但是一旦通过第一个分支的类型检查，实际上就已经清楚了后续所有的分支的pet类型了。

TypeScript中的**类型守卫**机制让其变成了现实。类型守卫就是一些表达式，并且会在运行时检查以确保在某个作用域里的类型。

#### 使用类型判定
要定义一个类型守卫，只需要简单定义一个函数，它的返回值是一个**类型谓词**：
```ts
function isFish(pet: Fish | Bird): pet is Fish {
    return (pet as Fish).swim !== undefined;
}
// pet is Fish 就是类型谓词
// paramterName is Type 就是谓词形式，但是 paramterName 必须是来自当前函数签名的一个参数名
```
这样当一些变量使用`isFish`时，TypeScript 会将变量缩减为那个具体的类型，只要这个类型与变量的原始类型是兼容的即可：
```ts
// 'swim' 和 'fly' 调用都没有问题了

if (isFish(pet)) {
    pet.swim();
}
else {
    pet.fly();
}
```
此时，TypeScript不仅知道`if`分支里的`pet`是`Fish`类型；它还确认`else`分支里一定不是`Fish`类型。

#### typeof类型守卫
如果每个守卫都通过定义一个函数这样的方式来判断也太麻烦了。可以使用`typeof x === "number"`这样的方式来进行类型判别，TypeScript会将`typeof`识别为一个类型守卫，也就是说可以直接在代码里检查类型了。
```ts
function padLeft(value: string, padding: string | number) {
    if (typeof padding === "number") {
        return Array(padding + 1).join(" ") + value;
    }
    if (typeof padding === "string") {
        return padding + value;
    }
    throw new Error(`Expected string or number, got '${padding}'.`);
}
```
:::tip
`typeof`类型守卫只有几种类型可以被识别："number" "string" "boolean" "symbol"
:::

#### instanceof类型守卫
instanceof 类型守卫 是通过构造函数来细化类型的一种方式
```ts
interface Padder {
    getPaddingString(): string
}

class SpaceRepeatingPadder implements Padder {
    constructor(private numSpaces: number) { }
    getPaddingString() {
        return Array(this.numSpaces + 1).join(" ");
    }
}

class StringPadder implements Padder {
    constructor(private value: string) { }
    getPaddingString() {
        return this.value;
    }
}

function getRandomPadder() {
    return Math.random() < 0.5 ?
        new SpaceRepeatingPadder(4) :
        new StringPadder("  ");
}

// 类型为SpaceRepeatingPadder | StringPadder
let padder: Padder = getRandomPadder();

if (padder instanceof SpaceRepeatingPadder) {
    padder; // 类型细化为'SpaceRepeatingPadder'
}
if (padder instanceof StringPadder) {
    padder; // 类型细化为'StringPadder'
}

```
`instanceof`的右侧要求是一个构造函数，TypeScript将其细化为：
- 此构造函数的`prototype`属性的类型，如果它的类型不为`any`的话
- 构造签名所返回的类型的联合

## 可以为null的类型
默认情况下，类型检查器会认为`null`与`undefined`可以赋值给任何类型。`null`与`undefined`是所有其它类型的一个有效值。一般来说是阻止不了将它们赋值给其它类型，就算是想阻止也不太行。

可以在TS配置中开启`--strictNullChecks`标记，就可以解决这个错误：当声明一个变量时，它不会自动地包含`null`或`undefined`。
```ts
let s = "foo";
s = null; // 错误, 'null'不能赋值给'string'
let sn: string | null = "bar";
sn = null; // 可以

sn = undefined; // error, 'undefined'不能赋值给'string | null'
```
### 可选参数和可选属性
使用`--strictNullChecks`，可选参数会被自动地加上`| undefined`
```ts
function f(x: number, y?: number) {
    return x + (y || 0);
}
f(1, 2);
f(1);
f(1, undefined);
f(1, null); // error, 'null' is not assignable to 'number | undefined'
```
可选属性也是如此：
```ts
class C {
    a: number;
    b?: number;
}
let c = new C();
c.a = 12;
c.a = undefined; // error, 'undefined' is not assignable to 'number'
c.b = 13;
c.b = undefined; // ok
c.b = null; // error, 'null' is not assignable to 'number | undefined'
```
### 类型守卫和类型断言
由于可以为`null`的类型通过联合类型实现，那么就可以使用类型守卫来去除`null`
```ts
function f(sn: string | null): string {
    if (sn == null) {
        return "default";
    }
    else {
        return sn;
    }
}
```
这里明显去除了`null`，也可以使用短路运算符：
```ts
function f(sn: string | null): string {
    return sn || "default";
}
```
也可以使用类型断言去除，语法是`!`后缀：
```ts
name!.charAt(0)
```
## 类型别名
类型别名会给一个类型起上一个新的名字。类型别名看起来和接口很像，但是类型别名可以作用域于原始值，联合类型，元组以及其它任何需要手写的类型：
```ts
type Name = string;
type NameResolver = () => string;
type NameOrResolver = Name | NameResolver;
function getName(n: NameOrResolver): Name {
    if (typeof n === 'string') {
        return n;
    }
    else {
        return n();
    }
}
```
需要注意的是，起别名并不会创建一个类型，它创建了一个新的**名称**来引用那个类型。

同接口一样，类型别名也可以是泛型
```ts
type Container<T> = {value:T}
```
也可以使用类型别名在属性里来引用自己：
```ts
type Tree<T>={
  value:T;
  left:Tree<T>;
  right:Tree<T>;
}
```
与交叉类型一起使用，可以创造一些灵活的类型：
```ts
type LinkedList<T> = T & { next: LinkedList<T> };

interface Person {
    name: string;
}

var people: LinkedList<Person>;
var s = people.name;
var s = people.next.name;
var s = people.next.next.name;
var s = people.next.next.next.name;
```
## 接口与类型别名的区别

类型别名可以和接口一样。然而，仍然有一些细微差别：
- 接口创建了一个新的名字，可以在其它任何地方使用。类型别名并不创建新的名字——比如，错误信息就不会使用别名
- 接口无法用于描述一个类型并且需要使用联合类型或元组类型
```ts
type Person = { name: string; } | { setName(name:string): void };
// 接口实现不了这种形式
```
- 接口可以一直声明合并(多次声明同一个名的接口，TS会将其合并到一个声明中，并将其视为一个接口)。而重复声明类型别名是会报错的

一般情况下**推荐使用接口去替代类型别名**

## 可辨识联合
```ts
interface Square {
    kind: "square";
    size: number;
}
interface Rectangle {
    kind: "rectangle";
    width: number;
    height: number;
}
interface Circle {
    kind: "circle";
    radius: number;
}
```
每个接口都有`kind`属性但有不同的字符串字面量类型。`kind`属性称做为**可辨识的特征或标签**。而其它属性是特定于各个接口的。比如：
```ts
type Shape = Square | Rectangle | Circle;
```
这就可以使用辨识联合了：
```ts
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
}
```
### 完整性检查
如果希望添加`Triangle`这类新的类型，并且希望编译器通知需要更新的`area`:
```ts
type Shape = Square | Rectangle | Circle | Triangle;
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
    }
    // should error here - we didn't handle case "triangle"
}
```
非常推荐使用`never`类型，编译器用它来做完整性检查:
```ts
function assertNever(x: never): never {
    throw new Error("Unexpected object: " + x);
}
function area(s: Shape) {
    switch (s.kind) {
        case "square": return s.size * s.size;
        case "rectangle": return s.height * s.width;
        case "circle": return Math.PI * s.radius ** 2;
        default: return assertNever(s); // error here if there are missing cases
    }
}
```
`assertNever`检查`s`是否为`never`类型—即为除去所有可能情况后剩下的类型。这样的好处在于如果忘了某个新增的类型，那么`s`将具有一个真实的类型并且返回一个错误。