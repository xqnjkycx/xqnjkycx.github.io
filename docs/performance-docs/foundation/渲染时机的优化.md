# 渲染时机的优化
动画的画面其实是由一帧一帧的静态图快速切换组成的，人眼的反应速度有限，所以当画面切换的够快，对于人眼来说就是连续的动画了。



## reuqestAnimationFrame
:::tip
`window.requestAnimation`可以告诉浏览器希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。这个方法需要传入一个回调函数来作为参数，这个回调函数会在浏览器下一次重绘之前进行执行。
:::

这个API专门用于处理JS动画，相比于平常的定时器动画，`requestAnimation`更加稳定，其区别在于`requestAnimationFrame`不可以设置间隔时间，它的间隔时间是由浏览器自身来决定的，大约是`17ms`左右。

像`setTimeout`和`setInterval`的问题在于，它们并不是精确的。它们的内在运行机制决定了 **时间间隔参数** 实际上只是指定了把动画代码添加到 **浏览器UI线程队列** 中以等待执行的时间。如果队列前面已经加入了其它任务，那动画代码就要等前面的 **任务完成后** 再执行，就可能会导致动画可能不会按照预设的方式去执行，要么是间隔小于一帧导致多余的重绘，要么是间隔大于一帧，有一帧渲染空了，画面不流畅，会降低用户的体验。

:::tip
需要强调的一点是`requestAnimationFrame`能够保证回调函数在每一帧内只渲染一次，如果这一帧有太多的任务需要执行，还是会造成卡顿的，因此它只能保证重新渲染的时间间隔最短是屏幕的刷新时间。
:::

### 基本使用
- `requestAnimationFrame`本质上是一个全局`window`对象上的一个属性函数，函数是要被执行的，要被调用的。所以我们使时，直接：`window.requestAnimationFrame(callBack)`即可。

- 和定时器一样其接收的参数`callback`也是一个函数，即下一次重绘之前更新动画帧所调用的函数，即在这个函数体中，可以写对应的逻辑代码（和定时器类似）

- `requestAnimationFrame`也有返回值，返回值是一个整数，主要是定时器的身份证标识，可以使用 `window.cancelAnimationFrame()`来取消回调函数执行，相当于定时器中的`clearTimeout()`

- 想要继续执行，做到类似`setInterval`的效果，需要写成递归的形式

一个实际的代码例子：
```js
		// requestAnimationFrame请求动画帧方式
		function requestAnimationFrameFn() {
			let timer = null // 可注掉
			box2.style.left = '0px'
			function callbackFn() {
				let leftVal = parseInt(box2.style.left)
				if (leftVal >= 720) {
					cancelAnimationFrame(timer) 
				} else {
					box2.style.left = leftVal + 1 + 'px'
                    // 如果想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用
					window.requestAnimationFrame(callbackFn)
				}
			}
			window.requestAnimationFrame(callbackFn)
		}
```
回调函数的执行次数通常是每秒60次，但在大多数遵循`W3C`建议的浏览器中，回调函数执行次数通常与**浏览器屏幕刷新次数**互相匹配。一般大约为17.6ms。

并且为了提高性能和电池寿命，在大多数浏览器里，当`requestAnimationFrame()`运行在后台标签或隐藏的`<iframe>`里时，`requestAnimationFrame()`会被暂停调用来提升性能和电池寿命。

## requestIdleCallback
动画的画面其实是由一帧一帧的静态图快速切换组成的，人眼的反应速度有限，所以当画面切换的够快，人眼看着就是连续的动画了。

对于人眼来说，当每秒切换60张图片时，就会认为是连贯的。所以主流的显示器是60hz，1s刷新60次，那么每**16.7ms**就需要刷新一次，浏览器就会自动适配这个频率，对应的就是前端页面每16.7ms需要渲染一次。

![image](./assets/60fps%E6%B8%B2%E6%9F%93.png)

页面每隔16.7ms才会渲染一次，那么在两次渲染的中间时间，就是浏览器的**空闲时间**，在这段空闲时间执行的任务，是不会阻塞到页面渲染的流畅性。

反之，如果大量的耗时任务在一个区间连续执行的话，下一帧将会排到很后面才能执行，看着页面就会出现掉帧的效果。

![image](./assets/222fps%E6%B8%B2%E6%9F%93.png)

`requestIdleCallback` 就是浏览器提供给开发者来判断浏览器什么时候是**空闲时间**，什么时候是**空闲时间结束**，该进行渲染了。它会在浏览器的**空闲时间**来执行传给它的回调函数。如果指定了超时时间，则会在超时后的下一帧强制执行。

```js
const id = window.requestIdleCallback((deadline) => {
  // 当前帧剩余时间大于0，或任务已超时
  if(deadline.timeRemaining() > 0 || deadline.didTimeout) {
      // do something
      console.log(1)
  }
}, { timeout: 2000 }) // 指定超时时间

// window.cancelIdleCallback(id) 与定时器类似，支持取消
```

`requestIdleCallback`在`Event Loop`的执行时机如下图所示，彩色方块代表一帧之内的渲染任务，当这些任务被执行完成后，剩余时间被认为是**空闲时间**:

![image](./assets/%E6%B8%B2%E6%9F%93%E4%BB%BB%E5%8A%A1%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg)

`reuqestIdleCallback`和`requestAnimationFrame`的不同之处在于：
`requestIdleCallack`是捡浏览器空闲时间来执行任务。

:::tip
如果浏览器一直处于非常忙碌的状态，`requestIdleCallback`注册的任务有可能永远不会执行，当然可以指定`timeout`来保证一定执行。
:::

运气不好的是，`requestIdleCallback`的兼容性不太好，所以一般要做降级处理，通常使用`requestAnimationFrame`来做降级处理。

所以，一些低优先级但比较耗时的任务可以使用`requestIdleCallback`在浏览器不忙的时候来执行，最好是可以细分的一些任务。

因为发生在一帧的最后，此时页面布局已经完成，**所以不建议在 `requestIdleCallback` 里再操作 DOM，这样会导致页面再次重绘**。DOM 操作建议在 `requestAnimationFrame` 中进行。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。
