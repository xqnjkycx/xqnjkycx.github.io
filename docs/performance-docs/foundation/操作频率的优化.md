# 操作频率的优化
像一些事件可能会在短时间内被频繁触发，比如`scroll`，`resize`，还有鼠标事件`mousemove`和`mouseover`，以及键盘事件`keyup`和`keydown`等都存在频繁触发的风险。

频繁触发回调导致的大量计算会引发页面的抖动甚至卡顿。为了规避这种情况，我们需要一些手段来控制事件被触发的频率。就是在这样的背景下，`throttle（事件节流）`和 `debounce（事件防抖）`出现了。

## 节流与防抖的本质
“节流”和“防抖”函数的设计都以**闭包**的形式而存在。

通过对事件对应的回调函数进行包裹，以自由变量的形式缓存时间信息，最后用*setTimeout*来控制时间的触发频率。

### 节流函数 Throttle
throttle的中心思想在于：在某段时间内，不管触发了多少次回调，在这段时间内，都执行一次。

有的节流函数的实现会在计时周期结束的那一刻执行，而有的节流函数会在计时周期的开始那一刻执行。

这里手写一个，只有一段时间的结束时刻执行的throttle函数：
```js
function throttle(fn,delay){
    let timer = null
    return function(..args){
        if(!timer){
            let context = this
            timer = setTimeout(()=>{
                fn.apply(context,args)
                clearTimeout(timer)
                timer = null
            },delay)
        }
    }
}
```
这个是一段周期内只有开始时刻才开始执行的throttle函数:
```js
function throttle(fn,delay){
    let timer = null
    return function(args){
        if(!timer){
            fn.apply(this,args)
            timer = setTimeout(()=>{
                clearTimeout(timer)
                timer = null
            },delay)
        }
    }
}
```

### 防抖函数 debounce
防抖的中心思想在于：在一段频繁操作周期内，无论触发多少次回调函数，只有一次会触发，要么在开始时刻，要么在结束时刻。

这里手写一个在频繁操作周期开始时刻执行:
```js
function debounce(fn,delay){
    let timer = null
    return function(..args){
        if(!timer){
            fn.apply(this,args)
            clearTimeout(timer)
            timer = setTimeout(()=>{
                clearTimeout(timer)
                timer = null
            },delay)
        }
    }
}
```

这里手写一个在频繁操作周期结束时刻执行：
```js
function debounce(fn,delay){
    let timer = null
    return function(..args){
        if(!timer){
            let context = this
            clearTimeout(timer)
            timer = setTimeout(()=>{
                fn.apply(context,args)
                clearTimeout(timer)
                timer = null
            },delay)
        }
    }
}
```