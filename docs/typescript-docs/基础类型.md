# 基础类型
在TypeScript中，基础类型可以概括为以下12种：
- Boolean
- Number
- String
- Array
- Tuple
- Enum
- Unknown
- Any
- Void
- Null Undefined
- Never
- Object

## Boolean
和JS并无区别
```typescript
// Boolean
let isDone:Boolean = false;
```

## Number
TS里的所有数字都是浮点数number或者大整数bigint
```typescript
// Number bigint
let decLiteral:number = 6;
let hexLiteral:number = 0xf00d;
let binaryLiteral:number = 0b1010;
let bigLiteral:bigint = 100n;
```
## String
```typescript
let name:string = 'jinke.li'
let sentence:string=`Hello, my name is`
```
## Array
TS中有两种方式定义数组
```typescript
// 元素类型后接[]
let list: number[] = [1, 2, 3];
// 泛型
let list: Array<number> = [1, 2, 3];
```
## Tuple
元组类型表示一个已知元素数量和类型的数组，各元素类型不必相同。
```typescript
let x:[string,number]

x = ['hello',10]
```
这样做的好处在于，当访问一个已知索引的元素可以得到正确的类型
```typescript
console.log(x[0].substr(1)); // OK
console.log(x[1].substr(1)); // Error, 'number' does not have 'substr'
```
访问一个越界的元素会报错
```typescript
x[3] = "world" //Error, Property '3' does not exist on type '[string, number]'
```
## Enum
enum类型是对JavaScript标准数据类型的一个补充。使用枚举可以为一组数值赋予友好的名字
```typescript
enum Color {Red, Green, Blue}
let c: Color = Color.Green;
```
默认情况下，从0开始为元素编号，也可以手动附值
```typescript
enum Color{Red=1,Green,Blue}
let c:Color = Color.Red
```
或者，全部手动赋值
```typescript
enum Color {Red = 1, Green = 2, Blue = 4}
let c: Color = Color.Green;
```
枚举类型提供的一个便利在于，可以由枚举的值得到它的名字，
```typescript
enum Color {Red = 1, Green, Blue}
let colorName: string = Color[2];

console.log(colorName);  // 显示'Green'因为上面代码里它的值是2
```
## Unknown
在写应用的时候可能会遇到描述一个不知道其类型的变量。这些值来自于动态内容。
```typescript
let notSure: unknown = 4;
notSure = "maybe a string instead";

// OK, definitely a boolean
notSure = false;
```
如果有一个`unkonwn`类型的变量，可以直接通过`typeof`，比较或者更加高级的类型检查来将其类型范围进行缩小
```typescript
declare const maybe: unknown;
// 'maybe' could be a string, object, boolean, undefined, or other types
const aNumber: number = maybe;

if (maybe === true) {
  // TypeScript knows that maybe is a boolean now
  const aBoolean: boolean = maybe;
  // So, it cannot be a string
  const aString: string = maybe;
}

if (typeof maybe === "string") {
  // TypeScript knows that maybe is a string
  const aString: string = maybe;
  // So, it cannot be a boolean
  const aBoolean: boolean = maybe;
}
```
## Any
有时候，可能想要为拿下在编程阶段还不清楚类型的变量指定一个类型。
这些值可能来自于动态的内容，比如用户输入和第三方代码库，这时不希望类型检查器对这些值进行检查而是直接让它们通过编译阶段的检查，那么可以使用any类型来进行标记这些变量.
```typescript
let notSure: any = 4;
notSure = "maybe a string instead";
notSure = false; // okay, definitely a boolean
```
对现有代码进行改写时，`any`类型十分有用，允许开发者在编译时可以选择地包含或移除类型检查。看起来这和`Obejct`有相似的作用，但是区别在于`Object`类型的变量只是允许你给它赋任意值，但是却不能够在上面调用任意的方法，即便它真的有这些方法：
```typescript
let notSure: any = 4;
notSure.ifItExists(); // okay, ifItExists might exist at runtime
notSure.toFixed(); // okay, toFixed exists (but the compiler doesn't check)

let prettySure: Object = 4;
prettySure.toFixed(); // Error: Property 'toFixed' doesn't exist on type 'Object'.
```
## Void
void类型表示没有任何类型。当一个函数没有返回值的时候，可以使用它
```typescript
function warnUser(): void {
    console.log("This is my warning message");
}
```
声明一个void类型的变量基本上没什么用，因为只能赋予它`null`和`undefined`
```typescript
let unusable:void = undefined
```
## Null和Undefined
`undefined`和`null`两者各自有自己的类型，分别为`undefined`和`null`
```typescript
// Not much else we can assign to these variables!
let u: undefined = undefined;
let n: null = null;
```

默认情况下，`null`和`undefined`是所有类型的子类型。也就是说，可以把`null`和`undefined`赋值给`number`类型的变量。
## Never
`never`类型表示的是那些永不存在的值的类型。`never`类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型。变量可能是`never`类型，当它们被永不为真的类型保护所约束时。
`never`类型是任何类型的子类型，也可以赋值给任何类型，但没有任何类型可以赋值给`never`类型（除了`never`本身），就算是any也不行。
```typescript
// 返回never的函数必须存在无法达到的终点
function error(message: string): never {
    throw new Error(message);
}

// 推断的返回值类型为never
function fail() {
    return error("Something failed");
}

// 返回never的函数必须存在无法达到的终点
function infiniteLoop(): never {
    while (true) {
    }
}
```
## Object
这个和js的`Object`也并没什么大不同
```typescript
declare function create(o: object | null): void;

create({ prop: 0 }); // OK
create(null); // OK

create(42); // Error
create("string"); // Error
create(false); // Error
create(undefined); // Error
```
## 类型断言
有时候你比TypeScript还要懂每个值的信息。这个时候就可以使用类型断言。
```typescript
// 使用“尖括号”语法
let someValue: any = "this is a string";
let strLength: number = (<string>someValue).length;
// 使用“as”语法
let someValue: any = "this is a string";
let strLength: number = (someValue as string).length;
```
当在TypeScript里使用JSX时，只有as语法的断言是被允许的
