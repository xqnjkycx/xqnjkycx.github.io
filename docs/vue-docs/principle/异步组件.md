# 异步组件
从根本上来解释，异步组件的实现其实不需要任何框架层面的支持，用户其实可以自行去实现，比如：异步渲染App组件到页面所示：
```js
const loader = () => import('App.vue')
loader().then(App => create(App).mount('#app'))
```
通常一个页面会由多个组件构成，每个组件复制渲染页面的一部分。如果想异步渲染部分页面，只需要有能力异步加载某一个组件就可以了：
```html
 <template>
   <CompA />
   <component :is="asyncComp" />
 </template>
 <script>
 import { shallowRef } from 'vue'
 import CompA from 'CompA.vue'

 export default {
   components: { CompA },
   setup() {
     const asyncComp = shallowRef(null)

     // 异步加载 CompB 组件
     import('CompB.vue').then(CompB => asyncComp.value = CompB)

     return {
       asyncComp
     }
   }
}
 </script>
```
虽然开发者可以自行去实现组件的异步加载和渲染，但整体实现还是比较复制的，主要还是设计的不太全面，考虑如下这些因素：
- 如果组件加载失败或加载超时，是否要渲染Error组件？
- 组件在加载时，是否展示占位内容？例如一个渲染组件
- 组件加载的速度可能很快，也有可能很慢，是否要设置一个延迟展示Loading组件的事件？如果组件在200ms内没有加载成功才展示Loading组件，从而可以避免组件加载过快导致的闪烁
- 组件加载失败后，是否要重试？
V3在考虑用户的层面上对异步组件提供了更好的封装支持，与之对应的能力如下：
- 允许用户指定加载出错时要渲染的组件
- 允许用户指定Loading组件，以及展示该组件的延迟时间
- 允许用户设置加载组件的超时时长
- 组件加载失败后，为用户提供重试的能力

## 异步组件的实现原理
### 封装defineAsyncComponent函数
异步组件本质上是通过封装手段来实现友好的用户接口，从而降低用户层面的使用复杂度：
```html
 <template>
   <AsyncComp />
 </template>
 <script>
 export default {
   components: {
     // 使用 defineAsyncComponent 定义一个异步组件，它接收一个加载器作为参数
     AsyncComp: defineAsyncComponent(() => import('CompA'))
   }
 }
 </script>
```
这样，在模板中就可以使用普通组件一样去使用异步组件了，`defineAsyncComponent` 是一个高阶组件，它的最基本实现如下:

```js
// defineAsyncComponent 函数用于定义一个异步组件，接收一个异步组件加载器作为参数
function defineAsyncComponent(loader) {
  // 一个变量，用来存储异步加载的组件
  let InnerComp = null
  // 返回一个包装组件
  return {
    name: 'AsyncComponentWrapper',
    setup() {
      // 异步组件是否加载成功
      const loaded = ref(false)
      // 执行加载器函数，返回一个 Promise 实例
      // 加载成功后，将加载成功的组件赋值给 InnerComp，并将 loaded 标记为 true，代表加载成功
      loader().then(c => {
        InnerComp = c
        loaded.value = true
      })

      return () => {
        // 如果异步组件加载成功，则渲染该组件，否则渲染一个占位内容
        return loaded.value ? { type: InnerComp } : { type: Text, children: '' }
      }
    }
  }
}
```
注意这个关键点：
- `defineAsyncComponent` 函数本质上是一个高阶组件，它返回的是一个包装组件
- 包装组件会根据加载器的状态来决定渲染什么内容。如果加载成功了就返回组件，如果加载失败了就返回一个占位内容

## 超时和Error组件
异步组件通常以网络请求的形式进行加载。前端发送一个HTTP请求，请求下载组件的JavaScript资源，或者从服务端直接获取组件数据。既然存在网络请求，那么就必然会考虑网络较慢的情况下，尤其是在弱网环境下，加载一个组件可能需要较长的时间。因此，V3也提供用户指定超时时长的能力，当加载组件的时间超过指定时间时，就会触发超时错误。

当然如果用户配置了Error组件，就会渲染这个Error组件

```js
 const AsyncComp = defineAsyncComponent({
   loader: () => import('CompA.vue'),
   timeout: 2000, // 超时时长，其单位为 ms
   errorComponent: MyErrorComp // 指定出错时要渲染的组件
 })
```
那么可以如此设计：
```js
 function defineAsyncComponent(options) {
   // options 可以是配置项，也可以是加载器
   if (typeof options === 'function') {
     // 如果 options 是加载器，则将其格式化为配置项形式
     options = {
       loader: options
     }
   }

   const { loader } = options

   let InnerComp = null

   return {
     name: 'AsyncComponentWrapper',
     setup() {
       const loaded = ref(false)
       // 代表是否超时，默认为 false，即没有超时
       const timeout = ref(false)

       loader().then(c => {
         InnerComp = c
         loaded.value = true
       })

       let timer = null
       if (options.timeout) {
         // 如果指定了超时时长，则开启一个定时器计时
         timer = setTimeout(() => {
           // 超时后将 timeout 设置为 true
           timeout.value = true
         }, options.timeout)
       }
       // 包装组件被卸载时清除定时器
       onUmounted(() => clearTimeout(timer))

       // 占位内容
       const placeholder = { type: Text, children: '' }

       return () => {
         if (loaded.value) {
           // 如果组件异步加载成功，则渲染被加载的组件
           return { type: InnerComp }
         } else if (timeout.value) {
           // 如果加载超时，并且用户指定了 Error 组件，则渲染该组件
           return options.errorComponent ? { type: options.errorComponent } : placeholder
         }
         return placeholder
       }
     }
   }
 }
```
整体实现下并不复杂，主要的关键点在于：
- 需要一个标志变量来判断异步组件是否加载已经超时，即`timeout.value`
- 开始加载组件的同时，开启一个是定时器进行计时。当加载超时后，将`timeout.value`的值设置为true，代表加载已经超时了。当然当组件卸载的时候也要清除定时器
-包装组件根据`loaded`变量的值以及`timeout`变量的值来决定具体的渲染内容。如果异步组件加载成功，则渲染被加载的组件；如果异步组件加载超时，并且用户指定了Error组件，就渲染Error组件

## 延迟与Loading组件
异步加载的组件受网络影响较大，加载过程可能很慢，因此会加载Loaing组件来做优化。

但是大多数情况下网络状况非常之好，异步组件的加载速度会非常快，这也导致了Loading组件刚完成了渲染就立即进入到卸载阶段，于是会出现闪烁的情况。

对于用户来说这是不好的体验，因此需要为Loading组件设置一个延迟展示的时间，例如，当超过200ms没有完成，才会去加载Loading组件。

对于开发者来说，希望接口是这样的设计：
```js
 defineAsyncComponent({
   loader: () => new Promise(r => { /* ... */ }),
   // 延迟 200ms 展示 Loading 组件
   delay: 200,
   // Loading 组件
   loadingComponent: {
     setup() {
       return () => {
         return { type: 'h2', children: 'Loading...' }
       }
     }
   }
 })
```
基本设计如下：
```js
 function defineAsyncComponent(options) {
   if (typeof options === 'function') {
     options = {
       loader: options
     }
   }

   const { loader } = options

   let InnerComp = null

   return {
     name: 'AsyncComponentWrapper',
     setup() {
       const loaded = ref(false)
       const error = shallowRef(null)
       // 一个标志，代表是否正在加载，默认为 false
       const loading = ref(false)

       let loadingTimer = null
       // 如果配置项中存在 delay，则开启一个定时器计时，当延迟到时后将 loading.value 设置为 true
       if (options.delay) {
         loadingTimer = setTimeout(() => {
           loading.value = true
         }, options.delay);
       } else {
         // 如果配置项中没有 delay，则直接标记为加载中
         loading.value = true
       }
       loader()
         .then(c => {
           InnerComp = c
           loaded.value = true
         })
         .catch((err) => error.value = err)
         .finally(() => {
           loading.value = false
          // 加载完毕后，无论成功与否都要清除延迟定时器
           clearTimeout(loadingTimer)
         })

       let timer = null
       if (options.timeout) {
         timer = setTimeout(() => {
           const err = new Error(`Async component timed out after ${options.timeout}ms.`)
           error.value = err
         }, options.timeout)
       }

       const placeholder = { type: Text, children: '' }

       return () => {
         if (loaded.value) {
           return { type: InnerComp }
         } else if (error.value && options.errorComponent) {
           return { type: options.errorComponent, props: { error: error.value } }
         } else if (loading.value && options.loadingComponent) {
           // 如果异步组件正在加载，并且用户指定了 Loading 组件，则渲染 Loading 组件
           return { type: options.loadingComponent }
         } else {
           return placeholder
         }
       }
     }
   }
 }
```
可以看出整体的实现思路也非常类似于超时与Error组件：
- 需要一个标记变量loading来表示组件是否正在加载
- 如果用户制定了延迟时间，则开启延迟定时器。定时器到时之后 ，再将 loading.value 的值设置为true
- 无论组件加载成功与否，都需要清除延迟定时器，否则会出现组件已经加载成功了，但仍然展示Loading组件的问题

## 重试机制
重试机制指的是，当加载出错时，又能力发起加载组件的请求，基本上是对onLoad函数进行一个改造：
```js
 // load 函数接收一个 onError 回调函数
 function load(onError) {
   // 请求接口，得到 Promise 实例
   const p = fetch()
   // 捕获错误
   return p.catch(err => {
     // 当错误发生时，返回一个新的 Promise 实例，并调用 onError 回调，
     // 同时将 retry 函数作为 onError 回调的参数
     return new Promise((resolve, reject) => {
       // retry 函数，用来执行重试的函数，执行该函数会重新调用 load 函数并发送请求
       const retry = () => resolve(load(onError))
       const fail = () => reject(err)
       onError(retry, fail)
     })
   })
 }
```