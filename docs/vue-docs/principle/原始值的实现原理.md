# 原始值的响应原理
由于Proxy的代理目标必须是非原始值，所以无法提供对原始值的代理：
```js
let str = 'vue'
// 无法拦截对值的修改
str = 'vue3'
```
对于这个问题，比较好的解决方案就是使用一个非原始值去“包裹”原始值，例如可以使用一个对象包裹原始值：
```js
const wrapper = {
    value:'vue'
}

// 可以使用 Proxy 代理 wrapper，间接实现对原始值的拦截
const name = reactive(wrapper)
name.value // vue
// 修改值可以触发响应
name.value = 'vue3'
```
## ref
在Vue中，其实帮助用户已经封装了一个函数，将包裹对象的创建工作都封装到函数中了：
```js
function ref(val){
  const wrapper = {
    value:val
  }
  return reactive(wrapper)
}
```
这样设计ref之后，怎么区分是原始值的包裹对象还是一个非原始值的响应式数据，如
```js
const refVal1 = ref(1) // 响应式原始值
const refVal2 = reactive({ value:1 }) // 非原始值 响应式
```
这是比较简单的，可以通过`Object.defineProperty`为包裹对象`wrapper`定义一个不可枚举且不可写的标志属性`__v_isRef`
```js
function ref(val){
  const wrapper = {
    value : val
  }
  Object.defineProperty(wrapper,'__v_isRef',{
    value:true
  })
  return reactive(wrapper)
}
```
## 解决响应丢失问题
如果通过展开运算符...把数据暴露到模版中去使用
```js
const obj = reactive( { foo:1 , bar:2 } )
return {
  ...obj
}
```
如果直接在模版中去使用，实际上会导致响应丢失。这是因为展开运算符运算得到的是一个新的普通对象`newObj`

用代码来描述这个丢失问题如下：
```js
// obj 是响应式数据
const obj = reactive({foo:1,bar:2})

// 将响应式数据展开到一个新的对象 newObj
const newObj = {
    ...obj
}

effectRegister(()=>{
    // 在副作用函数内通过新的对象 newObj 读取 foo属性
    console.log(newObj.foo)
})

// 由于newObj是一个普通对象，所以修改它并不会触发响应...
obj.foo = 100
```
但是显而易见的是，一个普通对象也可以在内部实现`getter`和`setter`，所以可以抽象出来两个函数，其分别是`toRef`和`toRefs`
```js
function toRef(obj, key){
  const wrapper = {
    get value(){
      return obj[key]
    }
    set value(val){
      obj[key] = val
    }
  }
  Object.defineProperty(wrapper,'__v_isRef',{
    value:true
  })
  return wrapper
}

// 这样newObj也变成响应式了，前提是obj本身是响应式数据
const newObj = {
  foo : toRef(obj,'foo'),
  bar : toRef(obj,'bar')
}
```
```js
function toRefs(obj){
  const ret = []
  for(const key in obj){
    ret[key] = toRef(obj,key)
  }
  return ret
}

// 一步到位
const newObj = {...toRefs(obj)}
```
解决这个问题的思路就是：将响应式数据转换成类似于`ref`结构的数据

## 自动脱ref
`toRefs`函数的确解决了响应丢失的问题，但是由于`toRefs`会把响应式数据的第一层属性值转换为ref，因此不得不在模版中通过`.value`去访问值
```html
<p> {{foo.value}} / {{foo.bar}} </p>
```
这对用户来说是非常不友好的，所以需要一个自动脱`ref`的能力，也就是属性的访问行为，如果读取到的属性是一个`ref`，就直接将该`ref`对应的value属性值返回。

其大致的实现逻辑如下：
```js
return new Proxy(target,{
	get(target, key, reciever){
    const value = Reflect.get(target, key, receiver)
    return value.__v_isRef ? value.value : value
  }
})
```
