# 加载顺序优化
:::tip
CSS和JS，都具有**阻塞渲染**的特性
:::
## CSS的阻塞
默认情况下，CSS是阻塞的资源。浏览器在构建CSSOM的过程中，**不会渲染任何已处理的内容**。即便DOM已经解析完成了，只要CSSOM没有完成，那么渲染整个事情就是不OK的
:::tip
这样避免了没有CSS的HTML页面丑陋无比地出现在用户的眼前
:::
只有当开始解析 HTML 后，解析到link标签或者style标签时，CSS才登场，CSSOM的构建才正式开始，很多时候DOM不得不等待CSSOM，因此其实可以这么认为：

**CSS是阻塞渲染的资源。需要它尽早，也尽快地下载到客户端，以便缩短首次渲染的时间。**

而且很多团队都已经做到了尽早（将CSS放在head标签里面）和尽快（启用CDN实现静态资源加载速度的优化）。这个把“CSS往前放”的动作，基本上也是业内标准了。

## JS的阻塞
**JS引擎是独立于渲染引擎存在的**。当HTML解析器遇到一个 *script* 标签时，它会暂停渲染过程，将控制权交给JS引擎。

JS引擎对内联的JS代码会直接执行，对外部JS文件还要先获取到脚本，再进行执行。等JS引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续CSSOM和DOM的构建。因此与其说JS把CSS和HTML阻塞了，不如说是JS引擎抢走了渲染引擎的控制权。

浏览器之所以让JS阻塞其它活动，是因为不知道JS会做什么改变，担心如果不阻止后续的操作，会造成混乱。

所以一般行业内，可以看到一般把 *script* 标签放在HTML的 *body* 最末尾。

## 资源提示符优化
像async defer这样的关键字就被称为资源提示符。
```html
<script async />
<script defer />
```
在不加资源提示符的前提下，先会解析dom元素，然后网络加载 *script* 脚本，然后执行脚本，接着继续解析dom元素，like this:
```html
<p></p>
<p></p>
<script></script>
<p></p>
<p></p>
```
在上面的代码片段中，当浏览器在主线程解析dom元素后，会切到网络线程里面去`fetch` js脚本，然后又回到主线程去执行脚本，然后继续解析dom元素。

![image](./assets/%E5%90%8C%E6%AD%A5%E8%A7%A3%E6%9E%90.png)

这样导致在请求网络脚本时出现了一个空窗期，并且可以发现卡住了dom解析流程。

所以一般写代码时，建议去将*script*标签放在最后:
```html
<p></p>
<p></p>
<p></p>
<p></p>
<script></script>
```
![image](./assets/script%E6%94%BE%E5%9C%A8%E6%9C%80%E5%90%8E%E7%9A%84%E5%90%8C%E6%AD%A5%E8%A7%A3%E6%9E%90.png)

虽然这样并不会卡住浏览器的元素解析，但是依然出现了空窗期。

所以需要使用*async*和*defer*来优化这个过程

当使用*async*时，从远程加载js脚本并不会暂停执行dom元素渲染，而是异步加载脚本完成之后直接介入到主线程中去实现解析：
![image](./assets/async%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png)

而实现*defer*时，不仅不会暂停dom元素解析，并且还会等待主线程把dom元素解析完毕之后，才会执行请求好的js脚本。
![image](./assets/defer%E8%A7%A3%E6%9E%90%E6%B5%81%E7%A8%8B.png)

---
除了JS之外，还有`preload`和`prefetch`这两个提示符，它们可以放在任何的资源上，比如CSS文件，JS文件，图片资源等等。

它们的共同点在于只拿取资源但不解析执行资源，而且不会阻碍dom元素解析。可以用作缓存资源，省去了拿去资源的耗时，`preload`的优先级更高，它代表马上就要用到了，回立刻去请求资源。`prefetch`优先级较低，将会在浏览器空闲的时间去拿去资源。