# 服务端渲染
## 客户端渲染
提到服务端渲染不得不提一下客户端渲染，在客户端渲染模式之下，服务端会把渲染需要的静态文件发送给客户端，客户端加载过来之后，在浏览器中跑一遍JS，根据JS的运行结果去生成DOM。这种特性使得客户端渲染的源代码特别简洁，往往如下：
![image](./assets/%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B8%B2%E6%9F%93html.png)

至于根节点下到底是什么内容，无人知晓，只有浏览器把index.js跑过一遍之后才知道，这就是典型的客户端渲染。

**页面呈现出来的内容，在html源文件找不到**

## 服务端渲染
服务端渲染的模式下，当用户第一次请求页面时，由服务器把需要的组件或页面渲染成HTML字符串，然后把它返回给客户端。客户端拿到手里，是可以直接渲染呈现给用户的HTML内容，不需要为了生成DOM内容再去跑一遍JS代码。

使用服务端渲染的网站，就是可见即所得，**页面上呈现的内容，在html源文件里也可以找到**
![image](./assets/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93html.png)

阿丘科技的官网就是服务端渲染的典型例子。

## 服务端渲染解决了什么问题？
事实上，很多网站是出于效益的考虑才启用服务端渲染，性能倒是在其次。

假设 A 网站页面中有一个关键字叫“前端性能优化”，这个关键字是 JS 代码跑过一遍后添加到 HTML 页面中的。那么客户端渲染模式下，我们在搜索引擎搜索这个关键字，是找不到 A 网站的——搜索引擎只会查找现成的内容，不会帮你跑 JS 代码。A 网站的运营方见此情形，感到很头大：搜索引擎搜不出来，用户找不到我们，谁还会用我的网站呢？为了把“现成的内容”拿给搜索引擎看，A 网站不得不启用服务端渲染。

但性能在其次，不代表性能不重要。服务端渲染解决了一个非常关键的性能问题——**首屏加载速度过慢**。在客户端渲染模式下，我们除了加载 HTML，还要等渲染所需的这部分 JS 加载完，之后还得把这部分 JS 在浏览器上再跑一遍。这一切都是发生在用户点击了我们的链接之后的事情，在这个过程结束之前，用户始终见不到我们网页的庐山真面目，也就是说用户一直在等！相比之下，服务端渲染模式下，服务器给到客户端的已经是一个直接可以拿来呈现给用户的网页，中间环节早在服务端就帮我们做掉了，用户岂不“美滋滋”？

总结下来，主要还是以下三点的优势：
- **更快的首屏加载**：这一点在慢网速或者运行缓慢的设备上尤为重要。服务端渲染的 HTML 无需等到所有的 JavaScript 都下载并执行完成之后才显示，所以你的用户将会更快地看到完整渲染的页面。除此之外，数据获取过程在首次访问时在服务端完成，相比于从客户端获取，可能有更快的数据库连接。这通常可以带来更高的核心 [web指标评分](https://web.dev/articles/vitals?hl=zh-cn)、更好的用户体验，而对于那些“首屏加载速度与转化率直接相关”的应用来说，这点可能至关重要
- **统一的心智模型**:你可以使用相同的语言以及相同的声明式、面向组件的心智模型来开发整个应用，而不需要在后端模板系统和前端框架之间来回切换
- **更好的 SEO**：搜索引擎爬虫可以直接看到完全渲染的页面。

## 服务端渲染的缺点
- **开发中存在一些限制**:一些代码只能在某一环境中执行（服务端或浏览器端），导致在编写代码时额外注意代码的执行环境，需要添加额外的判断条件`import.meta.env.SSR`来区分环境。
- **更多的开发配置和部署要求**：表现在整体的配置流程比较麻烦，需要大量参考文档来套模版一步一步走下来，相比于单纯的SPA应用来说显得困难一些。而且需要一个能运行Node环境的服务器，而不是简单的静态文件服务器
- **更高的服务端负载**：在 Node.js 中渲染一个完整的应用一般要比只托管静态文件更加占用 CPU 资源，因此如果流量较高，还需要考虑服务器的负载，采用合理的缓存策略。

## Vue 的服务端渲染
基本使用可以参考Vue官网的[服务端渲染SSR](https://cn.vuejs.org/guide/scaling-up/ssr.html)

```js
const Vue = require('vue')
// 创建一个express应用
const server = require('express')()
// 提取出renderer实例
const renderer = require('vue-server-renderer').createRenderer()

server.get('*', (req, res) => {
  // 编写Vue实例（虚拟DOM节点）
  const app = new Vue({
    data: {
      url: req.url
    },
    // 编写模板HTML的内容
    template: `<div>访问的 URL 是： {{ url }}</div>`
  })

  // renderToString 是把Vue实例转化为真实DOM的关键方法
  renderer.renderToString(app, (err, html) => {
    if (err) {
      res.status(500).end('Internal Server Error')
      return
    }
    // 把渲染出来的真实DOM字符串插入HTML模板中
    res.end(`
      <!DOCTYPE html>
      <html lang="en">
        <head><title>Hello</title></head>
        <body>${html}</body>
      </html>
    `)
  })
})

server.listen(8080)
```
主要是以下两点：一是这个 `renderToString()` 方法；二是把**转化结果“塞”进模板**里的这一步。这两个操作是服务端渲染的灵魂操作。在虚拟 DOM“横行”的当下，服务端渲染不再是早年 JSP 里简单粗暴的字符串拼接过程，它还要求这一端要具备将虚拟 DOM 转化为真实 DOM 的能力。与其说是“把 JS 在服务器上先跑一遍”，不如说是“把 Vue、React 等框架代码先在 Node 上跑一遍”。

## 服务端的应用场景
在实践中，建议先忘记服务端渲染这个事情——**服务器稀少而宝贵**(毕竟浏览器的事情分给服务器去做了)，但首屏渲染体验和 SEO 的优化方案却很多——我们最好先把能用的低成本“大招”都用完。除非网页对性能要求太高了，对首屏渲染要求也很高，以至于所有的招式都用完了，性能表现还是不尽人意，再去考虑服务端渲染。

### 引申了解
1.**SEO含义，一般会从哪些方面进行SEO优化？**
- Search Engine Optimization, 搜索引擎优化。利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。
- 搜索引擎从网页数据库获取网页然后进行代码过滤，然后提取正文信息后进行切词，所以一方面网页内容必须包含正文内容。可以从正文内容，Title标记，外链推广，URL结构， Meta描述标记等方面优化网站，提升网站排名。
2.**服务端渲染和客户端渲染区别？**
- 二者本质的区别：是谁来完成了html的完整拼接,服务端渲染是在服务端生成DOM树,客户端渲染是在客户端生成DOM树
- 服务端渲染过程，用户输入一个url，浏览器向服务器发送url，请求网页文件。服务端接收到请求后，开始操作网页模版引擎，渲染dom。将网页需要的数据，放到文件中，然后在发送给浏览器。浏览器拿到一个渲染好了的网页文件，直接呈现在客户面前。
- 客户端渲染过程：页面渲染的工作是由浏览器端完成的。浏览器发送请求后，服务端返回js文件，客户端对js文件进行解析，渲染dom。

3.**服务端渲染和客户端渲染有什么优缺点？**
服务端渲染利于SEO搜索引擎优化。解析模版的操作在后端完成，客户端只解析html，客户端资源占用少。缺点是前后端不分离，不利于开发。如果数据量比较大，服务端渲染时间会比较久，其次是由于数据在服务端请求渲染，数据容易被爬虫爬取。

客户端渲染，前端只专注静态页面的开发，开发方式比较友好。页面的渲染工作都是由浏览器来完成的，服务器只是负责提供数据，不容易被爬虫爬取数据，利于数据安全。

4.**Vue官网对SRR的定义**
Vue.js 是一个用于构建客户端应用程序的框架。默认情况下，Vue 组件在浏览器中生成和操作 DOM 作为输出。但是，也可以在服务器上将相同的组件渲染为 HTML 字符串，直接将它们发送到浏览器，最后将静态标记Hydrate成客户端上的完全交互式应用程序。

服务器渲染的 Vue.js 应用程序也可以被认为是“同构的”或“通用的”，因为您的应用程序的大部分代码都在服务器和客户端上运行。

### SSR渲染示意图
![image](./assets/ssr%E6%B8%B2%E6%9F%93%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
- **Client bundle/Server bundle**：Vite将代码使用俩种打包方式（服务端build，客户端build）生成的包，执行`npm run build`
```json
    "scripts": {
        "dev:local": "vite --open",
        "dev": "node server-dev.js",
        "server": "node server-prod.js",
        "start": "vite --mode production --open",
        "build": "npm run build:client && npm run build:server",
        "build:client": "vite build --ssrManifest --outDir dist/client",
        "build:server": "vite build --ssr src/entry-server.js --outDir dist/server",
        "changelog": "conventional-changelog -p angular -i CHANGELOG.md -s -r 0"
    },
```
- **Bundle render**： 将server bundle 使用vue-server-renderer 的 *renderToString* 函数渲染成Html字符
- **Hydrate**：Vue 转换服务器端渲染标记并使其反应的过程，以便它可以反映来自Vue的动态变化。
- **vue官网**：https://v2.ssr.vuejs.org/zh/#什么是服务器端渲染-ssr

### SSR改造步骤
- **首先进行main.js的改造**。在这里改变导出一个*createApp*函数。提供给客户端和服务端的入口文件
```js
import { createSSRApp } from 'vue';

export const createApp = () => {
  const app = createSSRApp(App);
  ...
  return app;
}
```
- **路由配置**。在在router配置文件中，文件导出一个 createRouter 函数。每次调用createRouter创建一个新的router实例。需要注意的是在客户端使用`createWebHistory`，在服务端使用的是`createMemoryHistory`。
```js
import { createRouter as createAppRouter, createWebHistory, createMemoryHistory } from 'vue-router';

export const createRouter = (type,base='') => {
  const router = createAppRouter({
    history: type === 'client' ? createWebHistory(base) : createMemoryHistory(base),
    routes
  });

  router.beforeEach((to, from, next) => {
    ...
  });

  router.afterEach((to, from, next) => {
    ...
  });
  return router;
};
```
- **创建enter-client.js**客户端入口。在`entry-client.js`中，可以这样挂载(mount)应用程序。
```js
import { createApp } from './main';
import { createRouter } from './router';
import createStore from './store';

const router = createRouter('client');
const pinia = createStore();
const app = createApp();
app.use(router);
router.isReady().then(() => {
  // 强制使用应用程序的激活模式
    app.mount('#app', true);
});

```
在客户端挂载应用程序之前，服务器已经渲染好了HTML.我们显然无需将其丢弃再重新创建所有的 DOM 元素。相反，我们需要"激活"这些静态的 HTML，然后使他们成为动态的（能够响应后续的数据变化）。
:::tip
需要注意的是`mount`函数的第二个参数传入了true，来强制使用激活模式hydration。
:::
踩坑点1，使用SSR+客户端混合时，需要了解的一件事是，浏览器可能会更改一些特殊的HTML结构，例如，在模板中写入：
```html
<table>
  <tr><td>hi</td></tr>
</table>
// 浏览器浏览器会在 <table> 内部自动注入 <tbody>，然而，由于 Vue 生成的虚拟 DOM (virtual DOM) 不包含 <tbody>，所以会导致无法匹配。为能够正确匹配，请确保在模板中写入有效的 HTML。
```

踩坑点2，element-plus的SSR的兼容问题。在服务端渲染el-dialog这类popover组成的组件时，客户端激活后会有html的结构渲染问题。为避免，需要在onMounted阶段加载element的popover类型组件。

- **创建enter-server.js服务端入口**这里主要是使用 SSR API 渲染该应用。在这里提供一个render函数，导出[renderedHtml, state, preloadLinks]：

a. renderedHtml:使用`renderToString`将vue渲染成字符串
b. state.pinia 库导出的数据
c. preloadLinks: 预渲染连接。

服务端开始加载时，引用main.js的createApp创建vue实例，引用router文件的createRouter创建路由，进行路由注册。

读取pinia 存储的数据，转化成字符串state，输出到render函数中。 在enter-client.js中客户端渲染时，客户端应用程序能够拿到这些数据。在开始渲染过程之前，需要先预取和解析好这些数据。而且在挂载 (mount) 到客户端应用程序之前，需要获取到与服务器端应用程序完全相同的数据 - 否则，客户端应用程序会因为使用与服务器端应用程序不同的状态，然后导致混合失败。

还可以在这里处理全局的配置，比如语言配置，页面要加载的设备类型等。这是因为页面在服务端渲染后，客户端还需要对渲染出来的页面再渲染一次，这些配置需要在客户端服务端保持统一，避免造成HTML，CSS的加载冲突。

```js
import { createApp } from './main';
import { renderToString } from '@vue/server-renderer';
import { createRouter } from './router';
import createStore from './store';
import i18n from './language';

export const render = async (ctx, manifest) => {
    const app = createApp();
    let router = app.config.globalProperties.$router;
    // 服务端语言设置
    process.i18n_locale && (i18n.global.locale = process.i18n_locale);

    // 设备类型
    const matchMobiles = ctx.request.headers['user-agent'].match(
        /(phone|iPhone|iPod|ios|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i
    );
    const isMobiles = matchMobiles && matchMobiles.length > 0;
    process.isMobiles = isMobiles;

    // 路由注册
    if (!router) {
        router = createRouter('server');
        app.use(router);
    }
    await router.push(ctx.path);
    await router.isReady();

    // pinia
    const pinia = createStore();
    app.use(pinia);

    pinia.state.value.device = {
        isMobiles
    };
    const state = JSON.stringify(pinia.state.value);

    const renderedHtml = await renderToString(app, {});

    const preloadLinks = renderPreloadLinks(renderCtx.modules, manifest);

    return [renderedHtml, state, preloadLinks];
};
```
- **赠加服务入口文件server.js**，在这里使用koa创建启动文件。服务端接收到请求后，读取服务端打包文件，替换模版文件内容。创建vite服务, 注册 vite 的 Connect 实例作为koa服务的中间件 。
```js
(async () => {
    const app = new Koa();

    // 创建 vite 服务
    const viteServer = await vite.createServer({
        root: process.cwd(),
        logLevel: 'error',
        server: {
            middlewareMode: true
        }
    });

    // 注册 vite 的 Connect 实例作为中间件
    app.use(koaConnect(viteServer.middlewares));

    app.use(async ctx => {
        try {
            // 读取文件
            const clientRoot = resolve('dist/client');
            const template = fs.readFileSync(resolve('dist/client/index.html'), 'utf-8');
            const render = require('./dist/server/entry-server.js').render;
            const manifest = require('./dist/client/ssr-manifest.json');

            // 请求的是静态资源
            if (ctx.path.startsWith('/assets')) {
                await sendFile(ctx, ctx.path, { root: clientRoot });
                return;
            }

            const [renderedHtml, state, preloadLinks] = await render(ctx, manifest);
            const html = template
                .replace('<!--app-html-->', renderedHtml)
                .replace('<!--pinia-state-->', state)
                .replace('<!--preload-links-->', preloadLinks);
            ctx.type = 'text/html';
            ctx.body = html;
        } catch (e) {
            ctx.throw(500, e.stack);
        }
    });
    app.listen(8080, () => {
        console.log('server is listening in 8080');
    });
})();
```