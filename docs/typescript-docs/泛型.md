# 泛型
泛型可以比喻为一个类型占位符，它告诉编译器：这里有一个类型参数，但是不确定具体是什么类型，但稍后会告诉编译器。

## 泛型的作用
假设现在需要创建一个`identity`函数，这个函数可以返回任何传入它的值。

不使用泛型的情况，这个函数会是这个样子：
```ts
function identity(arg:number):number{
  return arg
}
```
这样写的缺点在于，它限制了传入的参数必须是个`number`类型，那么可能就会变成这样
```ts
function identity(arg:any):any{
  return arg
}
```
但是这样的做法也有问题，它导致了类型检查不严格，传入的是`number`类型，但如果传出的是`string`类型，这就检查不到错误。

问题在于：**传入任何类型的值，就必须返回对应的任何类型的值？**

OK，那就必须去使用泛型。
```ts
function identity<T>(arg:T):T{
  return arg;
}
```
类型变量T可以帮助我们去捕获用户传入的类型，之后就可以正常去使用这个类型了。

定义好泛型函数之后，就可以以以下两种方式去进行使用：
- 传入所有的参数，明确类型参数
```js
let output = identity<string>("myString");  // type of output will be 'string'
```
- 利用类型推论，根据传入的参数自动确定类型
```js
let output = identity("myString");  // type of output will be 'string'
```

## 使用泛型变量
使用泛形创建像`identity`这样的泛型函数时，编译器需要要求在函数体必须正确的使用这个通用的类型。比如
```ts
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
```
明显`arg`不一定拥有length属性，所以强烈推荐泛型变量T可以当做类型的一部分使用，而不是整个类型，从而去增加灵活性。

比如类型数组
```ts
function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
```
明显`arg`不一定拥有length属性，所以强烈推荐泛型变量T可以当做类型的一部分使用，而不是整个类型，从而去增加灵活性。

比如类型数组
```ts
function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}
```
:::tip
泛型使用尖括号<T>来表示，并在定义函数，类或接口时去指定类型参数
:::

比如:
```ts
// 示例1: 创建一个泛型函数
function identity<T>(arg:T):T{
  return arg
}

// 示例2: 使用泛型函数
let output = identity<string>("Hello")

// 示例3: 使用类型推断，自动推断泛型类型
let output2 = identity("Hello")
```

## 使用泛型
泛型函数的类型 与 非泛型函数的类型 没有什么不同，只是有一个类型参数在最前面，像函数声明一样：
```ts
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: <T>(arg: T) => T = identity;
```
![image](./assets/%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%9E%8B.png)

当然也可以使用不同的泛型参数名，只要在数量和使用方式上能对应得上即可：
```ts
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: <U>(arg: U) => U = identity;
```
还可以使用带有调用签名的对象字面量来定义泛型函数：
```ts
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: {<T>(arg: T): T} = identity;
```
也可以做成泛型接口
```ts
interface GenericIdentityFn {
    <T>(arg: T): T;
}

function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: GenericIdentityFn = identity;
```
但是无法创建泛型枚举和泛型命名空间。

## 泛型类
泛型类看上去和泛型接口差不多
```ts
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```
类被分为两个部分：静态部分和实例部分。泛型类指的是实例部分的类型，所以类的静态属性不能使用泛型类型。

## 泛型约束
有时候，要求想要访问变量的 **length** 属性，同时又要求这个变量的类型不受限制，比如这样:
```ts
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}
```
上面的例子就不能保证传入的任何类型的值都具有 **length** 属性。

相比于操作any所有类型，其实想要的是去处理任意带有`.length`属性的任意类型的值。只要传入的类型有这个属性，就被允许。

那么就可以通过泛型约束去创建条件，使用**接口**和`extends`关键字去实现。
```ts
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  
  	// Now we know it has a .length property, so no more error
    return arg;
}
```
甚至，你可以声明一个类型参数，而且它被另一个类型参数所约束。比如，想通过属性名从对象里获取这个属性，并且确保这个属性存在对象obj上，就需要两个类型之间约束。
```ts
function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

let x = { a: 1, b: 2, c: 3, d: 4 };

getProperty(x, "a"); 
// okay
getProperty(x, "m"); 
// error: Argument of type 'm' isn't assignable to 'a' | 'b' | 'c' | 'd'.
```