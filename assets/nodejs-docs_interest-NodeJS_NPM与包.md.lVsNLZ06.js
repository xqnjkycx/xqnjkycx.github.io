import{_ as s,c as i,o as a,U as n}from"./chunks/framework.PFQuerqu.js";const e="/assets/npm包的寻址规则.B_eyQZpX.png",p="/assets/幽灵依赖.xoaVeajR.png",t="/assets/npm包寻址图.CzNWNvKL.png",l="/assets/pnpm关系图.lxQnNm9R.png",F=JSON.parse('{"title":"NPM 与 包","description":"","frontmatter":{},"headers":[],"relativePath":"nodejs-docs/interest-NodeJS/NPM与包.md","filePath":"nodejs-docs/interest-NodeJS/NPM与包.md","lastUpdated":1710163799000}'),h={name:"nodejs-docs/interest-NodeJS/NPM与包.md"},o=n(`<h1 id="npm-与-包" tabindex="-1">NPM 与 包 <a class="header-anchor" href="#npm-与-包" aria-label="Permalink to &quot;NPM 与 包&quot;">​</a></h1><h2 id="commonjs-包规范" tabindex="-1">CommonJS 包规范 <a class="header-anchor" href="#commonjs-包规范" aria-label="Permalink to &quot;CommonJS 包规范&quot;">​</a></h2><p>按照CommonJS包规范的定义，一个包需要包含包描述文件，即<code>package.json</code>，里面需要包含多种手段。npm下的<code>package.json</code>也有很多字段，有些遵循CommonJS规范定义的，而有些则是npm自行定义的。一般来说，npm遵循着Node.js的需求，在一定程度上契合了CommonJS规范。</p><p>除了描述文件外，还定义一些目录得使用规范：</p><ul><li>可执行文件需要在<code>bin</code>目录下</li><li>JavaScript代码需要在<code>lib</code>目录下</li><li>文档需要在<code>doc</code>目录下</li><li>单元测试文件需要在<code>test</code>目录下</li></ul><p>早期的很多npm包都遵循了这种君子规则，但是近期又开始漫散起来了。</p><p>对于现在的NodeJS来说，<code>package.json</code>里的字段用得都不对，比npm用得少。NodeJS只会用到<code>package.json</code>中寻址相关的字段，比如<code>main</code>，各种映射字段，用于判断模块类型的<code>type</code>字段，甚至都不会判断<code>name</code>是否匹配。在CommonJS模式下，就算是没有<code>package.json</code>文件也不会影响，<strong>只要目录符合寻址算法即可</strong>。</p><p>也就是说，不通过npm，而是通过手写代码去创建下面的代码就是完全可以执行的：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ./node_modules/foo/index.js</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  foo: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;hello world&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ./index.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">foo</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;foo&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo);</span></span></code></pre></div><p>如果想使用ECMAScript modules的形式，也可以这样：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ./node_modules/foo/index.mjs</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> foo</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;hello world&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// ./index.mjs 需要明确指明导入的esm文件</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { foo } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;foo/index.mjs&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo);</span></span></code></pre></div><p>简单来说，NodeJS包参考了CommonJS的包，<code>package.json</code>这些内容只用于研发时的管理用（我一般都把它当成说明书来看），并不会被强行依赖，只要目录符合规则。而npm则帮NodeJS管理了这些依赖，生成符合规则的目录，并做一些额外的事情。</p><h2 id="node-js包的模块寻址规则" tabindex="-1">Node.js包的模块寻址规则 <a class="header-anchor" href="#node-js包的模块寻址规则" aria-label="Permalink to &quot;Node.js包的模块寻址规则&quot;">​</a></h2><p>其实所谓的包，对于NodeJS来讲就是一个有很多模块的一个特殊目录，它可以通过不断往上级目录回溯去寻址，也可以通过目录下的元信息描述文件<code>package.json</code>做映射，但无所谓。</p><p>在NodeJS中，如果在<code>require</code>或<code>import</code>模块时，其标识不以相对路径的（<code>.</code>，<code>..</code>）为开始，又不是一个内置模块，则认为其是从某个“包”内进行导入。它会根据标识作为“包名”去当前模块所在路径的<code>node_modules</code>目录下寻找，若找不到就去上级目录的<code>node_modules</code>里面寻找</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>在NodeJS眼里，“包名”就是目录名，而非 package.json 中的 name，它以目录作为事实标准</p></div><p><img src="`+e+`" alt="image"></p><p>假如在这个图中，假设当前所在文件是<code>C@2</code>中的<code>index.js</code>，它对于根的目录规则为<code>./node_modules/A/node_modules/C/index.js</code>，这个时候，它需要去<code>require(&#39;D)</code>，那么它就会折返进行寻址：</p><ul><li>在当前目录下的<code>node_modules</code>找，但是不存在</li><li>返回上级去<code>./nodemodules/A/node_modules</code>里找</li><li>再返回上级，成功找到<code>./node_modules/D</code>存在！ 在寻找到文件之后，需要通过两种方式来判断命中文件：</li><li>从当前目录的<code>package.json</code>中的<code>main</code>字段获取映射，判断文件是否存在。</li><li>如果没有<code>package.json</code>中的<code>main</code>字段，则默认以<code>index</code>加各种后缀尝试。</li></ul><h2 id="幽灵依赖" tabindex="-1">幽灵依赖 <a class="header-anchor" href="#幽灵依赖" aria-label="Permalink to &quot;幽灵依赖&quot;">​</a></h2><p>在上面得规则下，其实很容易触发一个叫做 <strong>幽灵依赖</strong> 的漏洞。</p><p>比如当下<code>packge</code>的代码安装以下的一些依赖：</p><div class="language-json vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">json</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;dependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;axios&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^1.6.5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;browser-md5-file&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^1.1.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;element-plus&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^2.5.1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;less&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^4.2.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^3.3.11&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">},</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;devDependencies&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;@vitejs/plugin-vue&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^4.5.2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  &quot;vite&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;^5.0.10&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>但是又因为这些依赖库可能又依赖了其他库，所以<code>npm i</code>的时候会安装一些没有声明过的第三方库： <img src="`+p+`" alt="image"></p><p>由于NodeJS的寻址规则，那么在代码中就可以去导入一些完全没有声明过的库：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;lodash&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">_.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">chunk</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>这样的做法可能存在一些问题（下面的说法A库是明确声明的库，B库是幽灵库）：</p><ul><li><strong>版本问题</strong>：在代码中使用B库的代码，但是A库突然升级了，升级版A库引入了升级版的B库，导致之前使用的B库代码出问题</li><li><strong>依赖丢失问题</strong>：在开发环境中使用了开发依赖B库，结果一上线A库的代码根本不打包，导致B库丢失了</li></ul><p>下图描述了依赖的产生原因： <img src="`+t+'" alt="image"></p><p>当然可以使用<strong>pnpm</strong>库来解决这个问题： <img src="'+l+'" alt="image"></p><h2 id="npm" tabindex="-1">NPM <a class="header-anchor" href="#npm" aria-label="Permalink to &quot;NPM&quot;">​</a></h2><p>一个npm实际上有多种语义在里面：</p><ul><li><strong>Node.js下的包管理器：</strong> 帮助JavaScript开发者去轻易的分享包</li><li><strong>npm源站：</strong> 互联网公共包代码的合集服务</li><li><strong>npm CLI ：</strong> 用于安装，发布包的客户端</li></ul>',33),k=[o];function d(c,r,E,g,m,y){return a(),i("div",null,k)}const C=s(h,[["render",d]]);export{F as __pageData,C as default};
