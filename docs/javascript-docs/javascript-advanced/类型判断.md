# 类型判断
到ES2023为止，一共定义了7种变量类型:
- undefined
- null
- boolean
- String
- Symbol
- Numeric( Number BigInt)
- Object

其中Object不是基本数据类型，前面的全是基本数据类型

## typeof
typeof 不是一个函数，而是一个操作符，而且不能声明一个 typeof 的变量
```js
var typeof = 3 // Unexpected token 'typeof'
typeof typeof // Unexpected end of input
```
typeof 返回值一定是这8种**字符串**的之一:
- "undefined"
- "string"
- "boolean"
- "number"
- "bigint"
- "symbol"
- "object"
- "function"
首先是null会被typeof返回成object，同时这个原因和底层的机器码的实现有关。

判断null类型，最好直接使用`if(foo === null)`

## undefined
一般来说，推荐使用`"undefined" === typeof foo`来判断是否是undefined

如果直接用全等`undefined === foo`也能实现，但是有意外

undefined还不是关键字，它可以在做为变量名在局部环境中进行声明(非严格模式)

```js
{
  const undefined = 1
  console.log(typeof undefined) //number
}
```
## 典型对象的判断
typeof 基本上能解决 原始类型 变量的判断，一般在业务中，往往要去做几个典型类型的判断需求，比如数组Array和正则RegExp。

先来看数组

早期因为IE环境下跨ifreme调用时，`[] instanceof Array`是不成立的，所以推荐使用的是`Object.prototype.toString.call(arr) === "[object Array]"`，其实也可以使用`arr.constructor === Array`

ES5之后又引入了`Array.isArray`来判断

这里推荐使用 **Array.isArray比instanceof或者constructor能胜任对Proxy的判定工作。**

比如这段代码：
```js
const proxy = new Proxy([],{
  get(target,p){
    if('constructor' === p) return String;
    return Reflect.get(target,p);
  },
  getPrototypeOf(){
    return null
  }
})

console.log(`Array.isArray(proxy)`,Array.isArray(proxy)); //true
console.log(`proxy instanceof Array`, proxy instanceof Array); //false
console.log(`proxy.constructor === Array`, proxy.constructor === Array); //false
```
但是在其他对象类型上，可能就没这种待遇了，比如正则表达式RegExp，除了它有自己独立的字面量语法之外，RegExp，Date，Argument等等.

但是通常也有三种方法来做判断：
- 第一种办法，判断其构造函数，不过对象的constructor属性一般是可以被覆写的，也有被伪造的可能
```js
function isAnimal(foo){
    return foo?.constructor === Animal
}
```
- 第二种办法，用 instanceof 做原型链判别，不过对象的原型链也是可以被篡改的
```js
function isAnimal(foo){
  return foo instanceof Animal
}
```
- 第三种办法，使用对象基类的toString方法
```js
function isAnimal(foo){
	return Object.prototype.toString.call(foo) === "[object Animal]"
}
```
比较难受的是,js的构造函数，甚至class语法本身都是语法糖，原型链基本上可以被修改。

## Primitive 的对象封装
除了 null 和 undefined 之外，其余的 基本数据 类型都可以封装为Object
```
Object(123) // new Number(123)
Object(123n) // new BigInt(123n)
Object("str") // new String("str")
Object(true) // new Boolean(true)
Object(Symbol("sym"))
```
虽然这些值在 typeof 下一定都返回 "object"，但是依然具有原本语义
```js
new Number(3) + new Number(4) // 7
new String("a") + new String("b") // "ab"
```
如果要实现一个`concatString(a,b)`函数，a和b除了应该是string类型之外，也允许字符串对象才行
```js
function isString(str){
  return "string" === typeof str || Object.prototype.toString.call(str) === "[object String]"
}
```