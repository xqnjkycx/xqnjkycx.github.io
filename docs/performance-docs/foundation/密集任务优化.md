# 密集任务的优化
JS最初设计是运行在浏览器中的，为了防止多个线程同时操作DOM，带来渲染冲突的问题，所以浏览器的渲染主线程被设计为了单线程。但随着前端技术的发展，js能力远不止如此，当遇到大量的计算场景时，js线程往往会被长时间阻塞，甚至造成页面卡顿，影响用户的体验。

## 什么是WebWorker
`Web Worker`是 HTML5 标准的一部分，这一规范定义了一套 API，允许我们在 js 主线程之外开辟新的 Worker 线程，并将一段 js 脚本运行其中，它赋予了开发者利用 js 操作多线程的能力。

因为是独立的线程，Worker 线程与 js 主线程能够同时运行，互不阻塞。所以，在我们有大量运算任务时，可以把运算任务交给 Worker 线程去处理，当 Worker 线程计算完成，再把结果返回给 js 主线程。这样，js 主线程只用专注处理业务逻辑，不用耗费过多时间去处理大量复杂计算，从而减少了阻塞时间，也提高了运行效率，页面流畅度和用户体验自然而然也提高了。

## WebWorker的作用
虽然 Worker 线程是在浏览器环境中被唤起，但是它与当前页面窗口运行在不同的全局上下文中，我们常用的顶层对象 `window`，以及 `parent` 对象在 Worker 线程上下文中是不可用的。另外，在 Worker 线程上下文中，操作 DOM 的行为也是不可行的，`document` 对象也不存在。但是，`location` 和 `navigator` 对象可以以可读方式访问。除此之外，绝大多数 Window 对象上的方法和属性，都被共享到 Worker 上下文全局对象 *WorkerGlobalScope* 中。同样，Worker 线程上下文也存在一个顶级对象 self。

## WebWorker 的使用
### 创建Worker
创建`Worker`只需要通过`new`调用`Worker()`构造函数即可，它接收两个参数：
```js
const worker = new Worker(path, options);
```
|   **参数**   |   **说明**   |
|------|------|
|path  | 有效的js脚本的地址，必须遵守同源策略。无效的js地址或者违反同源策略，会抛出`SECURITY_ERR` 类型错误     |
|options.type |  可选，用以指定 worker 类型。该值可以是 classic 或 module。 如未指定，将使用默认值 classic。使用module就可以像ESM一样引入外部文件了    |
|options.credentials |  可选，用于指定Worker凭证    |
|options.name      | 可选，指定Worker的名称，主要是用于调试     |

### 线程之间传递数据
主线程 与 Worker线程 都是通过`postMessage`方法来发送消息，以及监听`message`事件来接收消息。如下：
```js
const myWorker = new Worker('/worker.js'); // 创建worker

myWorker.addEventListener('message', e => { // 接收消息
    console.log(e.data); // Greeting from Worker.js，worker线程发送的消息
});

// 这种写法也可以
// myWorker.onmessage = e => { // 接收消息
//    console.log(e.data);
// };

myWorker.postMessage('Greeting from Main.js'); // 向 worker 线程发送消息，对应 worker 线程中的 e.data
```
```js
// worker.js（worker线程）
self.addEventListener('message', e => { // 接收到消息
    console.log(e.data); // Greeting from Main.js，主线程发送的消息
    self.postMessage('Greeting from Worker.js'); // 向主线程发送消息
});
```
主线程与 worker 线程之间的数据传递是传值而不是传地址。所以你会发现，即使你传递的是一个Object，并且被直接传递回来，接收到的也不是原来的那个值了。
```js
// main.js（主线程）
const myWorker = new Worker('/worker.js');

const obj = {name: '小明'};
myWorker.addEventListener('message', e => { 
    console.log(e.data === obj); // false
});
myWorker.postMessage(obj);

// worker.js
self.addEventListener('message', e => {
    self.postMessage(e.data); // 将接收到的数据直接返回
});
```

### 监听错误信息
web worker 提供两个事件监听错误，`error`和`messageerror`。这两件事的区别在于：
|**事件**|**描述**|
|------|------|
|error|当worker内部出现错误时触发|
|messageerror|当`message`事件接收到无法被反序列化的参数时触发|

```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker

myWorker.addEventListener('error', err => {
    console.log(err.message);
});
myWorker.addEventListener('messageerror', err => {
    console.log(err.message)
});
```
```js
// worker.js（worker线程）
self.addEventListener('error', err => {
    console.log(err.message);
});
self.addEventListener('messageerror', err => {
    console.log(err.message);
});
```

### 关闭线程
worker 线程的关闭在主线程和 worker 线程都能进行操作，但对 worker 线程的影响略有不同。
```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker
myWorker.terminate(); // 关闭worker
```
```js
// worker.js（worker线程）
self.close(); // 直接执行close方法就ok了
```
在主线程手动关闭 worker，主线程与 worker 线程之间的连接都会被立刻停止，即使 worker 线程当前的 Event Loop 中仍有待执行的任务继续调用 `postMessage()` 方法，但主线程不会再接收到消息。

在 worker 线程内部关闭 worker，不会直接断开与主线程的连接，而是等 worker 线程当前的 Event Loop 所有任务执行完，再关闭。也就是说，在当前 Event Loop 中继续调用 `postMessage()` 方法，主线程还是能通过监听`message`事件收到消息的。

### 引用其他文件
在worker线程中利用`importScripts()`方法加载需要的js文件，通过这个方法可以加载的js文件不受同源策略约束。

```js
// utils.js
const add = (a, b) => a + b;

// worker.js（worker线程）
// 使用方法：importScripts(path1, path2, ...); 
importScripts('./utils.js');

console.log(add(1, 2)); // log 3
```
同时可以支持定义`type`来指定worker中的js文件引入模式为ESModule模式。
```js
// main.js（主线程）
const worker = new Worker('/worker.js', {
    type: 'module'  // 指定 worker.js 的类型
});
```
### 可传递的数据
worker中传递的数据并不是全部都能传递的，比如：
```js
// main.js（主线程）
const myWorker = new Worker('/worker.js'); // 创建worker

const fun = () => {};

myWorker.postMessage(fun); 
// Error：Failed to execute 'postMessage' on 'Worker': ()=>{} could not be cloned.
```
`postMessage`传递的数据可以是由结构化克隆算法处理的任何值或JavaScript对象，包括循环引用。
结构化不能克隆的数据有：
- `Error`对象以及`Function`对象
- Dom节点
- 对象的某些特定参数不会被保留（原型链上的属性不会被追踪和复制，属性描述符中的getter和setter）

支持结构化克隆算法支持的数据主要就以下几种：
|**类型**|**说明**|
|------|------|
|所有的原始类型|除了Symbol|
|Boolean||
|String||
|Date||
|RegExp||
|Blob||
|File||
|FileList||
|ArrayBuffer||
|ArrayBufferView|这就基本意味着所有的类型化数组，比如Int32Array被支持|
|ImageData||
|Array||
|Object|当然只包括普通对象|
|Map||
|Set||