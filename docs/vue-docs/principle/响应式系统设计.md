# 响应式系统设计
阅读优秀的框架代码设计，可以学习作者在设计代码上的优秀思路，了解作者在实现自己的思路时考虑到的各种情况，以及各种解决方案...

vue中的响应式系统设计是vue框架的核心之一，接下来这篇分享可以帮助大家仿照vue的实现思路去设计一个简单的响应式系统

## 响应式数据与副作用函数
副作用函数指的是一些会产生副作用的函数，如下代码所示：
```js
function effect(){
  document.body.innerText = 'hello vue3'
}
```
effect函数执行时，它会设置body下的文本内容，如果除了effect函数之外，存在其他函数正在设置或者读取文本内容时，effect函数的执行就直接或间接的影响到了其他函数的执行，也就是产生了副作用，副作用很容易产生。

例如修改一个全局变量就是副作用：
```js
let val = 1

function effect(){
  val = 2
}
```
什么是响应式数据？副作用函数effect会设置body下的文本内容，其值为obj.text，当obj.text的值发生变化时，希望effect会重新执行。

```js
const obj = {text : 'hello world'}
function effect(){
  document.body.innerText = obj.text
}
```
理想情况下，如果修改obj的text字段，副作用函数自动重新执行一次，那么数据源obj就可以被称为是响应式数据。但遗憾的是，现在的数据源obj是明显的“死”数据，不具有响应性。

## 响应式数据的基本实现
实现的基本思路在于：
- 当副作用函数 effect 执行时，会触发字段的obj.text的**读取**操作
- 当修改obj.text的值时，会触发字段obj.text的**设置**操作

为了使得数据具有响应性，就不得不去监听数据的“读”“写”操作，然后执行对应的副作用函数，在Vue2中，采用了`Object.defineProperty`函数来实现，但在最新的Vue3中，可以使用代理对象`Proxy`来实现：

```js
// 存放副作用函数的集合
const bucket = new Set()

// 数据源
const data = {text:'hello vue'}

// 利用proxy将数据进行代理
const dataProxy = new Proxy(data,{
  // 拦截读取操作 target指向数据源 key为数据源上的属性
  get(target, key){
    // 将副作用函数放进集合中
    bucket.add(effect)
    return target[key]
  },
  // 拦截写操作 newVal代表更改的新值
  set(target, key, newVal){
    // 设置属性值
    target[key] = newVal
    // 将副作用函数取出来进行执行
    bucket.forEach(fn => fn())
    // 修改成功之后返回true
    return true
  }
})

// 副作用函数
function effect(){
  document.body.innerText = dataProxy.text
}

// 执行副作用函数
effect()

// 5秒后自动修改
setTimeout(()=>{
  dataProxy.text = "hello reactive"
},5000)
```

## 开始设计响应式系统
在vue的真实实现中，存在一个函数用于专门来注册副作用函数，哪怕副作用函数是一个匿名函数，也可以被正确的收集到集合中

```js
// 全局副作用函数
let activeEffect

// 副作用函数捕获函数
function effectRegister(fn){
  activeEffect = fn
  // 执行后会触发一次读取操作
  fn()
}
```
在上述代码中有一个“亮点”，也就是在注册副作用函数时,副作用函数在赋值给全局变量的同时也被自动执行了一次，这次执行至关重要，因为执行副作用函数也就意味着数据源的读取操作被触发了，一旦触发了读取操作，那么就可以从全局变量activeEffect中取到对应的副作用函数，从而记录到集合中
:::tip
这就是怎么将副作用函数进行收集的！
:::

修改一下Proxy中的逻辑:
```js
const dataProxy = new Proxy(data,{
  get(target, key){
    // 将副作用函数放进集合中
    if(activeEffect) bucket.add(activeEffect)
    return target[key]
  },
  set(target, key, newVal){
    target[key] = newVal
    bucket.forEach(fn => fn())
    return true
  }
})
```
但是这样的设计会存在一个小bug，如果向数据源新增一个不存在的属性，依然会导致副作用函数执行

```js
// 副作用函数
function effect(){
  console.log('effect函数触发')
  document.body.innerText = dataProxy.text
}

// 注册副作用函数
effectRegister(effect)

setTimeout(()=>{
  dataProxy.noExist = 'noExist'
},2000)
```
为什么说增加一个不存在的属性导致副作用函数执行是错误的，因为理论上来说，副作用函数中**涉及**到的字段是obj的text字段，正确的逻辑是text的值改变 触发 副作用函数执行 ，而不是增加一个和副作用函数无关的属性 触发 副作用函数执行。

这个bug存在的根本原因在于手机副作用函数的集合`bucket`只和数据源产生了关系，**忽略了没有在副作用函数与被操作的数据源目标字段之间建立明确的联系**，要正确的触发副作用函数的执行，和如下的三个角色关系很大：
- 被操作的代理对象 obj
- 被操作的字段名 text
- 副作用函数 effectFn

那么这三者的关系可以说有这么几种：

- 多个副作用函数读取同一个对象的字段
```text
obj
 |___text
    	|___ effectFn1
      |___ effectFn2
      |___ ......
```

- 一个副作用函数读取了同一个对象的多个字段
```text
obj
 |___text1
    	|___effectFn1

 |___text2
    	|___effectFn1

 |___ ......
```
- 不同副作用函数读取了不同的对象的字段
```text
obj
 |___text1
    	|___effectFn1

 |___text2
    	|___effectFn2

 |___ ......
```
总体来说，这其实是一个树形结构，显然需要重新设计收集副作用函数的存储集合的数据结构：
```js
// 存放副作用函数的集合
const bucket = new WeakMap()

// 利用proxy将数据进行代理
const dataProxy = new Proxy(data,{
  // 拦截读取操作 target指向数据源 key为数据源上的属性
  get(target, key){
    // 没有activeEffect，就直接return出去
    if(!activeEffect) return target[key]
    // 根据 target 从集合中取出depsMap，这就是依赖dep，它是 key ---> effects
    let depsMap = bucket.get(target)
    // 如果不存在 depsMap ，那么就新建一个Map与target关联
    if(!depsMap) bucket.set(target,(depsMap = new Map()))
    // 获取字段对应的依赖列表
    let deps = depsMap.get(key)
    // 如果不存在依赖列表，那么就新建一个Set与key关联
    if(!deps) depsMap.set(key,(deps = new Set()))
    // 收集依赖
    deps.add(activeEffect)
    return target[key]
  },
  // 拦截写操作 newVal代表更改的新值
  set(target, key, newVal){
    // 设置属性值
    target[key] = newVal
    // 将副作用函数取出来进行执行
    const depsMap = bucket.get(target)
    if(!depsMap) return
    const deps = depsMap.get(key)
    deps && deps.forEach(fn => fn())
    // 修改成功之后返回true
    return true
  }
})
```
这次设计出的数据结构，分别使用了`WeakMap`，`Map`,`Set`

并且可以得到这么一个结构：WeakMap存储的是数据源对象，而对应的值是一个Map结构，而Map结构中存放的是key--->deps的关系，Map的键是数据源对象的key，Map的值是一个装载副作用函数的Set。如图所示：

![image](./assets/weakmap-map-set.png)

这就是一个简单的响应式设计系统，最后对于这一块的代码做一步封装，将在get拦截函数里编写的把副作用函数收集到依赖集合的这部操作封装为一个`track`表示追踪，触发副作用函数重新执行的逻辑封装到`trigger`中，表示触发

最后的代码设计如下👇👇👇

```js
// 数据源
const data = {text:'hello vue'}

// 全局副作用函数
let activeEffect

// 副作用函数捕获函数
function effectRegister(fn){
  activeEffect = fn
  // 执行后会触发一次读取操作
  fn()
}

// 存放副作用函数的集合
const bucket = new WeakMap()

// 利用proxy将数据进行代理
const dataProxy = new Proxy(data,{
  // 拦截读取操作 target指向数据源 key为数据源上的属性
  get(target, key){
    track(target, key)
    return target[key]
  },
  // 拦截写操作 newVal代表更改的新值
  set(target, key, newVal){
    // 设置属性值
    target[key] = newVal
    trigger(target,key)
    // 修改成功之后返回true
    return true
  }
})

// track函数
function track(target, key){
      // 没有activeEffect，就直接return出去
    if(!activeEffect) return 
    // 根据 target 从集合中取出depsMap，这就是依赖dep，它是 key ---> effects
    let depsMap = bucket.get(target)
    // 如果不存在 depsMap ，那么就新建一个Map与target关联
    if(!depsMap) bucket.set(target,(depsMap = new Map()))
    // 获取字段对应的依赖列表
    let deps = depsMap.get(key)
    // 如果不存在依赖列表，那么就新建一个Set与key关联
    if(!deps) depsMap.set(key,(deps = new Set()))
    // 收集依赖
    deps.add(activeEffect)
}

// trigger函数
function trigger(target,key){
      // 将副作用函数取出来进行执行
    const depsMap = bucket.get(target)
    if(!depsMap) return
    const deps = depsMap.get(key)
    deps && deps.forEach(fn => fn())
}

// 副作用函数
function effect(){
  console.log('effect函数触发')
  document.body.innerText = dataProxy.text
}

// 注册副作用函数
effectRegister(effect)

// 5秒后自动修改
setTimeout(()=>{
  dataProxy.text = "hello reactive"
},5000)
```
## 分支切换
```js
const data = { ok : true , text:'hello world'}
const obj = new Proxy( data , {/* ...... */})
effectRegister(() => {
  document.body.innerText = obj.ok ? obj.text : 'not'
})
```
在匿名函数内部存在一个三元表达式，根据字段obj.ok值的不同会执行不同的代码分支。也就是说，obj.ok的值发生变化时，代码执行分支也会跟着变化，这就是所谓的分支切换。

这个分支切换可能会带来一些问题，产生遗留的副作用函数

根据上文的概述，这个匿名的副作用函数理应会被`obj.ok`和`obj.text`字段同时收集，假设现在obj.ok的初时值为true，当其变为false时，很明显这个副作用函数就会被触发，此时如果`obj.text`值发生了100次不同的改变，那么就会重新执行100次副作用函数，但实际上，既然`obj.ok`都为`false`了，何必去执行100次的副作用函数呢？这就是现在的设计所遗留的副作用函数问题。

:::tip
对于这个问题，其实解决起来也比较简单，就是副作用函数执行时，可以把它从所有与之关联的依赖集合中去做删除。**由于副作用函数执行本身就会触发数据源的字段的`get`，那么又会被收集回去，重新建立联系，好处在于新的联系不会包含遗留的副作用函数**
:::

## cleanup
从上文中的tip可以知道，既然要知道副作用函数在哪有依赖集合中被收集，那么对于副作用函数来说，它也应该有一个`deps`属性，用来存储所有包含它的依赖集合

可想而知，当副作用函数被调用时，就可以挂载一个deps
```js
// 副作用函数捕获函数
function effectRegister(fn){
  //effectFn是被包装的副作用函数
  const effectFn = () => {
    activeEffect = effectFn
    // fn才是真正的副作用函数
    fn()
  }
  effectFn.deps = []
  // 执行后会触发一次读取操作
  effectFn()
}
```
然后在track中收集这些deps
```js
function track(target, key){
    if(!activeEffect) return 
    let depsMap = bucket.get(target)
    if(!depsMap) bucket.set(target,(depsMap = new Map()))
    let deps = depsMap.get(key)
    if(!deps) depsMap.set(key,(deps = new Set()))
    deps.add(activeEffect)
    //新增： 依赖收集deps
    activeEffect.deps.push(deps)
}
```
经过这样的`track`之后，就完成了互相的依赖收集，那么关系图变为了下面这样：

![image](./assets/effectFn.png)

由此cleanup函数诞生了！
```js
// 副作用函数捕获函数
function effectRegister(fn){
  const effectFn = () => {
    // 因为副作用函数被trigger时会走到这里来
    cleanup(effectFn)
    activeEffect = effectFn
    fn()
  }
  effectFn.deps = []
  effectFn()
}

function cleanup(effectFn){
  for(let i = 0 ; i < effectFn ; i++){
    let deps = effectFn.deps[i]
    deps.delete(effectFn)
  }
  // 注意这里需要清掉，避免内存泄漏
  effectFn.deps.length = 0
}
```
这样看起来，设计的响应式系统似乎可以避免副作用函数的遗留产生了。但在实际的运行中，会出现无限循环的问题,原因是发生在`trigger`函数中

```js
function trigger(target, key) {
  const depsMap = bucket.get(target);
  if (!depsMap) return;
  const effects = depsMap.get(key);
  effects && effects.forEach((fn) => fn());
  // 原因就在于 effects && effects.forEach(fn => fn())当中
  // 在这里遍历 effects 函数
  //拿出了副作用函数进行执行包装的effectFn，此时会直接执行cleanup
  // 紧接着，又马上调用真正的副作用函数，执行副作用函数又会把当前新的effectFn又加入到Set中
  // 由此，形成了死循环
}

// 类似代码如下
const set = new Set([1])
set.forEach(item => {
  set.delete(1)
  set.add(1)
  console.log('遍历中...')
})
```
思考问题发生的本质在于，存放依赖集合的set 和 运行依赖集合的set 是同一个set，导致存删在同一个set上操作从而引发循环,好的解决方案就是，将trigger中将 **存放依赖集合** 和 **运行依赖集合隔** 离开来，实现代码如下：
```js
function trigger(target,key){
    // 将副作用函数取出来进行执行
    const depsMap = bucket.get(target)
    if(!depsMap) return
    // 存储依赖集合
    const deps = depsMap.get(key)
    // 运行依赖集合
    const effectsToRun = new Set(deps)
    effectsToRun && effectsToRun.forEach(fn => fn())
}
```
**到目前为止，这就实现了一个简易的响应式系统，完整代码如下：**
```js
// 数据源
const data = {text:'hello vue'}

// 全局副作用函数
let activeEffect

// 副作用函数捕获函数
function effectRegister(fn){
  const effectFn = () => {
    cleanup(effectFn)
    activeEffect = effectFn
    fn()
  }
  effectFn.deps = []
  // 执行后会触发一次读取操作
  effectFn()
}

// 存放副作用函数的集合
const bucket = new WeakMap()

// 利用proxy将数据进行代理
const dataProxy = new Proxy(data,{
  // 拦截读取操作 target指向数据源 key为数据源上的属性
  get(target, key){
    track(target, key)
    return target[key]
  },
  // 拦截写操作 newVal代表更改的新值
  set(target, key, newVal){
    // 设置属性值
    target[key] = newVal
    trigger(target,key)
    // 修改成功之后返回true
    return true
  }
})

// track函数
function track(target, key){
      // 没有activeEffect，就直接return出去
    if(!activeEffect) return 
    // 根据 target 从集合中取出depsMap，这就是依赖dep，它是 key ---> effects
    let depsMap = bucket.get(target)
    // 如果不存在 depsMap ，那么就新建一个Map与target关联
    if(!depsMap) bucket.set(target,(depsMap = new Map()))
    // 获取字段对应的依赖列表
    let deps = depsMap.get(key)
    // 如果不存在依赖列表，那么就新建一个Set与key关联
    if(!deps) depsMap.set(key,(deps = new Set()))
    // 收集依赖
    deps.add(activeEffect)
    // 依赖收集deps
    activeEffect.deps.push(deps)
}

// trigger函数
function trigger(target,key){
      // 将副作用函数取出来进行执行
    const depsMap = bucket.get(target)
    if(!depsMap) return
    // 存储依赖集合
    const deps = depsMap.get(key)
    // 运行依赖集合
    const effectsToRun = new Set(deps)
    effectsToRun && effectsToRun.forEach(fn => fn())
}

// cleanup函数
function cleanup(effectFn){
  for(let i = 0 ; i < effectFn ; i++){
    let deps = effectFn.deps[i]
    deps.delete(effectFn)
  }
  effectFn.deps.length = 0
}

// 副作用函数
function effect(){
  console.log('effect函数触发')
  document.body.innerText = dataProxy.text
}

// 注册副作用函数
effectRegister(effect)

// 5秒后自动修改
setTimeout(()=>{
  dataProxy.text = "hello reactive"
},5000)
```

## 嵌套的effectRegister
`effectRegister`应该是被设计成可以嵌套的，而且这是很有必要的，形式如下：
```js
effectRegister(function effectFn1(){
  // ...
  effectRegister(function effectFn2(){
    // ...
  })
})
```
在Vue的内部代码里，组件的渲染函数就是在一个`effectRegister`中执行的，当组件`Foo`内部渲染了`Bar`组件时，就会发生嵌套，代码形式等同于
```js
effectRegister(() => {
  Foo.render()
  effectRegister(() => {
    Bar.render()
  })
})
```
如果不支持嵌套，会导致一些错误发生，假如下面这个例子
```js
// 数据源
const data = {
  foo: "hello world",
  bar: true,
};

// 将匿名函数注册为副作用函数
effectRegister(function effectFn1() {
  console.log("foo 组件触发了");
  effectRegister(function effectFn2() {
    console.log("bar 组件触发了");
    obj.bar;
  });
  obj.foo;
});

setTimeout(() => {
  obj.foo = 123;
  console.log("修改foo的值....");
}, 2000);
```
会发现打印的结果变成了...
```text
foo 组件触发了
bar 组件触发了
bar 组件触发了
修改foo的值....
```
`obj.foo`的值改变没有触发对应的副作用函数，反而是错误触发了`obj.bar`对应的副作用函数

问题就出在`effectRegister`函数身上，已知 `activeEffect` 作为全局变量去记录一个正在被访问字段的副作用函数，会导致在嵌套的`effectRegister`函数中，内部的副作用函数的执行会覆盖掉原先`activeEffect`的值，并且永远恢复不了原来的值

问题就出在`effectRegister`函数身上，已知 `activeEffect` 作为全局变量去记录一个正在被访问字段的副作用函数，会导致在嵌套的`effectRegister`函数中，内部的副作用函数的执行会覆盖掉原先`activeEffect`的值，并且永远恢复不了原来的值

```js
effectRegister(function effectFn1() {
  console.log("foo 组件触发了");
  // 这一步时 activeEffect 记录的是 effectFn1
  effectRegister(function effectFn2() {
    console.log("bar 组件触发了");
    obj.bar;
    // 这一步时 activeEffect记录的是 effectFn2
  });
  // 错误发生了！！obj.foo对应得effectFn1早已被覆盖为effectFn2
  // 导致obj.foo的对应副作用函数永远只能变为effectFn2
  obj.foo;
});
```
解决这个问题的做法是，创建一个副作用函数栈effectStack，副作用函数执行时，将副作用函数放入栈中，执行完毕时，从栈中取出，并始终让 activeEffect 指向栈顶
```js
// 副作用函数栈
const effectStack = []

// 注册副作用函数的函数
function makeEffect(fn) {
  const effectFn = () => {
    cleanup(effectFn);
    activeEffect = effectFn;
    effectStack.push(effectFn)
    fn();
    effectStack.pop()
    activeEffect = effectStack[effectStack.length - 1]
  };
  effectFn.deps = [];
  effectFn();
}
```
## 避免无限递归
可能会有这样一种情况
```js
effectRegister(() => {
  obj.num = obj.num + 1
})
```
会导致爆栈，原因在于：先读取`obj.num`的值，然后触发 `track `操作，将当前副作用函数收集到集合中，然后立即给 `obj.num` 赋值，这时触发 `trigger` 操作，把集合中的副作用函数取出，然后又触发了 `track` 操作 .... 副作用函数正在执行中，还没执行完毕，就又不得不开始下一次的执行，产生了无限递归，从而爆栈

分析问题可以发现，`obj.num`的读取和设置操作是在同一个副作用函数内进行的，此时`track`收集的副作用函数，还是`trigger`触发执行的副作用函数都是全局变量`activeEffect`。需要做的是，在`trigger`动作发生时增加必要的守卫条件：如果`trigger`触发的执行的副作用函数和当前正在执行的副作用函数相同，则不触发执行

```js
function trigger(target, key) {
  const depsMap = bucket.get(target);
  if (!depsMap) return;
  
  // 存储依赖结合
  const effects = depsMap.get(key);
  
  // 运行依赖集合
  const effectsToRun = new Set();
  
  effects && effects.forEach(effectFn => {
    // 如果当前执行的副作用函数 与 activeEffect 相同，则不加入到运行依赖集合
    if(effectFn !== activeEffect){
      effectsToRun.add(effectFn)
    }
  })
  effectsToRun.forEach((effectFn) => effectFn());
}
```