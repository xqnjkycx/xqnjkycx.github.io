# 枚举
使用枚举的好处在于可以定义一些带名字的常量。然后可以清晰的表达意图或创建一组有区别的用例。

TS支持数字的和基于字符串的枚举。

## 数字枚举
定义的数字枚举，第一个变量会被初始化为0。其余的成员会从1开始自动增长。也就是分别为`0，1，2，3`
```ts
enum Direction{
  Up, //0
  Down, //1
  Left, //2
  Right //3
}
```

## 字符串枚举
字符串枚举的概念很简单，但是有细微的**运行时差别**。在一个字符串枚举里，每个成员都必须用字符串字面量，或另外一个字符串枚举成员进行初始化。
```ts
enum Direction{
  Up="UP",
  Down="DOWN",
  Left="LEFT",
  Right="RIGHT",
}
```
由于字符串枚举没有自增长的行为，字符串枚举可以很好的序列化。

说的通俗一点，如果正在调试并且必须要读一个数字枚举的运行时的值，这个值通常是非常难读的，因为它不能代表有用的意思。

而字符串枚举允许你提供一个运行时有意义的可读的值，独立于枚举成员的名字。

## 异构枚举
从技术角度来说，枚举可以混合字符串和数字成员。
```ts
enum BooleanLikeHeterogeneousEnum {
    No = 0,
    Yes = "YES",
    }
```
不建议这么做。

## 联合枚举与枚举成员的类型
存在一种特殊的非计算的常量枚举成员的子集：字面量枚举成员。字面量枚举成员是指不带有初始值的常量枚举成员，或者是值被初始化为：
- 任何字符串字面量
- 任何数字字面量
- 应用了一元 - 符号的数字字面量

当所有枚举成员都拥有了字面量枚举值时，它就带有了一种特殊的语义。

首先，枚举成员成为了类型，就可以说某些成员只能说枚举成员的值：
```ts
// 枚举字面量
enum ShapeKind {
    Circle,
    Square,
}

interface Circle {
    kind: ShapeKind.Circle;
    radius: number;
}

interface Square {
    kind: ShapeKind.Square;
    sideLength: number;
}

let c: Circle = {
    kind: ShapeKind.Square, // Error! Type 'ShapeKind.Square' is not assignable to type 'ShapeKind.Circle'.
    radius: 100,
}
```
另外一种情况枚举类型本身变成了每个枚举成员的**联合**。类型系统就能够知道枚举值里的值的集合，于是可以捕获在比较值的时候的一些愚蠢的错误。
```ts
enum E {
    Foo,
    Bar,
}

function f(x: E) {
    if (x !== E.Foo || x !== E.Bar) {
        // Error! This condition will always return 'true' 
        // since the types 'E.Foo' and 'E.Bar' have no overlap.
    }
}

```
## 运行时与编译时
**运行时枚举**是真正存在的对象：
```ts
enum E{
  X,Y,Z
}
```
可以传递给函数
```ts
function f(obj: { X: number }) {
    return obj.X;
}

// 没问题，因为 'E'包含一个数值型属性'X'。
f(E);
```
**编译时枚举**，尽管一个枚举是在运行时真正存在的对象，但`keyof`关键字的行为与其作用在对象上时有所不同。应该使用`keyof typeof`来获取一个表示枚举里所有字符串`key`
```ts
enum LogLevel {
    ERROR, WARN, INFO, DEBUG
}

/**
 * 等同于：
 * type LogLevelStrings = 'ERROR' | 'WARN' | 'INFO' | 'DEBUG';
 */
type LogLevelStrings = keyof typeof LogLevel;

function printImportant(key: LogLevelStrings, message: string) {
    const num = LogLevel[key];
    if (num <= LogLevel.WARN) {
       console.log('Log level key is: ', key);
       console.log('Log level value is: ', num);
       console.log('Log level message is: ', message);
    }
}
printImportant('ERROR', 'This is a message');
```
## 反向映射
除了创建一个以属性名作为对象成员的对象之外，数字枚举成员还具有**反向映射**，从枚举值到枚举名字。
```ts
enum Enum {
    A
}
let a = Enum.A;
let nameOfA = Enum[a]; // "A"

```
这是因为Ts将这段代码编译为了下面的Js代码
```ts
var Enum;
(function (Enum) {
    Enum[Enum["A"] = 0] = "A";
})(Enum || (Enum = {}));
var a = Enum.A;
var nameOfA = Enum[a]; // "A"
```
生成的代码中，枚举类型被编译为了一个对象，它包含了正向映射`name -> value`和反向映射`value -> name`。引用枚举成员总会生成为对属性访问并且永远也不会内联代码。