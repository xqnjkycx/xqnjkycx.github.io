import{_ as i,c as l,o as e,U as a}from"./chunks/framework.qUHj8-gn.js";const h=JSON.parse('{"title":"入门","description":"","frontmatter":{},"headers":[],"relativePath":"performance-docs/foundation/index.md","filePath":"performance-docs/foundation/index.md","lastUpdated":1706107384000}'),t={name:"performance-docs/foundation/index.md"},o=a('<h1 id="入门" tabindex="-1">入门 <a class="header-anchor" href="#入门" aria-label="Permalink to &quot;入门&quot;">​</a></h1><p>要做前端的性能优化，最主要的就是去树立一个比较正确的性能优化的体系。</p><p>掌握性能优化，离不开一定比例的理论基础和实际操作的支撑。</p><p>具体到前端性能优化这件事情上，需要20%的理论，加上80%的实践，很多理论本身都是再具体的业务场景中实践出来的。</p><h2 id="前端性能优化体系" tabindex="-1">前端性能优化体系 <a class="header-anchor" href="#前端性能优化体系" aria-label="Permalink to &quot;前端性能优化体系&quot;">​</a></h2><p>其实前端性能优化的本质，都可以从这么一道题上来概括：</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>从输入URL到页面加载完成之后，到页面渲染发生了什么？</p></div><p>站在性能优化的角度上来看，简单来概括这个经典过程：</p><ul><li>首先通过DNS域名解析系统将URL解析为正确的IP地址</li><li>然后这个IP地址确定的那台服务器建立起TCP网络连接</li><li>随后向服务端发出HTTP请求</li><li>服务端处理好请求之后，把目标数据放在HTTP响应中返回给客户端，然后就到前端的渲染流程...</li></ul><p>再高度概括一下：</p><ul><li>DNS解析</li><li>TCP链接</li><li>HTTP 请求抛出</li><li>服务端处理请求，HTTP响应</li><li>浏览器拿到响应数据，解析响应内容，返回结果</li><li>浏览器进行用户交互...</li></ul><p>任何一个面向用户端的产品，都可以在这个过程中去考虑性能优化这个方案。</p><p>比如：</p><ul><li>DNS解析太花费时间了？—— 浏览器DNS缓存</li><li>TCP三次握手太久了？—— 长连接</li><li>HTTP请求太慢了？ —— 构建工具代码压缩和Tree-Shaking，静态资源部署CDN等等（减少请求次数和减少请求体积）</li><li>资源返回太慢了？ —— 浏览器缓存机制，资源加载优化，离线存储，</li><li>页面渲染太慢了？—— ssr，图片懒加载，按需加载</li><li>页面太卡了？ —— 合理操作DOM</li><li>如何测评性能？—— performance lightHouse</li></ul><p>总体来说，需要从<strong>网络层面</strong>和<strong>渲染层面</strong>来综合考虑网站的性能优化。</p><p>总体来说可以总结为下面一张图：</p>',16),n=[o];function r(s,p,c,d,_,u){return e(),l("div",null,n)}const f=i(t,[["render",r]]);export{h as __pageData,f as default};
