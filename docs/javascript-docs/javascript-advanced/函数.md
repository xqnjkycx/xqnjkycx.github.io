# 函数
function 是一种特殊的对象，它的特殊性体现在它的内部必须要实现一个`[[Call]]`方法。这个方法代表了一段可以复用的**过程**。

这个方法对于开发来说是不可见的，不过在规范内部，`typeof` 的原理就看对象里面有没有这个`[[Call]]` 属性的。

ECMAScript 规范还特意定义来一个操作，叫做 `Call(F,V[,argumentsList] )`。它的第一个参数 F 是一个函数对象，第二个参数 V 是一个上下文对象，最后是不定数量的参数。

这个操作的语义很明确，就是：**在 V 上调用 F，传入 argumentsList 参数**。

以 `Object.assign(a, b)` 为例，它在规范内部的表述就是 `Call(assign, Object, a, b)`。

大部分函数对象的内部还会存在一个叫做 `[[Construct]]` 方法，代表这个函数可以作为一个构造函数来创建对象。相应的，也有一个 `Construct(F[,argumentsList[,newTarget]])` 操作。

函数也是被某个特定构造函数构造出来的，这个构造函数就是`Function`

```js
function foo(){}

foo.constructor === Function // true
foo instanceof Function // true
```

## 函数的种类
这里主要介绍ES6之后的几个特殊函数：**箭头函数**，**异步函数**，**生成器函数**

### 箭头函数
箭头函数的特点就是它的内部没有 `this` 的概念，也就是说，`Function Environment Record` 的 `HasThisBinding()` 函数返回 **false**。

它会顺着作用域链向上查找最近的 this

```js
function Pool() {
    this.self = () => { return this; };
}

console.log(new Pool().self()); // Pool
```

这种特性不因调用方式的改变而改变，我们都知道，函数的`call`、`apply`、`bind` 方法都可以重置上下文，但是大家注意，这对箭头函数无效！

```js
const foo = () => { return this; };
foo.call(5); // window
foo.bind(4)(); //window
```
所以，当你想锁定一个函数的上下文的时候，那么就应该把它定义成箭头函数。如果不打算使用 this，那么箭头函数还是写起来更简练。

除了这个最重要的特性之外，箭头函数还有一个由此而来的推论：**箭头函数不可以作为构造函数**。这很容易理解，它没有 `this`，而构造函数又必须有，由此产生了不可调和的冲突，强行使用 `new` 来创建对象会导致错误：
```js
const foo = () => {};
new foo(); // ❌ Uncaught TypeError: foo is not a constructor
```
并且**箭头函数也不能作为构造函数使用，也不能使用super，arguments 也不能出现在箭头函数中。（ES6后不建议使用arguments，展开语法写起来更优雅）**

### 异步函数
**Promise是对回调地狱的优化，是多种语言公认的优秀异步方案。**
```js
Promise.resolve()
    .then(() => fetch("/xxx"))
    .then(res => res.json())
    .then(data => {
        if (data.role === 1) {
            return Promise.resolve()
                .then(() => {
                    return processAdmin(data.payload);
                });
        } else {
            return Promise.resolve()
                .then(() => {
                    return processMemeber(data.payload);
                });
        }
    })
    .catch(err => console.log(err));
```
这种写法依然会产生大量的缩进，可以使用`async - await`来实现同步的代码写法
```js
async onMount() {
    try {
        const res = await fetch("/xxx");
        const data = await res.json();
    
        if (data.role === 1) {
            await processAdmin(data.payload);
        } else {
            await processMemeber(data.payload);
        }
    } catch(err) {
        console.log(err);
    }
}
```
`async/await`也只不过是**Promise的语法糖**。通过这种异步关系，可以推出：异步函数不可以作为构造函数，不可以使用super。至于this 和 arguments，取决于 async 修饰的是一个箭头函数还是普通函数。

异步函数并不是由 Function 隐式创建的，而是叫做 `AsyncFunction`，它是 Function 的子类。不过 AsyncFunction 并不能直接访问得到，只能间接获取：
```js
const AsyncFunction = (async () => {}).constructor;

Object.getPrototypeOf(AsyncFunction) === Function; // true
```
因此，当你需要决定一个函数如何调用时，便可以以此来判断类型：
```js
if (callback instanceof AsyncFunction) {
    await callback();
} else {
    callback();
}
```
也可以动态创建一个异步函数
```js
const fn = AsyncFunction("", "return 1");

fn().then(ret => console.log(ret)); // 1
```

### 生成器函数
生成器函数看起来比较晦涩难懂：
```js
function* foo(seed) {
    const  ret = yield seed;
    return ret * seed;
}
```
如果说异步函数总是返回一个Promise对象，那么生成器函数每次都会返回一个**迭代器**对象。生成器函数返回的值不能直接使用，但是可以用`for...of`来遍历即可。
```js
function* count() {
    yield 9;
    yield 8;
    yield 7;
}

const it = count();

for (let k of it) {
    console.log(k); // 9 8 7
}
```
与异步函数类似，生成器函数也不是由Function构造的额，而是不可直接访问到的`GneratorFunction`：
```js
const GeneratorFunction = (function*() {}).constructor;

Object.getPrototypeOf(GeneratorFunction) === Function; // true
```
生成器函数也可以是异步的，构成一个**异步生成器函数**。但生成器函数不可以用箭头函数的形式定义。

箭头函数，异步函数，生成器函数之间并不是并列关系的分类，可以相互组合，但生成器和箭头不能组合。

不同函数的创建方式不同，使用场景也不同，决定了它们作为函数有着共同数据属性的同时，也会存在一些差异。

## 函数的结构
函数作为一个特殊对象，也有一些自己的独特属性：
- name
- length
- prototype

### name
name 是函数的名字，如果函数如此定义：
```js
function foo(){}
```
这样看来, name显然就是 foo，这并不难，但也存在一些特殊的例子：
```js
// 匿名
(function() {}).name // ""
(() => {}).name // ""
(async () => {}).name //""
(function*() {}).name // ""

// 普通函数
const foo = function(){};
foo.name // "foo"

// 箭头函数
const foo = () => {};
foo.name // "foo"

// 构造函数
const fn = Function()
fn.name // "anonymous"

// 成员函数
const obj = {
    foo() {},
    [Symbol.for("bar")]() {},
    get baz() {},
    set baz() {},
};
obj.foo.name // "foo"
obj[Symbol.for("bar")] // "[bar]"
Object.getOwnPropertyDescriptor(obj, "baz").get.name // "get baz"
Object.getOwnPropertyDescriptor(obj, "baz").set.name // "set baz"

// 私有函数
class Foo {
    #say() {}
    bark() {
        return this.#say.name;
    }
}

new Foo().bark() // "#say"

// 绑定函数
const foo = function() {}
foo.bind(3).name // "bound foo"
(() => {}).bind(3).name // "bound"

// 属性定义/赋值
const obj = {}
            
Object.defineProperty(obj, 'foo', {
    value: async() => {}
});

obj.bar = () => {};

obj.foo.name // "value"
obj.bar.name // ""

// ESM场景
// lib.js
export default function() {};
// index.js
import("./lib.js").then(({ default }) => {
    default.name // "default"
});
```
可以总结这么的规律：
- 各种匿名函数 name 均为空串
- 函数表达式的 name 为定义时赋值给的独立变量名
- 对象成员函数 name 为 key 的字符串表达
- 使用 Function 创建的函数的 name 为 `anonymous`
- `bind` 后的函数，name 前置 `bound`
- `export default` 导出的匿名函数 name 为`default`

诸如 **类私有函数**，**getter/setter**，都符合上述规则。事实上，name只是一个字符串表达式，其值是可以自由定义的。但是name作为对象属性本身是只读的，只能以重新定义的方式来修改：
```
function foo() { }

Object.defineProperty(foo,'name', {
    value: 'bar',
    writable: false,
    configurable: true,
    enumerable: false,
});
        
foo.name // "bar"
```
### length
`length`指出函数的参数个数。注意是函数的代码静态声明的参数，而不是运行时传入的参数。

一般来说，函数在定义时，其参数声明就已经定了，因此`length`也是一个不可写的属性。

```js
(function (a, b) {}).length // 2
```
引入函数展开语法后，特殊情况会出现：
```
(function (...a) {}).length // 0
(function (a, ...b) {}).length // 1
```
下面是一些函数的 length 值:
```js
Function.length // 1
Function.prototype.call.length // 1
Function.prototype.apply.length // 2
Array.prototype.splice.length // 2
window.setTimeout.length // 1
window.alert.length // 0
window.getComputedStyle.length // 1
parseInt.length // 2
JSON.stringify.length // 3
```
### prototype
一般的函数还会有一个`prototype`属性，这个属性函数用作构造函数时是至关重要的，用来实现 JS 的继承。
```js
function Foo() {}

const foo = new Foo();
```
函数 Foo 会有一个默认的 `prototype`，那么对于用其创建的对象 foo 来说，访问属性将很有可能顺着原型链访问到 Foo.prototype 上来。相当于以 Foo 创建的所有对象，都会共享 Foo.prototype 上面的属性。

函数在定义的时候，就应该为其创建一个`prototype`属性，值是一个包含`constructor`属性的简单对象。

```js
const fooProto = {};

Objet.defineProperty(fooProto, 'constructor', {
    value: Foo,
    writable: true,
    enumerable: false,
    configurable: true
});

Objet.defineProperty(Foo, 'prototype', {
    value: fooProto,
    writable: true,
    enumerable: false,
    configurable: false
});
```
`constructor`就是指向 Foo 本身。不过注意，它是不可枚举的，这也解释了当你用 `for...in` 遍历一个对象的时候，根本遍历不到 constructor。

如果在 Foo.prototype 上定义新的方法，那么将实现全部实例的数据共享：
```js
Foo.prototype.bar = function() {};

foo.bar();
```