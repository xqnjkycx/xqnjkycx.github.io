# 日期操作
`Date`对象是日常业务代码中最容易遇到的对象之一，在某些特殊场景下，`Date`也有一些特殊的表现。

## 创建日期对象
日期的本质就是数字，`Unix`时间戳从`**1970-01-01 00:00:00**`开始算起的毫秒数。但是这个字符串其实不太严谨，因为还缺少了时区的信息。

过去，`Unix`时间戳是以英国格林威治时间为基准的，这个格林威治简称就是**GMT**。**GMT**是基于天体运转观测而来的，所以一般很不精确，现在正在被原子钟的**协调世界时**所取代，称为`UTC`。

现在直接`new Date`创建对象获取本机时间，不需要任何的时区信息，这是因为产生的时间戳是一个**UTC**绝对值，而日期时间的语义化表述才是时区相关的。

```js
new Date()
//Thu Jan 18 2024 23:50:51 GMT+0800 (中国标准时间)
```

`Date`函数并不是只能构造出当前时间的日期对象，当Date不作为构造函数被调用时，就会忽略入参，返回当前时间的字符串表述，如：
```js
console.log(Date())
//'Sun Jan 14 2024 19:22:33 GMT+0800 (中国标准时间)'
```
这个字符串格式是通过内部得到一个叫做`ToDateString`方法得到的。

如果Date作为构造函数，那么可以传入多个参数：
- 不传参数，得到当前时间的字符串
- 如果参数只有一个：1.传入的是一个Date对象，相当于拷贝了这个Date时间戳。2.如果不是Date类型，就调用ToPrimitive将参数转换为原生类型；如果原生类似为String，使用Date.parse将参数转换为时间戳，否则用ToNumber强制转换为数字为时间戳
- 如果参数不少于两个，所有的参数都会被用`ToNumber`转成数字，前两个会被当作年份和月份，后面如果有的话，依次就是日，小时，分钟，秒，毫秒，除了日默认为1外，其余都默认为0.并且如果年份是[0,99]的范围内，则加上**1900**。

逻辑比较复杂，这里用一段伪代码来解释：
```js
function createDate(...args) {
    switch (args.length) {
        case 0: 
            return new Date();
        case 1:
            if (args[0] instanceof Date) {
                return new Date(args[0].getTime());
            }
            const primitiveData = ToPrimitive(args[0]);
            if ('string' === typeof primitiveData) {
                return new Date(Date.parse(primitiveData));
            }
            
            return new Date(ToNumber(primitiveData));
        default:
            let y = ToNumber(args[0]);
            const m = ToNumber(args[1]);
            const d = ToNumber(args[0] ?? 1);
            const h = ToNumber(args[0] ?? 0);
            const min = ToNumber(args[0] ?? 0);
            const s = ToNumber(args[0] ?? 0);
            const milli = ToNumber(args[0] ?? 0);
            
            if (y <= 99) y += 1900;
            
            const date = new Date();
            date.setYear(y, m, d, h, min, s, milli);
            return date;
    }
}
```
比如这样的代码，相当于拷贝了五个相同的时间戳，虽然是不同的日期对象：
```js
new Date(new Date(new Date(new Date(new Date()))))
```
有时，虽然日期对象可以被创建出来，但不一定是有效的:
```js
new Date(NaN)
// Invalid Date
```

## 日期的变换
在`Symbol.toPrimitive`的参数`hint`时，一般的对象都是将 **default** 当作 **number**，唯独 **Date** 是唯一一个将 default 视为 string 的内置对象类型，可以得到：
```js
new Date(0) == Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间) // true
```
所以，要做日期的加法计算，不能直接相加
```js
86400000 + new Date() // 得不到明天
// 最后只能得到： '86400000Sun Jan 14 2024 19:36:12 GMT+0800 (中国标准时间)'
```
除非用`getTime`或者`valueOf`转换成时间戳：
```js
new Date().getTime()
new Date().valueOf()
```
两个方法都是等价的，如果是单纯是取当前时间戳，最好还是使用`Date.now()`，固执的使用`new Date().getTime()`是没有任何好处的。

要获取指定时间的时间戳，除了能用`new Date(y,m,d).getTime()`，根据数据的来源不同，还可以使用`Date.UTC`和`Date.parse`这两种方法。

### Date.UTC
Date.UTC 和两个参数及以上的Date构建函数具有完全相同的参数签名，但是存在两点核心差异：
- **Date.UTC 返回时间戳，而Date构造函数返回日期对象。**
- **Date.UTC 的参数是UTC时间，而不是当前时区时间。**
所以，以北京时间为例，必须把当前时间减去8小时，传入Date.UTC才是准确的，没办法，Date相关的 API 不支持指定时区。

### Date.parse
`Date.parse`相当于在`Date`构造函数只传入一个字符串参数时效果是类似的，只不过`Date.parse`返回的时间戳而不是日期对象。

`Date.parse`首先会将参数用`ToString`转换为字符串，得到的字符串取决于格式，可能会让`Date.parse`正确解析，也可能返回NaN，涉及格式的方面比较多，有时候还取决于时区，语言和浏览器，这不是一个可以枚举的格式集合。

`Date.parse`首先会按照**ISO**格式解析：`YYYY-MM-DDTHH:mm:ss.sssZ`

```js
new Date().toISOString()
// '2024-01-14T12:10:27.032Z'
```
其中**Z**代表了UTC时间，也可以换成`+-HH:mm`时区格式，即'**2024-01-14T12:10:27.032Z+08:00**'，和上面等价的。

`Date.parse`对这种ISO格式提供了很大的容错性，都可以解析：
- 年份(yyyy)存在
- 小时(HH)存在，则分钟(mm)必须存在

以下都是合法的参数：
```js
'2023-07-16T10:03:14.713+08:00'
'2023-07-16T10:03:14.713'
'2023-07-16T10:03:14'
'2023-07-16T10:03'
'2023-07-16'
'2023-07'
'2023'
'2023T10:03'
'2023T10:03:14'
'2023T10:03:14.713'
'2023T10:03:14.713+08:00'
```
:::tip
如果传入的参数没有时间部分，则时区默认为UTC，否则时区默认为当前时区
:::
比如：
```js
new Date(Date.parse('2023-07-16')).toISOString() // '2023-07-16T00:00:00.000Z'
new Date(Date.parse('2023-07-16T00:00')).toISOString() // '2023-07-15T16:00:00.000Z'
```
`Data.parse`至少还包括以下两种格式的支持：
- 'Sun Jul 16 2023 00:00:00 GMT+0800 (中国标准时间)'；
- 'Sat, 15 Jul 2023 16:00:00 GMT' ,也即`toUTCString`的产物
:::tip
由于其中时区的不同解析策略，不建议使用 Date.parse，以及向 new Date() 传入字符串 来支持关键业务逻辑。对不同系统之间的信息传递之用，基于绝对时间的Unix时间戳是更安全格式
:::

## 日期的计算
Date API 本身不是用来做日期之间的计算之用，所以并没有设计明确的加减法，但是日期对象提供了一些额外功能和容错能力，可以拿来做一些简单的计算。

首先它的设置日期和设置时间方法，代表性的为setFullYear和setHours，它们的 TypeScript 签名是：

```js
setFullYear(year: number, month?: number, date?: number): number;
setHours(hours: number, min?: number, sec?: number, ms?: number): number;
```
setFullYear 除了发挥本职工作之外，还提供了设置month，date的能力，而setHours也提供了进一步向下设置minute,second,millisecond的能力。可以说，这样的设计可以免去开发者很多繁琐的工作量，不必再setMinutes，setSeconds，setMilliseconds一个一个地设置。

这些方法还有**进位**功能，设置溢出的数字，日期对象会自动进来匹配输入：
```js
var d = new Date(2000, 1, 29);
console.log(d.toLocaleString()); // "2000/2/29 00:00:00"
```
设置日期为30号，就会进入到3月1号:
```js
d.setDate(30);
console.log(d.toLocaleString()); // "2000/3/1 00:00:00"
```
设置负数就会倒退到1月份
```js
d.setDate(-1);
console.log(d.toLocaleString()); // "2000/1/30 00:00:00"
```
大概的逻辑为：1日是正常的最小日期，0就是倒退到1月31日，-1自然就是1月30号了

所以可以实现一个计算100天后的日期：
```js
function dateAfter100(currentDate) {
    const d = new Date(currentDate)
    d.setDate(currentDate.getDate() + 100);
    return d;
}
```