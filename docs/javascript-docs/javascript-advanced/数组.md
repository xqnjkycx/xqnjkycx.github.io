# 数组
在C++，Java等静态编译型语言中，数组只能存储同类型的数组（类似TS的元组），并且数组的长度是固定的，这是因为数组在内存上是一片连续的区域，虽然容量不可变，但是在定位和遍历上非常高效。

而**JavaScript 的数组更加灵活，不但可以存储不同类型的数组，而且数组的容量也可以灵活地扩展和收缩。**这是背后的底层引擎所决定的，像V8引擎，在实现数组上就有连续内存和哈希表两种结构。

## 创建数组
创建数组可以用中括号来声明一个数组字面量，它的每一个位置都已经初始化数据，数组的长度也定了。虽然可以后期更改，但是会带来一定的开销。

如果数据量一定，应该更倾向于用`Array`构造器来初始化一个有确切容量的空数组。这个数组的每一个位置上都没有数据。**没有数据不代表是 undefined**。

```js
const arr = new Array(3)
console.log(arr) //[empty, empty, empty]
```
使用`fill`函数可以批量填充任意的数据：
```js
arr.fill(undefined)
console.log(arr) // [undefined * 3]
```
可以从运行结果上分辨这两种状态，无数据代表数组对象没有这个key，有数据代表数组对象有这个key，但是值为undefined，因此使用`hasOwnProperty`函数或者in操作符：
```js
const arr = new Array(5)

arr.hasOwnProperty(0) //false
0 in arr // false

arr.fill(undefiend)

arr.hasOwnProperty(0) //  true
0 in arr //undefined
```
`Array()`构造器也可以传入一个以上的参数，不过这时参数的意义就发生变化了：
- 不传参数，代表空数组
- 传入1个参数，代表的数组的长度
- 传入多个参数，代表的是数组内初始化数据，和中括号语法的结果是等价的
```js
function createArray(...params){
    return new Array(...params)
}

createArray(5) // 构建一个长度为5的无数据数组
createArray(5,6) // 返回包含数字5和6的长度为2的有数据数组
```
这种API具有迷惑性，不建议使用，而是静态方法`Array.of()`，比如`Array.of(3,4,5)`

`Array.of`函数并非必须在Array上调用，如果一个构造函数，它有唯一一个Number类型的参数，那么就可以作为这个函数的上下文了：
```js
class Queue {
    size;
    constructor(size) {
        this.size = size;
    }
}

console.log(Array.of.call(Queue, 15, 16))
```
![image](./assets/ArrayOf%E5%AE%9E%E7%8E%B0Queue.png)
简单来说，`Array.of`的逻辑非常简单，以下简单实现：
```js
function myArrayOf(...elements) {
    // 以 this 为构造函数，传入当前函数的参数个数作为唯一构造参数
    const obj = Reflect.construct(this, [elements.length]);
    
    // 在生成的对象上创建序号为 key 的各种属性
    for (const [index, value] of elements.entries()) {
        Object.defineProperty(obj, index, {
            value,
            enumerable: true,
            configurable: true,
            writable: true,
        });
    }
    
    // 添加 length 属性，值为当前函数的参数个数
    Object.defineProperty(obj, 'length', {
        value: elements.length,
        enumerable: true,
        configurable: true,
        writable: true,
    });

    return obj;
}
```
如果希望每个位置的值不一样，并且带有一定的逻辑性，可以使用Array.from

例如：**生成一个数组，包含有序的26个大写英文字母**
```js
Array.from(new Array(26),(val,index)=>String.fromCodePoint(65+index))
```
## 遍历数组
数据遍历用`for循环`，`while循环`都是常规的办法，增加了`forEach`实例函数，它的特点是不允许中途退出。

`for...in`以普通对象的方式来遍历数组，如果数组对象上有其他属性，很可能被遍历出来，比如之前的正则的exec的特殊数组结构：
```js
/[A-Z]+/.exec("AC78") // ['AC', index: 0, input: 'AC78', groups: undefined]
```
`for...in`会把index，input，gourps也遍历出来。而数组上的every，forEach，map，find 等方法，虽然在原型链上，但是不能被遍历出来。

因为ESMCAScript做了精心的设计，这些数组的方法都是不可枚举的（`non-enumerable`），通过下面的代码可以看出来：

```js
Object.getOwnPropertyDescriptor(Array.prototype，'find')
```
![image](./assets/find%E6%96%B9%E6%B3%95%E4%B8%8D%E5%8F%AF%E4%BF%AE%E6%94%B9.png)

enumerable 输出的是false，代表了不能被`for...in`遍历出来

无论如何，`for...in`确实存在潜在的风险，所以推荐使用`for...of`的方式：

```js
for(const val of [1,2,3]){ console.log(val) }
```
并且`for...of`**能利用数组具有迭代器的特性，进行安全地遍历数组**，缺点在于不能直接输出序号，但是可以围魏救赵
```js
for (const [index,val] of [1,2,3].entiries()){
  console.log(index,val)
}
```
## 搜索数组
搜索特定元素在数组中的位置，通常使用`indexOf`,`lastIndexOf`,`findIndex`,`finedLastIndex`这四个函数。

其中,`indexOf`和`lastIndexOf`有两个特殊情况需要关注：
- 不认为数组中的无数据位置是undefined
- 无法搜索到NaN
这两个函数的关键运行原理为：
- 按照顺序遍历数据，对于下标 index ，要保证数组有这个属性，可以理解为`array.hasOwnProperty(index) === true`要成立，因此无数据的那些位置不会被当成undefined
- 内部使用了规范的`IsStrictlyEqual(x,y)`函数来比较两个对象，这个函数可以理解为符号`===`，可以知道`(NaN === NaN) === false`
手写一下`indexOf`
```js
Array.prototype.indexOf = function(ele) {
    for (let i = 0; i < this.length; i += 1) {
        // 判断有无此数据
        if (!this.hasOwnProperty(i)) continue;
        // 严格相等判断
        if (ele === this[i]) return i;
    }
    return -1;
}
```
## 找到元素
`find`和`some`都可以搜索数组中有没有指定的元素。`some`返回布尔语义更清晰，需要传入一个判断函数：
```js
[NaN,1,Infinity].some(ele => ele === Infinity)
```
如果想直接传入与元素相等的值，`includes`只够了
**但数组的indexOf和includes在搜索指定元素上还是存在不同之处**
看这个例子：
```js
new Array(5).includes(undefined) //true
[NaN].includes(NaN) // true
```
可想而知，`includes`一定不是`IsStrictlyEqual`实现的。
- 首先，`includes` 不会要求 `array.hasOwnProperty(index) === true`，因此即便在这个下标没有数据，强行读取仍然会读到 `undefined`；
- 其次，`includes` 不使用 `IsStrictlyEqual` 而是 `SameValueZero`，相对而言，它支撑 NaN 的判断。
