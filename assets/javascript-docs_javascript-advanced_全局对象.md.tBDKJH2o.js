import{_ as s,c as i,o as a,U as n}from"./chunks/framework.PFQuerqu.js";const e="/assets/ResolveBinding.WI1z_Mzw.png",t="/assets/Environment.dzW6gaAq.png",p="/assets/windowprotoproto.EQSUxjf0.png",l="/assets/eventTarget.Xqb5nl0B.png",h="/assets/window的原型链.pR4HToc0.png",b=JSON.parse('{"title":"全局对象","description":"","frontmatter":{},"headers":[],"relativePath":"javascript-docs/javascript-advanced/全局对象.md","filePath":"javascript-docs/javascript-advanced/全局对象.md","lastUpdated":1706532002000}'),d={name:"javascript-docs/javascript-advanced/全局对象.md"},k=n('<h1 id="全局对象" tabindex="-1">全局对象 <a class="header-anchor" href="#全局对象" aria-label="Permalink to &quot;全局对象&quot;">​</a></h1><p>全局对象是一类特殊的对象，它在任何JavaScript代码的执行之前就已经创建了，并且不提供任何方法去创建第二个实例。全局对象的作用很多，比如去承载各种各样的其他“全局”内置对象，也是不同模块之间交流数据的最简单粗暴的渠道。</p><h2 id="全局对象的基本理解" tabindex="-1">全局对象的基本理解 <a class="header-anchor" href="#全局对象的基本理解" aria-label="Permalink to &quot;全局对象的基本理解&quot;">​</a></h2><p>每个<code>Enviroment Record</code>都有一个<code>[[OuterEnv]]</code>指针，指向其父环境，最终可以上溯到一个<code>Global Environment Record</code>。当代码执行到需要访问一个变量的时候，实际上就是从当前<code>Environment Record</code>一路向上寻找哪一个“绑定”了这个名称的变量，这就相当于访问到了，如果没找到就会抛出一个<code>ReferenceError</code>。</p><p>这个过程的规范叫做<code>ResolveBinding(name[,env])</code>，其本质是在调用<code>GetIdentifierReference(env,name)</code>，它的逻辑非常简单，就是一个递归性的遍历。</p><p><img src="'+e+'" alt="image"></p><p><code>HasBinding</code>和<code>GetBindingValue</code>是每一个<code>Environment Record</code>都拥有的方法，并且都可以重载。</p><p><img src="'+t+`" alt="image"></p><p>事实上，<code>Declarative Environment Record</code>，<code>Object Environment Record</code>和<code>Gloabl Environment Record</code> 都有各自的<code>HasBinding</code>和<code>GetBindingValue</code>实现。</p><p>对于<code>Gloabl Environment Record</code>的实现，需要特别注意它的4个独特的属性：</p><ul><li><strong>[[ObjectRecord]]</strong></li><li><strong>[[DeclarativeRecord]]</strong></li><li><strong>[[GlobalThisValue]]</strong></li><li><strong>[[VarNames]]</strong></li></ul><p>其中<code>[[DeclarativeRecord]]</code>是一个<code>Declarative Environment Record</code>，它包含了在全局环境中的以const，let，class等方式声明的变量。</p><p>而<code>Object Environment Record</code>通过对象结构容纳了大部分的全局数据。</p><p><code>Object Environment Record</code>有两个特殊的属性，分别是<code>[[IsWithEnvironment]]</code>和<code>[[BindingObject]]</code>。对于全局环境的<code>[[ObjectRecord]]</code>来说，<code>[[BindingObject]]</code>指的就是<strong>全局对象</strong>。</p><p>在ECMAScript规范中，有这么一个规矩：<strong>先查询<code>[[DeclarativeRecord]]</code>，再查询<code>[[ObjectRecord]]</code></strong>。于是可以推断出下面的结果。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(foo) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//2</span></span></code></pre></div><div class="tip custom-block"><p class="custom-block-title">var 和 const let 的区别</p><p>通过const，let，class 等方式声明的变量，只会影响到<code>[[DeclarativeRecord]]</code>。但通过var，function等方式定义的就完全不同。会涉及到<code>CreateGloablBinding</code>和<code>CreateGlobalFunctionBinding</code>这两个方法。</p></div><h2 id="全局对象下的属性" tabindex="-1">全局对象下的属性 <a class="header-anchor" href="#全局对象下的属性" aria-label="Permalink to &quot;全局对象下的属性&quot;">​</a></h2><p>全局对象下有一系列的属性，包括<code>globalThis</code>,<code>NaN</code>,<code>Infinity</code>,<code>undefined</code>,<code>eval</code>,<code>isFinite</code>,<code>isNaN</code>,<code>parseInt</code>,<code>parseFloat</code>,<code>decodeURI/encodeURI</code>,<code>decodeURIComponent/encodeURIComponent</code>,<code>JSON</code>,<code>Math</code>,<code>Reflect</code>,<code>Error</code>,<code>Array</code>,<code>String</code>,<code>Number</code>,<code>Boolean</code>,<code>Object</code>,<code>Function</code>,<code>RegExp</code>,<code>Symbol</code>,<code>Date</code>,<code>Map</code>,<code>Set</code>,<code>Promise</code>,<code>Proxy</code>,<code>Int8Array</code>等等。</p><p>这些结构的一个无例外的特征就是，它们都是完全不可枚举的<code>(non-enumerable)</code>，因此默认情况下<code>Object.keys(window)</code>是绝对找不到这些属性名的。</p><p>其中有一个属性叫做<code>gloablThis</code>，这是ES2020才引入的，按照规范，在任何运行环境下，访问全局对象都应该使用<code>globalThis</code>。</p><p>虽然在浏览器环境中，window一直是全局对象的代名词，可以使用<code>window.foo</code>或者<code>window[&quot;foo&quot;]</code>来访问全局属性。<strong>但实际上Window这个词本身实际就是指全局对象下的属性名</strong>，即<code>window.window</code>，准确的表述应该是<code>globalThis.window</code>。类似的还有<code>self</code>。即全局对象的某些属性指向了自己，形成了环，<strong>所以window是不可以被JSON序列化的</strong>。</p><p>浏览器在全局对象下定义了起码几百个额外的全局属性，如图： <a href="./assets/window%E5%B1%9E%E6%80%A7.png">!image</a></p><p>这样以来，像<code>addEventListener</code>，<code>onerror</code>，<code>getComputedStyle</code>等这些属性。完全其实可以不加上window，一般为了规范来说最好还是加上</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;load&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,()</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onerror</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(){})</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getComputedStyle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(dom,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><p>在NodeJS的环境中，以<code>gloabl</code>作为全局对象的代名词，而且现在<code>global === globalThis</code>，有时候看到很多即兼容浏览器又能兼容NodeJS的代码，需要来回的判断window和global才能取到全局对象。</p><p>global的额外属性要少很多，大概有这些：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;global&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;clearInterval&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;clearTimeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;setInterval&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;setTimeout&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;queueMicrotask&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;performance&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;clearImmediate&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;setImmediate&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>但是，在NodeJS中的代码中的var，function的声明并不会干预到全局对象：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foo </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 99</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(global.foo) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// undefined</span></span></code></pre></div><p>而且<code>this</code>也不会指向全局对象</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">this</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> global </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span></code></pre></div><h2 id="window的原型关系" tabindex="-1">Window的原型关系 <a class="header-anchor" href="#window的原型关系" aria-label="Permalink to &quot;Window的原型关系&quot;">​</a></h2><p>可以知道，window 和 Window 都是可以直接引用的全局对象属性，并且“一定”满足<code>window instanceof Window === true</code>。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOwnPropertyDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(globalThis, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;window&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     configurable: false</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     enumerable: true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     get: ƒ window()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     set: undefined</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOwnPropertyDescriptor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(globalThis, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;Window&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     configurable: true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     enumerable: false</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     value: ƒ Window()</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//     writable: true</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// }</span></span></code></pre></div><p>window是一个<strong>不可配置，不可更改</strong>的属性，时刻保证它的安全。但是Window就不那么严格了，不但是可以配置的，而且可写，所以是可以写出这样的“恶意”代码：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">global.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Window</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// success</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instanceof</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Window</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// false</span></span></code></pre></div><p>所以，<strong>Window 是可篡改的</strong>。</p><p>对于window对象的原型链，可以通过<code>Reflect.getPrototypeOf</code>，或者非标准的<code>__proto__</code>：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> winProto</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getPrototypeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(window)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">ownKeys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(winProto) </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//[&#39;TEMPORARY&#39;, &#39;PERSISTENT&#39;, &#39;constructor&#39;, Symbol(Symbol.toStringTag)]</span></span></code></pre></div><p>继续往上爬：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> winProtoProto</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> winProto.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">__proto__</span></span></code></pre></div><p>可以看到如下的打印： <img src="`+p+`" alt="image"></p><p>这个<code>WindowProperties</code>类型的对象，但它却没有 constructor，可能是随着某个函数的创建而创建的，大概像这样：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> windowProperties</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    [Symbol.toStringTag]: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;WindowProperties&quot;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Reflect.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">setPrototypeOf</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(winProto, windowProperties);</span></span></code></pre></div><p>继续向上，可以看到一个叫做<code>EventTarget</code>的对象，并且有一些和事件相关的API：<code>addEventListner</code>，<code>removeEventListener</code>，<code>dispatchEvent</code>。</p><p><img src="`+l+`" alt="image"></p><p>EventTarget 也是一个公开的API。可以说，<strong>浏览器中所有实现了相关事件接口的对象，原型链上都能追溯到EventTarget，除了 Window 之外，还包括 Document，各种 HTMLElement，XMLHttpRequest 等等。</strong></p><p>事件派发机制在前端是一种非常常见的编程范式，可以认为是<strong>Pub-Sub</strong>。通常会引入第三方库来实现，比如 <em>eventemitter3</em>, <em>mitt</em> 等等。</p><p>有个小技巧就是，不用引入任何第三方库，直接用原生的<code>EventTarget</code>就可以了，而且非常适合Node.js环境。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyEventBus</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> extends</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventTarget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{}</span></span></code></pre></div><p>如果嫌API名字冗长，可以换成on，off，emit</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyEventBus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">    #et</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> EventTarget</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    on</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.#et.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    off</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.#et.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    emit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">args</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">        this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.#et.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">dispatchEvent</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">args);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>然后 EventTarget 再向上就到顶了，即 <strong>EventTarget.prototype.proto === Object.prototype</strong>。可以看到如下原型链结构：</p><p><img src="`+h+'" alt="image"></p>',55),o=[k];function c(r,E,g,y,F,v){return a(),i("div",null,o)}const m=s(d,[["render",c]]);export{b as __pageData,m as default};
