# 异步编程
2012年时，`Promises/A`规范被提出，随着ES6的成熟，现在Promise对象已经在 2015 年被接入到了JavaScript 语言中。

ES6中的Promise对象基于`Promises/A+`规范，提供了一套完整的方法和内置的语法糖。

## Promsie 原理
Promise对象有三种状态：`pending`，`fulfilled`，`rejected`。当一个Promise对象处于`pending`状态时，可以通过调用`resolve`函数将其状态改变为`fulfilled`，或者通过调用`reject`函数将其状态改为`rejected`。

一旦状态发生改变，就不可逆转，并调用相对应的回调函数。

![image](./assets/promise%E7%8A%B6%E6%80%81.png)

`fullfilled`与`rejected`被统一称为`settled`

以下是一个非常简单的示例：
```js
const promise = new Promise((reoslve,reject)=>{
    // 异步操作
    setTimeout(()=>{
        const randomNum = Math.random()
        if(randomNum < 0.5){
            reoslve("fullfiled")
        }else{
            reject("reject")
        }
    })
})

promise.then((result)=>{
    console.log("fulfiled",result)
})
.catch((error)=>{
    console.log("reject:",error)
})
```
Promise的实现好处就在于可以避免异步回调地狱的问题，将异步操作的嵌套方法改为链式调用。比如：
```js
function asyncOperation1() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Operation 1');
    }, 1000);
  });
}

function asyncOperation2() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Operation 2');
    }, 1000);
  });
}

function asyncOperation3() {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      resolve('Operation 3');
    }, 1000);
  });
}

// 实现异步的链式调用
// 本质是因为每个then都返回一个新的promsie
asyncOperation1()
  .then((result1) => {
    console.log(result1);
    return asyncOperation2();
  })
  .then((result2) => {
    console.log(result2);
    return asyncOperation3();
  })
  .then((result3) => {
    console.log(result3);
  })
  .catch((error) => {
    console.log(error);
  });
```
这三个异步操作函数1，2，3。它们会分别返回一个Promise对象。

然后通过使用 then 方法，将这些异步操作串联起来，以便于顺序执行。如果任何一个异步操作失败了，就会调用 catch 方法来处理错误。

虽然，也可以不按照链式调用来实现。
```js
const op1 = asyncOperation1();
op1.catch((error) => {
    console.log(error);
  });
op1.then(() => {
    return asyncOperation2();
  })
  .catch((error) => {
    console.log(error);
  });
op1.then(() => {
    return asyncOperation3();
  })
  .catch((error) => {
    console.log(error);
  });
```
真正的实现原理是：
Promise对象内部，会存在两个分别叫做`[[PromiseFulfillReactions]]`和`[[PromiseRejectReactions]]`的列表，其实存储的就是 then 和 catch 参数。

于是，在一个Promise上多次调用 then 和 catch，它们的参数就都会存储在这两个列表中，等到Promise的状态一旦发生改变，就会依次取出列表中的函数来调用。

所以，`[[PromiseFulfillReactions]]`和`[[PromiseRejectReaction]]`都是充当了一个缓存的角色。

## 手写一个简单的Promise
先来定义一个基本的Promise状态
```js
const STATE = {
    PENDING:'pending',
    FULFILLED:'fulfilled',
    REJECTED:'rejected'
}
```
定义一个基本的Promise类，并定义好其内部状态和入口
```js
class _Promise{
    // 初始状态为pending
    #state=STATE.PENDING
    // 接受成功的回调函数集合
    #fulfillReactions = []
    // 接受失败的回调函数集合
    #rejectReactions = []
  	// 传给resolve 和 reject 的结果
  	#result=undefined
  
    constructor(executor){
        // 拦截非函数
        if('function' !== typeof executor){
            throw TypeError('Promise executor is not a function')
        }
    }
  	// 定义 then 函数
    then(fulfillReaction, rejectReaction){
    	
    }
  	// 定义catch 函数
    catch(rejectReaction){

    }

}
```
这里用`#fulfillReactions`和`#rejectReactions`来模拟上文提到的`[[PromiseFulfillReactions]]`和`[[PromiseRejectReactions]]`。

对于实现Promise的第一步，就要去运行**executor**，这一步在构造函数中直接同步执行。

考虑一下调用方式`new Promise( (resolve,reject) => { /****/} )`

得到几个关键信息：
- 需要传给Promise一个函数
- 这个函数被传入了内置的resolve和reject，已知调用resolve和reject，会导致Promise的状态发生改变并且执行then或catch内的方法
- resolve,reject还可以接受值然后传给then和catch

所以`constructor`中需要这么实现：
```js
    constructor(executor){
        if('function' !== typeof executor){
            throw TypeError('Promise executor is not a function')
        }
        executor(
          (value)=>{
              // 把结果存到#result中，以备后面使用
              this.#result = value
              this.#state = STATE.FULFILLED
              this.#fulfillReactions.forEach(reaction => reaction(value))
          },
          (reason)=>{
              this.#result = reason
              this.#state = STATE.REJECTED
              this.#rejectReactions.forEach(reaction => reaction(reason))
          }
        )
    }
```
而`#fulfillReactions`和`#rejectReactions`的值来源于当then和catch调用时将传进来的函数进行缓存:
```js
    then(fulfillReaction, rejectReaction){
        if(fulfillReaction) this.#fulfillReactions.push(fulfillReaction)
        if(rejectReaction) this.#rejectReactions.push(rejectReaction)
    }

    catch(rejectReaction){
        if(rejectReaction) this.#rejectReactions.push(rejectReaction)
    }
```
问题在于，如果executor是同步调用resolve和reject的，导致还没走到then和catch中去缓存回调函数时，`#fulfillReactions`和`#rejectReactions`就被拿来调用了，而此时这两个队列还是空队列。

所以要把`#fulfillReactions`和`#rejectReactions`放到异步队列中将缓存的函数逐步执行。

如果在Node.js中可以使用`process.nextTick`来包裹模拟执行。

如果在Web中可以使用`setTimeout`来包裹执行。

当然使用`process.nextTick`是最好的，因为它是微任务，而`setTimeout`是不好的，因为他是宏任务。

这里用`setTimeout`来简单模拟，改写执行效果如下：

```js
    constructor(executor){
        if('function' !== typeof executor){
            throw TypeError('Promise executor is not a function')
        }
        executor((value)=>{
            this.#result = value
            this.#state = STATE.FULFILLED
            // 使用异步队列来执行
            setTimeout(()=>{
                this.#fulfillReactions.forEach(reaction => reaction(value))
            })
        },(reason)=>{
            this.#result = reason
            this.#state = STATE.REJECTED
            setTimeout(()=>{
                this.#rejectReactions.forEach(reaction => reaction(reason))
            })
           
        })
    }
```
然后观察then函数，调用这个函数的时候，Promise对象一般还在pending状态，也可能处于fulfilled或rejected状态。并且无论是哪一种，then都需要返回一个全新的Promise来实现链式调用。
```js
    then(fulfillReaction, rejectReaction){
        if(this.#state === STATE.FULFILLED){
            return new _Promise(resolve => resolve(this.#result))
        }
        if(this.#state === STATE.REJECTED){
            return new _Promise((resolve,reject)=>reject(this.#result))
        }
        if(this.#state === STATE.PENDING){
            return new _Promise((resolve,reject)=>{
                const tempFulFillReaction = (value) => {
                    if(fulfillReaction) fulfillReaction(value)
                    resolve(value)
                }
                this.#fulfillReactions.push(tempFulFillReaction)
                const tempRjectaReaction = (reason) => {
                    if(rejectReaction) rejectReaction(reason)
                    reject(reason)
                }
                this.#rejectReactions.push(tempRjectaReaction)
            })
        }
    }
```
由于catch本身就是then方法的缺少成功回调的语法糖，所以可以这样实现：
```js
    catch(rejectReaction){
        return this.then(undefined,rejectReaction)
    }
```
## Promise的静态方法
Promise的静态方法很多，包括 `resolve/reject/all/race/allSettled/any`。

大部分的方法都是为了操作效率而设计的，因此如果理解其内部原理的话，都可以自行实现，甚至可以扩展一些其他的功能。

### Promise.resolve Promise.reject
`Promise.resolve`将参数转换为 Promise 形态，用代码可以描述:
```js
Promise.resolve = result => new Promise(resolve => resolve(result))
```
如果参数本身就是一个Promise，那么也就链上去就行了，因此并非一定走的到then:
```js
Promsie.resolve(new Promise((resolve,reject)=>throw Error()))
.catch( /.../) // 最终走到catch来了
```
类似的还有Promise.reject，不多说。

### Promise.all
接受一个Promise组成的数组，如果数组内的所有Promise的所有参数都走到了`fulfilled`，那么就返回一个成功的Promise。否则，只要有一个Promise是失败的，那么就会返回一个失败的Promise。

基本原理如下：
```js
Promise.all = (promises) => {
    return new Promise((resolve, reject) => {
        const results = new Array(promises.length);
        let fulfilledCount = 0;
        for (let i = 0; i < promises.length; i += 1) {
            Promise.resolve(promises[i]).then(
                (result) => {
                    results[i] = result;
                    fulfilledCount += 1;检查
                    // 计数
                    if (fulfilledCount === promises.length) resolve(results);
                },
                // “短路”效应
                reject
            );
        }
    });
};

```
### Promise.allSettled
它的特点是收集所有的`Promise`结果，最后resolve出去。所以它永远走不到rejected。
```js
Promise.allSettled([
    Promise.resolve(1),
    Promise.reject(1)
]).then(console.log);
// [
//   { status: 'fulfilled', value: 1 },
//   { status: 'rejected', reason: 1 }
// ]
```
### Promise.any
这个与Promise.all正好相反。但是特点在于如果所有的Promise都被rejecet了，就会抛出一个`AggregateError`。
:::tip
Promise.any 比较新，需要注意浏览器的兼容性，它是唯一一个可以产生AggregateError的方法
:::
```js
Promise.any = (promises) => {
    return new Promise((resolve, reject) => {
        const results = new Array(promises.length);
        let rejectedCount = 0;
        for (let i = 0; i < promises.length; i += 1) {
            Promise.resolve(p).then(
                // “短路”效应
                resolve,
                (result) => {
                    results[i] = result;
                    rejectedCount += 1;检查
                    // 计数
                    if (rejectedCount === promises.length)
                        reject(AggregateError(results));
                }
            );
        }
    });
};
```

### Promise.race
任意的Promise从pending进入到reject获取resolve。它就会返回对应状态的Promise，而忽略其他Promise。
```js
Promise.race = (promises) => {
    return new Promise((resolve, reject) => {
        for (let i = 0; i < promises.length; i += 1) {
            Promise.resolve(p).then(
                resolve,
                reject
            );
        }
    });
};
```