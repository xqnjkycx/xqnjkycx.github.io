import{_ as s,c as i,o as a,U as t}from"./chunks/framework.qUHj8-gn.js";const n="data:image/png;base64,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",e="/assets/222fps渲染.dg3J9-Fk.png",l="/assets/渲染任务流程图.lMWFp48b.jpg",I=JSON.parse('{"title":"渲染时机的优化","description":"","frontmatter":{},"headers":[],"relativePath":"performance-docs/foundation/渲染时机的优化.md","filePath":"performance-docs/foundation/渲染时机的优化.md","lastUpdated":1709976146000}'),A={name:"performance-docs/foundation/渲染时机的优化.md"},p=t(`<h1 id="渲染时机的优化" tabindex="-1">渲染时机的优化 <a class="header-anchor" href="#渲染时机的优化" aria-label="Permalink to &quot;渲染时机的优化&quot;">​</a></h1><p>动画的画面其实是由一帧一帧的静态图快速切换组成的，人眼的反应速度有限，所以当画面切换的够快，对于人眼来说就是连续的动画了。</p><h2 id="reuqestanimationframe" tabindex="-1">reuqestAnimationFrame <a class="header-anchor" href="#reuqestanimationframe" aria-label="Permalink to &quot;reuqestAnimationFrame&quot;">​</a></h2><div class="tip custom-block"><p class="custom-block-title">TIP</p><p><code>window.requestAnimation</code>可以告诉浏览器希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。这个方法需要传入一个回调函数来作为参数，这个回调函数会在浏览器下一次重绘之前进行执行。</p></div><p>这个API专门用于处理JS动画，相比于平常的定时器动画，<code>requestAnimation</code>更加稳定，其区别在于<code>requestAnimationFrame</code>不可以设置间隔时间，它的间隔时间是由浏览器自身来决定的，大约是<code>17ms</code>左右。</p><p>像<code>setTimeout</code>和<code>setInterval</code>的问题在于，它们并不是精确的。它们的内在运行机制决定了 <strong>时间间隔参数</strong> 实际上只是指定了把动画代码添加到 <strong>浏览器UI线程队列</strong> 中以等待执行的时间。如果队列前面已经加入了其它任务，那动画代码就要等前面的 <strong>任务完成后</strong> 再执行，就可能会导致动画可能不会按照预设的方式去执行，要么是间隔小于一帧导致多余的重绘，要么是间隔大于一帧，有一帧渲染空了，画面不流畅，会降低用户的体验。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>需要强调的一点是<code>requestAnimationFrame</code>能够保证回调函数在每一帧内只渲染一次，如果这一帧有太多的任务需要执行，还是会造成卡顿的，因此它只能保证重新渲染的时间间隔最短是屏幕的刷新时间。</p></div><h3 id="基本使用" tabindex="-1">基本使用 <a class="header-anchor" href="#基本使用" aria-label="Permalink to &quot;基本使用&quot;">​</a></h3><ul><li><p><code>requestAnimationFrame</code>本质上是一个全局<code>window</code>对象上的一个属性函数，函数是要被执行的，要被调用的。所以我们使时，直接：<code>window.requestAnimationFrame(callBack)</code>即可。</p></li><li><p>和定时器一样其接收的参数<code>callback</code>也是一个函数，即下一次重绘之前更新动画帧所调用的函数，即在这个函数体中，可以写对应的逻辑代码（和定时器类似）</p></li><li><p><code>requestAnimationFrame</code>也有返回值，返回值是一个整数，主要是定时器的身份证标识，可以使用 <code>window.cancelAnimationFrame()</code>来取消回调函数执行，相当于定时器中的<code>clearTimeout()</code></p></li><li><p>想要继续执行，做到类似<code>setInterval</code>的效果，需要写成递归的形式</p></li></ul><p>一个实际的代码例子：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">		// requestAnimationFrame请求动画帧方式</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">		function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> requestAnimationFrameFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> timer </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 可注掉</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			box2.style.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;0px&#39;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">			function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> callbackFn</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> leftVal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> parseInt</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(box2.style.left)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">				if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (leftVal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 720</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">					cancelAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(timer) </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">					box2.style.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> leftVal </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;px&#39;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">                    // 如果想在浏览器下次重绘之前继续更新下一帧动画，那么回调函数自身必须再次调用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">					window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callbackFn)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">				}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">			window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestAnimationFrame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(callbackFn)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">		}</span></span></code></pre></div><p>回调函数的执行次数通常是每秒60次，但在大多数遵循<code>W3C</code>建议的浏览器中，回调函数执行次数通常与<strong>浏览器屏幕刷新次数</strong>互相匹配。一般大约为17.6ms。</p><p>并且为了提高性能和电池寿命，在大多数浏览器里，当<code>requestAnimationFrame()</code>运行在后台标签或隐藏的<code>&lt;iframe&gt;</code>里时，<code>requestAnimationFrame()</code>会被暂停调用来提升性能和电池寿命。</p><h2 id="requestidlecallback" tabindex="-1">requestIdleCallback <a class="header-anchor" href="#requestidlecallback" aria-label="Permalink to &quot;requestIdleCallback&quot;">​</a></h2><p>动画的画面其实是由一帧一帧的静态图快速切换组成的，人眼的反应速度有限，所以当画面切换的够快，人眼看着就是连续的动画了。</p><p>对于人眼来说，当每秒切换60张图片时，就会认为是连贯的。所以主流的显示器是60hz，1s刷新60次，那么每<strong>16.7ms</strong>就需要刷新一次，浏览器就会自动适配这个频率，对应的就是前端页面每16.7ms需要渲染一次。</p><p><img src="`+n+'" alt="image"></p><p>页面每隔16.7ms才会渲染一次，那么在两次渲染的中间时间，就是浏览器的<strong>空闲时间</strong>，在这段空闲时间执行的任务，是不会阻塞到页面渲染的流畅性。</p><p>反之，如果大量的耗时任务在一个区间连续执行的话，下一帧将会排到很后面才能执行，看着页面就会出现掉帧的效果。</p><p><img src="'+e+`" alt="image"></p><p><code>requestIdleCallback</code> 就是浏览器提供给开发者来判断浏览器什么时候是<strong>空闲时间</strong>，什么时候是<strong>空闲时间结束</strong>，该进行渲染了。它会在浏览器的<strong>空闲时间</strong>来执行传给它的回调函数。如果指定了超时时间，则会在超时后的下一帧强制执行。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> id</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">requestIdleCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">deadline</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 当前帧剩余时间大于0，或任务已超时</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(deadline.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">timeRemaining</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> deadline.didTimeout) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // do something</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, { timeout: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> }) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指定超时时间</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// window.cancelIdleCallback(id) 与定时器类似，支持取消</span></span></code></pre></div><p><code>requestIdleCallback</code>在<code>Event Loop</code>的执行时机如下图所示，彩色方块代表一帧之内的渲染任务，当这些任务被执行完成后，剩余时间被认为是<strong>空闲时间</strong>:</p><p><img src="`+l+'" alt="image"></p><p><code>reuqestIdleCallback</code>和<code>requestAnimationFrame</code>的不同之处在于： <code>requestIdleCallack</code>是捡浏览器空闲时间来执行任务。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>如果浏览器一直处于非常忙碌的状态，<code>requestIdleCallback</code>注册的任务有可能永远不会执行，当然可以指定<code>timeout</code>来保证一定执行。</p></div><p>运气不好的是，<code>requestIdleCallback</code>的兼容性不太好，所以一般要做降级处理，通常使用<code>requestAnimationFrame</code>来做降级处理。</p><p>所以，一些低优先级但比较耗时的任务可以使用<code>requestIdleCallback</code>在浏览器不忙的时候来执行，最好是可以细分的一些任务。</p><p>因为发生在一帧的最后，此时页面布局已经完成，<strong>所以不建议在 <code>requestIdleCallback</code> 里再操作 DOM，这样会导致页面再次重绘</strong>。DOM 操作建议在 <code>requestAnimationFrame</code> 中进行。同时，操作 DOM 所需要的耗时是不确定的，因为会导致重新计算布局和视图的绘制，所以这类操作不具备可预测性。</p>',29),k=[p];function h(d,E,g,o,c,r){return a(),i("div",null,k)}const m=s(A,[["render",h]]);export{I as __pageData,m as default};
