# 联合类型和交叉类型
联合类型和交叉类型是组合类型的方式之一。

## 联合类型
联合类型表示一个值的类型可以是几个类型中的一个。一般用竖线 | 来分割不同的类型，所以`number | string | boolean`是一个可以是`number`，`string`，`boolean`的值的类型。

```ts
function padLeft(value: string, padding: string | number) {
  // ...
}
```

## 具有公共字段的联合
如果有一个联合类型的值，则只能访问联合中所有类型共有的成员。
```ts
interface Bird{
  fly():void;
  layEggs():void;
}

interface Fish{
  swim():void;
  layEggs():void
}

declare function getSmallPet():Fish|Bird;

let pet = getSmallPet()
pet.layEggs();

// 只有两种可能类型中的一种可用，这个调用用不到
pet.swim()
```

## 可区分的联合
使用联合的一种常用技术是使用字面量类型的单个字段，可以使用该字段来缩小Ts可能的当前类型。例如，可以创建一个包含三种类型的联合，这些类型具有一个共享字段。

```ts
type NetworkLoadingState = {
  state: "loading";
};

type NetworkFailedState = {
  state: "failed";
  code: number;
};

type NetworkSuccessState = {
  state: "success";
  response: {
    title: string;
    duration: number;
    summary: string;
  };
};

// 创建一个只代表上述类型之一的类型，但你还不确定它是哪个。
type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState;
```
上面的每个类型都有一个名为`state`的字段，然后它们也有自己的字段。并且鉴于`state`字段在每个类型都是通用的，这就保证了代码不需要存在检查即可安全访问。

有了`state`这个字面类型，就可以将`state`的值与相应的字符串进行比较，TS就知道当前使用的是哪种类型。

```ts
function logger(state: NetworkState): string {
  // 现在，TypeScript不知道state是三种可能类型中的哪一种。

  // 试图访问一个不是所有类型都共享的属性将引发一个错误
  state.code;

  // 通过选择state，TypeScript可以在代码流分析中缩小联合的范围
  switch (state.state) {
    case "loading":
      return "Downloading...";
    case "failed":
      // 这里的类型一定是NetworkFailedState，所以访问`code`字段是安全的。
      return `Error ${state.code} downloading`;
    case "success":
      return `Downloaded ${state.response.title} - ${state.response.summary}`;
  }
}
```
## 联合的穷尽性检查
如果希望在新增可区分联合的类型时，告诉我们相关的代码也需要新增一些逻辑。比如，接着上一个例子来说，新增一个`NetworkFromCachedState`到`NetworkState`，那么`logger`函数也应该被更新一些逻辑：
```ts
// @errors: 2366
type NetworkLoadingState = { state: "loading" };
type NetworkFailedState = { state: "failed"; code: number };
type NetworkSuccessState = {
  state: "success";
  response: {
    title: string;
    duration: number;
    summary: string;
  };
};
// ---cut---
type NetworkFromCachedState = {
  state: "from_cache";
  id: string;
  response: NetworkSuccessState["response"];
};

type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState
  | NetworkFromCachedState;

// 可以发现logger函数只处理了这三种类型，没有新增NetworkFromCachedState类型的相关处理
function logger(s: NetworkState) {
  switch (s.state) {
    case "loading":
      return "loading request";
    case "failed":
      return `failed with code ${s.code}`;
    case "success":
      return "got response";
  }
}

```
**推荐的做法是利用编译器用于检查穷尽性的never类型来检查代码**

```ts
// @errors: 2345
type NetworkLoadingState = { state: "loading" };
type NetworkFailedState = { state: "failed"; code: number };
type NetworkSuccessState = { state: "success" };
type NetworkFromCachedState = { state: "from_cache" };

type NetworkState =
  | NetworkLoadingState
  | NetworkFailedState
  | NetworkSuccessState
  | NetworkFromCachedState;
  
// ---cut---
function assertNever(x: never): never {
  throw new Error("Unexpected object: " + x);
}

function logger(s: NetworkState): string {
  switch (s.state) {
    case "loading":
      return "loading request";
    case "failed":
      return `failed with code ${s.code}`;
    case "success":
      return "got response";
    default:
      return assertNever(s);
  }
}
```
在这个例子中，`assertNever`检查s是否属于`never`类型——即不属于所有其他情况都被移除后剩下的类型，如果忘记了这个情况，那么s将会有一个实际的类型，而编译器会报类型错误。

## 交叉类型
交叉类型与联合类型密切相关，区别在于交叉类型将多个类型合并为一个。例如`Person & Serializable & Loggable` 是一种类型，它是`Person,Serializable,Loggle`的全部。意味着这种对象将拥有三种类型的所有成员。

```typescript
interface ErrorHandling {
  success: boolean;
  error?: { message: string };
}

interface ArtworksData {
  artworks: { title: string }[];
}

interface ArtistsData {
  artists: { name: string }[];
}

// 这些接口被组合后拥有一致的错误处理，和它们自己的数据

type ArtworksResponse = ArtworksData & ErrorHandling;
type ArtistsResponse = ArtistsData & ErrorHandling;

const handleArtistsResponse = (response: ArtistsResponse) => {
  if (response.error) {
    console.error(response.error.message);
    return;
  }

  console.log(response.artists);
};
```