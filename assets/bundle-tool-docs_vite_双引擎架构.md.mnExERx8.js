import{_ as s}from"./chunks/vite-cons-1.BUVwtt-p.js";import{_ as i,c as l,o as a,U as t}from"./chunks/framework.qUHj8-gn.js";const e="/assets/vite-cons-2.x3CJ1Alp.png",p="/assets/vite-cons-3.GdWiXxxW.png",n="/assets/vite-cons-4.lySqPPz9.png",o="/assets/vite-cons-5.-qLZLrGC.png",d="/assets/vite-cons-6.gsNdDipp.png",r="/assets/vite-cons-7.h_iPMkre.png",h="/assets/vite-cons-8.mBx1MeS_.png",T=JSON.parse('{"title":"双引擎架构","description":"","frontmatter":{},"headers":[],"relativePath":"bundle-tool-docs/vite/双引擎架构.md","filePath":"bundle-tool-docs/vite/双引擎架构.md","lastUpdated":1715491431000}'),u={name:"bundle-tool-docs/vite/双引擎架构.md"},c=t('<h1 id="双引擎架构" tabindex="-1">双引擎架构 <a class="header-anchor" href="#双引擎架构" aria-label="Permalink to &quot;双引擎架构&quot;">​</a></h1><p>Vite的底层深度使用了两个架构引擎：<strong>Esbuild</strong>和<strong>Rollup</strong></p><h2 id="架构图" tabindex="-1">架构图 <a class="header-anchor" href="#架构图" aria-label="Permalink to &quot;架构图&quot;">​</a></h2><p><img src="'+s+'" alt="image"></p><p>可以看出Vite不仅仅是开发阶段使用Esbuild和在生产环境使用Rollup这样的简单概念</p><h2 id="esbuild" tabindex="-1">Esbuild <a class="header-anchor" href="#esbuild" aria-label="Permalink to &quot;Esbuild&quot;">​</a></h2><p><strong>Esbuild</strong>是Vite的高性能的得力助手，在很多<strong>关键的构建阶段</strong>让Vite获得了非常不错的性能优异，如果使用传统的打包器/编译器完成，开发体验会下降一大截。</p><h3 id="esbuild作为bundle工具" tabindex="-1">Esbuild作为Bundle工具 <a class="header-anchor" href="#esbuild作为bundle工具" aria-label="Permalink to &quot;Esbuild作为Bundle工具&quot;">​</a></h3><p>Esbuild首先被用在了开发阶段的依赖预构建阶段 <img src="'+e+'" alt="image"> 一般来说，<code>node_modules</code>依赖的大小要么几百MB甚至上GB，会远超项目源代码，如果这些依赖直接选择在Vite中去使用，会出现一系列的问题，主要是ESM格式的兼容性问题和海量请求的问题，另外，还需要在应用启动前进行<strong>打包并且转换为ESM格式</strong></p><p>Vite之前使用Rollup来做这件事情，但是Esbuild的性能确实太强大了,后面选择了使用Esbuild <img src="'+p+'" alt="image"></p><p>当然哈,Esbuild也有一些小缺点，这里可以说一下：</p><ul><li>不支持降级到<code>ES5</code>的代码，意味着在低端浏览器会跑不起来</li><li>不支持<code>const enum</code>等语法，意味着单独使用这些语法在esbuild中会直接抛错</li><li>不提供操作打包产物的接口，像Rollup中灵活处理打包产物的能力（如renderChunk钩子），在Esbuild中完全没有</li><li>不支持自定义Code Splitting 策略。传统的 Webpack 和 Rollup 都提供了自定义拆包策略的API，而Esbuild并未提供，从而降级了拆包优化的灵活性</li></ul><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>虽然 Esbuild 拥有这些局限性，依然不妨碍 Vite 在<strong>开发阶段</strong>使用它成功启动项目并获得极致的<strong>性能提升</strong>，生产环境处于稳定性考虑当然是采用功能更加丰富，生态更加成熟的Rollup作为依赖打包工具。</p></div><h3 id="esbuild用于文件编译" tabindex="-1">Esbuild用于文件编译 <a class="header-anchor" href="#esbuild用于文件编译" aria-label="Permalink to &quot;Esbuild用于文件编译&quot;">​</a></h3><p>在依赖预构建阶段，Esbuild作为Bundler的角色存在。而在 TS/JS 单文件编译上面，Vite也使用过Esbuild进行语法转译，也就是将 Esbuild 作为 Transformer 来用、</p><p><img src="'+n+'" alt="image"></p><p>Esbuild 转译 TS 或者 JSX 的能力通过 Vite 插件提供，这个 Vite 插件在开发环境和生产环境都会执行</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vite已经将Esbuild的Transformer能力用到了生产环境。而且，对于低端浏览器场景，Vite仍然可以做到语法和Polyfill安全</p></div><p>这部分能力用于替换原先的 Babel 或者 TSC 的功能，因为Babel和TSC实在是太慢了,实在比不过Esbuild</p><p>Esbuild Transformer能带来巨大的性能提升，但其自身也有局限性，最大的局限性在于TS中的类型检查问题。这是因为Esbuild并没有实现TS的类型系统，在编译TS文件时仅仅只是抹掉了类型相关的代码，暂时没有能力实现类型检查。</p><p>所以一般在vite创建的默认工程脚本中，<code>vite build</code>之前会执行一下<code>tsc</code>命令</p><p>要解决类型问题，更推荐使用TS的编辑器插件。然后在开发阶段就能把问题早点暴露出来。</p><h3 id="esbuild-用于代码压缩" tabindex="-1">Esbuild 用于代码压缩 <a class="header-anchor" href="#esbuild-用于代码压缩" aria-label="Permalink to &quot;Esbuild 用于代码压缩&quot;">​</a></h3><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vite从2.6版本开始，就官宣默认使用Esbuild来进行生产环境的代码压缩，包括JS代码和CSS代码</p></div><p>在生产环境中Esbuild压缩器通过插件的形式融入到了Rollup的打包流的过程中：</p><p><img src="'+o+'" alt="image"></p><p>一样的，追求速度，因为Esbuild的压缩效率非常之高。</p><p>传统的方式是使用Terser这种JS开发的压缩器来实现，在Webpack或者Rollup中作为一个Plugin来完成代码打包后的压缩混淆工作，而且Terser比较慢，其原因在于：</p><ul><li>压缩这项工作涉及到了大量的AST操作，并且在传统的构建流程中，AST在各个工具之间无法共享，比如Terser就无法与Babel共享一个AST，造成了很多重复解析的过程。在 Esbuild 打包的过程会有几个关键环节，TS/JS 编译、模块打包、代码压缩，这几个环节在 Esbuild 都能够达到 AST 的复用，而在 webpack 中就做不到，因为各个环节设计的工具不一样，AST 标准也不一样。</li><li>JS本身是属于解释性和即时编译的语言，对于压缩这种CPU密集型的工作，其性能是远远比不上Golang这种语言的（Esbuild的底层是Golang实现的）</li></ul><p>可以看到像echarts这样大型库的压缩性能测试项目：</p><p><img src="'+d+`" alt="image"></p><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><p>Vite将Esbuild作为自己的性能利器，将Esbuild各个垂直方向的能力Bundler Transformer Minifier 利用的淋漓尽致，给Vite的高性能提供了有利的保证</p><h2 id="rollup" tabindex="-1">Rollup <a class="header-anchor" href="#rollup" aria-label="Permalink to &quot;Rollup&quot;">​</a></h2><p>Rollup是作用于Vite用作生产环境打包的核心工具，也直接决定了Vite的插件机制设计。</p><h3 id="生产环境bundle" tabindex="-1">生产环境Bundle <a class="header-anchor" href="#生产环境bundle" aria-label="Permalink to &quot;生产环境Bundle&quot;">​</a></h3><p>虽然ESM已经得到了众多浏览器的原生支持，但生产环境做到完全no-bundle也不行，会有网络性能问题。为了在生产环境中也去得到优秀的产物性能，Vite默认选择在生产环境中利用Rollup打包，基于Rollup本身成熟的打包能力进行扩展和优化</p><ul><li>CSS代码分割。如果某个异步模块中引入了一些CSS代码，Vite会自动将这些CSS抽离出来生产成一个单独的文件，提高线上产物的缓存复用率。不用Esbuild，是因为Esbuild没有提供自定义分割代码的能力</li><li>自动预加载。Vite会自动为入口chunk的依赖自动生成预加载标签<code>&lt;link rel=&quot;modulepreload&quot;&gt;</code> 比如</li></ul><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  &lt;!-- 省略其它内容 --&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  &lt;!-- 入口 chunk --&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;module&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> crossorigin</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/assets/index.250e0340.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  &lt;!--  自动预加载入口 chunk 所依赖的 chunk--&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;modulepreload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;/assets/vendor.293dca09.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这种适当的预加载的做法会让浏览器提前下载好资源，从而优化页面的性能。</p><ul><li>异步Chunk加载优化。在异步引入的Chunk中，通常会有一些共有的模块，如现在有两个异步引入的Chunk:A和B，而且两者有一个公共依赖C，如下图</li></ul><p><img src="`+r+'" alt="image"></p><p>一般情况下，Rollup打包之后，会先请求A，然后浏览器在加载A的过程中才去决定请求和加载C，但Vite在进行优化之后，请求A的同时会自动预加载C,通过优化Rollup产物依赖加载方式节省了不必要的网络开销，也就是<strong>不必要的网络延迟</strong></p><h3 id="兼容插件机制" tabindex="-1">兼容插件机制 <a class="header-anchor" href="#兼容插件机制" aria-label="Permalink to &quot;兼容插件机制&quot;">​</a></h3><p>无论是开发还是生产阶段，Vite都根植于Rollup的插件进制和生态</p><p><img src="'+h+'" alt="image"></p><p>在开发阶段，Vite自己实现了一个<code>Plugin Container</code>，来模拟Rollup调度各个Vite的插件的执行逻辑，可以说</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>Vite的插件写法都是完全兼容Rollup的，因此在生产环境中将所有的Vite插件传入Rollup是没问题的，但反过来说，Rollup插件却不一定能够完全兼容Vite</p></div>',48),k=[c];function E(b,g,m,_,S,y){return a(),l("div",null,k)}const V=i(u,[["render",E]]);export{T as __pageData,V as default};
