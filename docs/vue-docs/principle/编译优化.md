# 编译优化
V3在编译器将模版编译为渲染函数的过程中，尽最大可能的去提取关键信息，并且以此指导生成最优的代码。主要依据方案是尽可能地去区分动态内容和静态内容，并且根据这些内容去做不同的优化策略。

## 动态节点收集与布丁标志
### 传统Diff的问题
对于传统diff算法，当出现新旧子树的时候，总是会按照虚拟DOM的结构去 **一层一层** 地遍历。举个例子，假设有这样的模版：
```html
 <div id="foo">
   <p class="bar">{{ text }}</p>
 </div>
```
显然在这种情况下，唯一可能发生变化的就是 p 标签下的文本子节点的内容。也就是说，当响应式数据 text 的值发生变化时，真正高效的做法就是直接设置 p 标签的文本内容，按照之前所说的Diff算法，此时会走这样的Diff过程：
- 对比 div 节点，以及该节点的属性和子节点
- 对比 p 节点，以及该节点的属性和子节点
- 对比 p 节点的文本子节点，如果文本子节点的内容变化才做更新

通过编译手段，其实可以分析出很多关键信息，比如节点是否属于动态还是静态的，之所以在V2中虚拟Dom会产生额外的开销，根本原因就在于渲染器不知道这些节点的动/静态类型，所以在Diff时做不了相关的优化。

:::tip
V3在此处做了额外的优化，它将编译器编译时得到的关键信息“附着”在它生成的虚拟Dom上，这些信息会通过虚拟Dom传给渲染器，最终，渲染器会根据这些关键信息执行“快捷路径”，以此优化性能
:::

### Block 与 PatchFlags
观察下面这段模版和它对应的虚拟Dom：
```html
 <div>
   <div>foo</div>
   <p>{{ bar }}</p>
 </div>
```
```js
 const vnode = {
   tag: 'div',
   children: [
     { tag: 'div', children: 'foo' },
     { tag: 'p', children: ctx.bar },
   ]
 }
```
在传统的虚拟DOM中没有任何标志能够体现出节点的动态性，但是经过编译之后，编译器会将它提取的关键信息“附着”到虚拟DOM节点上，如下所示：
```js
 const vnode = {
   tag: 'div',
   children: [
     { tag: 'div', children: 'foo' },
     { tag: 'p', children: ctx.bar, patchFlag: 1 },  // 这是动态节点
   ]
 }
```
在描述P节点时，增加了一个额外的属性，即patchFlag，它是一个数字，只要虚拟节点存在该属性，那么就认为这是一个动态节点，这里的 patchFlag 属性就是所谓的补丁标志。

这个补丁标志可以理解为一系列数字标记，并且会根据数字值的不同从而赋予不同的含义，比如有这些意义：
- 数字1 ：代表节点有动态的 textContent
- 数字2 ：代表元素有动态的 class 绑定
- 数字3 :  代表元素有动态的 style 绑定
- 数字4 ：其他...

```js
const PatchFlags = {
   TEXT: 1, // 代表节点有动态的 textContent
   CLASS: 2, // 代表元素有动态的 class 绑定
   STYLE: 3, // 代表有动态的style绑定
   // 其他……
 }
```
有了这个信息之后，就可以将具有动态的节点，抽离成单独的数组`dynamicChildren`来记录缓存这些动态节点，并挂载到虚拟节点vnode上

```js
 const vnode = {
   tag: 'div',
   children: [
     { tag: 'div', children: 'foo' },
     { tag: 'p', children: ctx.bar, patchFlag: PatchFlags.TEXT }  // 这是动态节点
   ],
   // 将 children 中的动态节点提取到 dynamicChildren 数组中
   dynamicChildren: [
     // p 标签具有 patchFlag 属性，因此它是动态节点
     { tag: 'p', children: ctx.bar, patchFlag: PatchFlags.TEXT }
   ]
 }
```
这里引入一个新的概念 **Block** ，block 代表着一个拥有`dynamicChildren`属性的虚拟节点。本质上Block依然是一个虚拟节点
:::tip
Block 不仅能够收集它的直接动态子节点，更能收集所有动态**子代**节点
:::

有了**Block**这样的概念之后，渲染器的更新操作将会直接以 Block 为维度，也就是说当在更新一个 Block 时，会忽略掉虚拟节点的 children 数组，而是直接找到该虚拟节点的 `dynamicChildren` 数组，并只更新该数组中的动态节点。

这样就能完美实现跳过静态内容，而只更新动态内容的操作。同时，由于动态节点中对应的补丁标志，所以更新动态节点时更是做到了靶向更新。例如：当一个动态节点的 patchFlag 值为数字1时，知道它只存在动态的文本节点，所以只需要更新它的文本内容即可

实际上，所有模版的根节点都是一个Block节点，如下所示，非根节点不算是Block

```html
<template>
  <!-- 这个 div 标签是一个 Block -->
  <div>
    <!-- 这个 p 标签不是 Block，因为它不是根节点 -->
    <p>{{ bar }}</p>
  </div>
  <!-- 这个 h1 标签是一个 Block -->
  <h1>
    <!-- 这个 span 标签不是 Block，因为它不是根节点 -->
    <span :id="dynamicId"></span>
  </h1>
</template>
```
收集好动态节点之后，就可以更好的去做Diff算法优化了，在以前的节点比较中，会层层比较子节点的差异，这样做的效率就很低了，在有了`dynamicChildren`之后，其实可以直接对比动态节点，这样就可以做到只更新动态节点，跳过所有的静态节点。

动态节点集合能够使得渲染器在执行更新时跳过静态节点，但对于单个动态节点来说，由于它存在对应的补丁标志，因此框架还可以针对性地完成靶向更新

## Block树
在Block的定义中，要求了组件模板的根节点必须作为 Block 角色，从节点开始，所有的动态子代节点都会被收集到根节点的`dynamicChildren`数组中。

如果只有根节点是Block，显然是形不成Block树的，既然会形成Block树，这就意味着除了根节点之外，还需要有其他特殊节点来充当Block角色，比如`v-if`和`v-for`指令携带的节点

### v-if
比如在这样的一个例子中：
```html
 <div>
    <section v-if="foo">
        <p>{{ a }}</p>
    </section>
    <div v-else>
         <p>{{ a }}</p>
    </div>
</div>
```
那么对于两次根div收集到的Block如下：
```js
// 第一次block树
cosnt block = {
  tag: 'div',
  dynamicChildren: [
    { tag: 'p', children: ctx.a, patchFlags: 1 }
  ]
  // ...
}

// 第二次block树
 cosnt block = {
   tag: 'div',
   dynamicChildren: [
     { tag: 'p', children: ctx.a, patchFlags: 1 }
   ]
   // ...
 }
```
明显`v-if`对于的`section`标签和`div`标签也是差异变化，但在Block的记录中丢失了

### v-for
带有v-for指令的节点也会让虚拟DOM树变得不稳定
```html
<div>
  <p v-for="item in list">{{ item }}</p>
  <i>{{ foo }}</i>
  <i>{{ bar }}</i>
</div>
```
假设 list 是一个数组，在更新过程中，list数组的值由`[1,2]`变为`[1]`

前后两次的Block树的结构如下：
```js
 // 更新前
 const prevBlock = {
     tag: 'div',
     dynamicChildren: [
         { tag: 'p', children: 1, 1 /* TEXT */ },
     { tag: 'p', children: 2, 1 /* TEXT */ },
     { tag: 'i', children: ctx.foo, 1 /* TEXT */ },
     { tag: 'i', children: ctx.bar, 1 /* TEXT */ },
     ]
 }

 // 更新后
 const nextBlock = {
     tag: 'div',
     dynamicChildren: [
         { tag: 'p', children: item, 1 /* TEXT */ },
     { tag: 'i', children: ctx.foo, 1 /* TEXT */ },
     { tag: 'i', children: ctx.bar, 1 /* TEXT */ },
     ]
 }
```
更新前的Block树（prevBlock）中有四个动态节点，而更新后的Block树（nextBlock）中在只有三个动态节点，由于动态节点中存储的可能是不同层级的节点，所以不能做传统的Diff算法，因为传统的Diff算法要求必须在一个层级之下

## 静态提升
静态提升能够减少更新时创建虚拟DOM带来的性能开销和内存占用

假如有这么一个模版：
```html
 <div>
   <p>static text</p>
   <p>{{ title }}</p>
 </div>
```
在没有静态提升这一方案的情况下，它对应的渲染函数为：
```js
 function render() {
     return (openBlock(), createBlock('div', null, [
         createVNode('p', null, 'static text'),
         createVNode('p', null, ctx.title, 1 /* TEXT */)
       ]))
   }
```
在这段虚拟DOM的描述中存在一个静态P标签和一个动态的P标签，一旦响应式数据发生变化时，静态标签p的`createVNode`也会执行一遍，这就导致了额外的性能开销，而**静态提升**的作用在于把**静态节点的虚拟DOM创建提取到渲染函数的外面，然后再做引用，从而保证静态节点的虚拟DOM只会做一遍**

```js
 // 把静态节点提升到渲染函数之外
 const hoist1 = createVNode('p', null, 'text')

 function render() {
   return (openBlock(), createBlock('div', null, [
     hoist1, // 静态节点引用
     createVNode('p', null, ctx.title, 1 /* TEXT */)
   ]))
 }
```
:::tip
在Diff算法中的优化是直接复用静态节点的DOM结构，而渲染函数中是直接复用静态节点的虚拟DOM结构
:::

## 预字符串
对于静态提升的静态节点，还可以做进一步的预字符串化的操作。

比如这个模版

```html
<div>
  <p></p>
  <p></p>
  // ... 20 个 p 标签
  <p></p>
</div>
```
当出现大量的静态节点时，经过编译之后的代码如下：
```js
 cosnt hoist1 = createVNode('p', null, null, PatchFlags.HOISTED)
 cosnt hoist2 = createVNode('p', null, null, PatchFlags.HOISTED)
 // ... 20 个 hoistx 变量
 cosnt hoist20 = createVNode('p', null, null, PatchFlags.HOISTED)

 render() {
   return (openBlock(), createBlock('div', null, [
     hoist1, hoist2, /* ...20 个变量 */, hoist20
   ]))
 }
```
预字符串化可以避免这些大量的静态节点去做虚拟节点-->真实节点渲染的过程，而是直接字符串化之后直接`innerHTML`进行设置进去，这样减少了创建虚拟节点的性能开销

```js
 const hoistStatic = createStaticVNode('<p></p><p></p><p></p>...20 个...<p></p>')

 render() {
   return (openBlock(), createBlock('div', null, [
     hoistStatic
   ]))
 }
```
## v-once
```html
 <section>
   <div v-once>{{ foo }}</div>
 </section>
```
当一个元素被`v-once`指令标记时，这段模版会被编译为：
```js
function render(ctx, cache) {
  return (openBlock(), createBlock('div', null, [
    cache[1] || (cache[1] = createVNode("div", null, ctx.foo, 1 /* TEXT */))
  ]))
}
```
从编译结果可以发现，当被挂上`v-once`之后，该div对应的虚拟节点会被缓存到一个`cache`数组中。既然虚拟节点已经被缓存了，那么后续更新导致渲染函数重新执行时，就会有限读取缓存的内容，而不是去重新创建虚拟节点。

同时由于虚拟节点被缓存了，这还意味着更新前后的虚拟节点不会发生变化，因此也就不需要这些被缓存的虚拟节点参与到Diff操作中了

```js
 render(ctx, cache) {
   return (openBlock(), createBlock('div', null, [
     cache[1] || (
       setBlockTracking(-1), // 阻止这段 VNode 被 Block 收集
       cache[1] = h("div", null, ctx.foo, 1 /* TEXT */),
       setBlockTracking(1), // 恢复
       cache[1] // 整个表达式的值
     )
   ]))
 }
```
`setBlockTracking(-1)`调用用于暂停动态节点的收集。也就是说，使用v-once包裹的动态节点不会被父级Block收集，自然也不会参与到Diff操作中了

总结一下：
- v-once 避免组件更新时重新创建虚拟DOM所带来的性能开销，因为虚拟DOM已经被缓存
- 避免无用的Diff开销，因为被V-once标记的虚拟DOM树不会被Block节点收集