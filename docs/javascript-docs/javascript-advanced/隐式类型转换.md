# 隐式类型转换
类型的隐式转换往往容易被忽略，对于具体的场景往往是想当然的，从而容易造成产生一些非预期的结果，甚至是运行时异常。

## 模板字符串
 模版字符串可以是带**占位符**的字符串，并且可以声明是带有换行符的**多行**字符串

```js
let name = "javascript"

var message = `Hello!
    ${name}
`;
```
上面的占位符变量name自然需要转换成字符串类型。

一般的对象，如果能在原型链上溯到`Object.prototype`，那么就可以调用`toString()`实例函数。有的对象会重载这个函数，比如Date，甚至像 Number 的 toString 还带有一个参数，进行进制转换。

如果没有重载，就相当于：
```js
Object.prototype.toString.call(obj); // [object xxx]
```
但是在模版字符串中，并不是调用变量的`toString`方法，这样很不安全，毕竟变量可能不是广义上的对象(null,undefined)，而且 toString 也可以被重载为不返回字符串类型。

而在ECMAScript规范定义的一个内部函数了，叫做ToString。它的工作原理如下：

1.判断入参类型，遍历一遍所有基本类型：
- 如果是String，就不会转换，直接返回
- 如果是Symbol，抛出异常，除非调用Symbol实例的toString()方法，否则不能转换成字符串
- 如果是Undefined，就返回"undefined"
- 如果是Null，就返回"null"
- 如果是Boolean，就返回"true"或"false"
- 如果是Number或者BigInt，就转换成其10进制表示形式，但是也有可能输出"NaN"，"Infinite"和科学记数法

2.如果是非基本数据类型
将参数带入到`ToPrimitive(arg,string)`。并且`ToPrimitive(input[,preferredType])`用来将参数转换成基本数据类型。

通常来说，使用到 ToPrimitive 的场景，都是在参数已经被判定是 Object 的条件之下。

它的第二个参数`preferredType`是可选的，用来选择"string"或者"number"这两个值。`preferredtype`就是用来控制对象转换为哪种基本类型。

`ToPrimitive`会先尝试取对象的一个方法，叫做`[Symbol.toPrimitive]`。这个方法存在于对象本身或者原型链都可以，像下面这两种声明方式都是允许的：
```js
var foo = {
    [Symbol.toPrimitive](hint: "default" | "number" | "string") {}
};

class Foo {
    [Symbol.toPrimitive](hint: "default" | "number" | "string") {}
}
```
这个参数`hint`事实上就是`preferredType`：
```js
hint = preferredType ?? "default"
```
因此，`Symbol.toPrimitive`的引入相当于把内部的方法`ToPrimitive`外包给了开发者去定义。`ToString`在调用`ToPrimitive`的时候，`preferredType`用的是"string"，因此下面的`hint`就是"string"。
```js
var foo = {
    [Symbol.toPrimitive](hint) {
        switch(hint) {
            case "number":
                return 67;
            case "string":
            default:
                return "foo"
        }
    }
};

console.log(`${foo}`); // “foo”
```
:::tip
`[Symbol.toPrimitive]`必须返回一个基础类型，如果不是的话，就会抛出异常。在`ToString`的场景下，返回的值就会递归到`ToString`，确保生成一个字符串
:::
如果对象没有`[Symbol.toPrimitive]`方法，就会回退到没有ES6之前的逻辑。在这个逻辑中，`preferredType`代表的是number，即ToPrimitive倾向于返回的是数字类型。

但是没有`[Symbol.toPrimitive]`的话，为什么还要设置一个`preferredType`呢？是因为这里就调用了另一个内部方法叫做`OrdinaryToPrimitive(0,preferredType)`

在`OrdinaryToPrimitive`中，基本逻辑如下：
- 如果 `preferredType` 等于"string"，那么就会尝试依次调用对象的 toString 和 valueOf 方法，如果 toString存在就不会调用 valueOf；
- 如果 `preferredType` 等于"number"，那么就会尝试依次调用对象的valueOf和toString方法，如果valueOf存在就不会调用toString
- 如果返回值不是基础类型，就抛出异常

后都是尝试使用 toString 和 valueOf 的返回值作为基础类型，只不过根据preferredType的值不同，调用顺序不同而已。

对于一般的对象来说，其 toString 和 valueOf 都会上溯到原型对象的`Object.prototype`中。

对于`Object.prototype.toString`的逻辑：
- 如果对象定义了`Symbol.toStringTag`属性，设为tag，返回`[object ${tag}]`
- 根据类型不同，返回`[object Undefined/Null/Array/Arguments/Function/Error/Boolean/Number/String/Date/RegExp/Object]`

这个方法几乎能够分辨所有日常开发中的类型，比`typeof`还好用。但是作为对象转换字符串的结果，只不过返回值比较偏死板。

而且事实上，大多数内置的对象类型，根本走不到`Object.prototype.toString`，因为它们都对toString都进行了重载，比如Number，BigInt，Array，Error，Symbol，RegExp，Boolean，Date。

另外像JSON，Math，Reflect，Map，Set，Symbol，WeakMap，WeakRef，Promise等很多对象。还有浏览器环境的window和document，也都定义了自己的`[Symbol.toStringTag]`属性，因此在Object.prototype.toString下也会有定制化的返回结果，比如：
```js
Object.prototype.toString.call(Math) //'[object Math]'
Object.prototype.toString.call(new Map()) //'[object Map]'
Object.prototype.toString.call(window) //'[object Window]'
Object.prototype.toString.call(document)// '[object HTMLDocument]'
```
相比之下，`Object.prototype.valueOf`就简单多了，就返回对象自身。不过像Date，Symbol，Number，String，Boolean 都重载了这个函数，返回的都是基本数据类型，比如：
```js
new Date().valueOf() // 1686978276206
Object(Symbol('x')).valueOf() // symbol(x) 
new Number(56).valueOf() // 56
new String().valueOf() // ''
new Boolean(true).valueOf() // true
```
最后用一张辅助图来讲解这个关系：
![image](./assets/string%E7%B1%BB%E5%9E%8B%E9%9A%90%E5%BC%8F%E8%BD%AC%E6%8D%A2.jpg)

把它带入到`ToString`中，就可以推理出**模版字符串**之下，想要控制一个对象的字符串表示形式，可以通过这么这几种方式：
- 定义`[Symbol.toPrimitive]()`方法。
- 重载`toString`方法。
- 如果对象（包括原型链）没有toString，那么定义`[Symbol.toStringTag]`也能控制，只不过只能是`[object ${tag}]`的格式。
- 如果对象（包括原型链）没有toString，那么定义`valueOf`同样有效。
:::tip
后面两者的情况比较偏，需要`Object.create(null)`来断开`Object.prototype`的关系
:::
以上就是模版字符串中的变量隐式转换逻辑了，还有一种把变量转换成字符串的方法就是利用String的强制转换：
```js
String(vari)
```
这个情况比较简单：
- 如果入参是Symbol类型，单独走一个`SymbolDescriptiveString()`方法，生成类似`Symbol(xxx)`的格式
- 其他类型统一走`ToString`

## 加法运算
假设计算`A+B`，操作如下：

首先，两者都转换为 Primitive 类型，`a=ToPrimitive(A)`，`b=ToPrimitive(B)`，注意没有传入`preferredType`参数，如果定义了`[Symbol.toPrimitive]`函数，参数`hint`就会是**default**；如果没有定义`[Symbol.toPromitive]`，`preferredType`就默认是**number**，从而会尝试调用valueOf，没有才会调用toString。

可以如下验证：
```js
var A = {
    [Symbol.toPrimitive](hint) {
        console.log(hint); // "default"
        return 1;
    }
};

var B = 1;

A + B; // 2
```
这一段代码可以证明`preferredType`默认为"number"，进而优先调用了`valueOf`:
```js
var A = {
    valueOf() {
        console.log('valueOf'); // valueOf
        return 1;
    },
    toString() {
        console.log('toString'); //
        return '1';
    }
};

var B = 1;

A + B; // 2
```
在得到了 a 和 b这两个 Primitive 类型之后，判断它们之中有没有 String 类型，如果有，就可以认为这个运算属于字符串拼接，把 a 和 b 传入`ToString`

如果 a 和 b 之间任意一个是 Symbol 类型，那么加法执行到`ToString`这一步必会报错。

如果 a 和 b 都不是 String，那么这个加法就属于数学运算，它们两个要继续转换成数字。需要特别强调的是，数字也分为 Number 和 BigInt，这两者是不可相加的。

## 相等判断
`===` 和 `==` 的区别不再过度解释。

不过`==`在比较不同的类型数据的时候，是可能返回true的，因此存在很多特例

第一步☝️，判断A和B的类型，如果相同，等价于`===`。

如果 A 和 B 一个null，一个是 undefined，那么返回true，即`null == undefined`；特例就是如果其中一个是`document.all`，另一个是 null 或者 undefined，也返回true。

如果 A 和 B，一个是String，一个是Number，那么把String传入`toNumber()`，也就是说，**字符串和数字比较，把字符串转换成数字，而不是把数字转换成字符串**

```js
15 == '0xF' // true
3 == '0b11' // true
```
再一个是String，一个是BigInt的情况下，也是同样的的操作，都是String被替换
继续，如果A和B有一方是Boolean，那么就将它转换为数字，结果无非就是1或者0，然后继续比较：
```js
1 == true
0 == false
'0x1' == true
```
如果A和B有一方是Object，那么就会把这个对象做`ToPrimitive`转换，再继续递归比较。必须有一方是Object，如果双方都是，又走到第一步去了
```js
var A = {
    valueOf() {
        return 1;
    },
};

var B = 1;

console.log(A == B); // true
```
最后，如果双方分别是Number和BigInt，那么就比较它们的数值是否是相等的。
其他情况，都返回false。

总结一下：
- Object在做比较时，总会转换为Primitive
- Boolean在比较时，总会转换为Number
- Undefined和Null只有互相比较的时候返回true，和其他任意类型都返回false，因此可以去掉Null，Undefined
- Symbol 和任意类型比较都返回 false