# 装饰器 Decorators
随着TypeScript和ES6中引入了类，在一些场景下需要额外的特性来支持标注或修改改类及其成员。

装饰器Decorators在类的声明上通过元编程与法添加标注提供了一种方式。

前提是需要在`tsconfig.json`里去启用`experimentalDecorators`编译器选项:
```JSON
{
  "compilerOptions":{
    "target":"ES5",
    "experimentalDecorators":true
  }
}
```

## 装饰器
**装饰器** 是一种特殊类型的声明，它能够被附加到类声明，方法，访问符，属性或参数上。

装饰器使用`@expression`这种形式，`expression`求值后必须为一个函数，它会在运行时被调用，被装饰的声明信息做为参数传入。

例如，有一个`@sealed`装饰器，那么就应该这样去定义`sealed`函数：
```ts
function sealed(target) {
    // do something with "target" ...
}
```

### 装饰器工厂
如果要定制一个修饰器应用到一个声明上，那么就必须写一个装饰器工厂函数。**装饰器工厂**就是一个简单的函数，它返回一个表达式，来供装饰器在运行时调用。

可以通过下面的方式来写一个装饰器工厂函数：
```ts
function color(value: string) { // 这是一个装饰器工厂
    return function (target) { //  这是装饰器
        // do something with "target" and "value"...
    }
}
```
### 装饰器组合
多个装饰器可以同时应用到一个声明上，就像下面：
- 书写到同一行上：
```
@f @g x
```
- 书写到多行上:
```
@f
@g
x
```
在TypeScript中，当多个装饰器应用在一个声明上时会进行如下步骤的操作：
- 由上到下依次对装饰器表达式求值
- 求值的结果会被当作函数，由下到上一次调用
例子：
```ts
function f() {
    console.log("f(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("f(): called");
    }
}

function g() {
    console.log("g(): evaluated");
    return function (target, propertyKey: string, descriptor: PropertyDescriptor) {
        console.log("g(): called");
    }
}

class C {
    @f()
    @g()
    method() {}
}
// 其打印结果如下：
// f():evaluated
// g():evaluated
// g():called
// f():called
```
### 类装饰器
**类装饰器** 在类声明之前被声明，需要紧靠着类声明。

类装饰器应用在类构造函数，可以用于监视，修改或替换类的构造器。

类装饰器不能用在声明文件中.d.ts，也不能用在任何外部上下文中（比如`declare`

类装饰器表达式会在运行时当作函数被调用，类的构造函数作为其唯一的参数。如果类装饰器返回了值，它会使用提供的构造函数来替换类的声明。

:::tip
如果要返回一个新的构造函数，必须注意处理好原来的原型链
:::

例如：
```ts
@sealed
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        return "Hello, " + this.greeting;
    }
}
```
定义一个装饰器：
```ts
function sealed(constructor: Function) {
    Object.seal(constructor);
    Object.seal(constructor.prototype);
}
// 当 @sealed 被执行的时候，它将密封此类的构造函数和原型
```
还有一个重载构造器的例子：
```ts
function classDecorator<T extends {new(...args:any[]):{}}>(constructor:T) {
    return class extends constructor {
        newProperty = "new property";
        hello = "override";
    }
}

@classDecorator
class Greeter {
    property = "property";
    hello: string;
    constructor(m: string) {
        this.hello = m;
    }
}

console.log(new Greeter("world"));
```
### 方法装饰器
方法装饰器在一个方法的声明之前使用。它会被应用到方法的**属性描述符**上，可以用于监视，修改或替换方法定义。

方法装饰器表达式，会在运行时当作函数被调用，需要传入下面三个参数：
- 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象
- 成员的名称
- 成员的**属性描述符**

如果方法装饰器返回一个值，它会被用作方法的**属性描述符**

例子：
```ts
class Greeter {
    greeting: string;
    constructor(message: string) {
        this.greeting = message;
    }
    // 使用enumberable装饰器
    @enumerable(false)
    greet() {
        return "Hello, " + this.greeting;
    }
}
```
可以使用下面的函数声明来定义`@enumerable`装饰器，当`@enumerable(false)`被调用时，它会修改属性描述符的`enumberable`属性
```ts
function enumerable(value: boolean) {
    return 
    function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.enumerable = value;
    };
}
```

### 访问器装饰器
访问器装饰器声明在一个访问器的声明之前，需要紧靠在访问器声明。访问器装饰器应用于访问器的**属性描述符**，并且可以用于监视，修改或替换一个访问器的定义。

:::tip
TypeScript 不允许同时装饰一个成员的get和set访问器。取而代之的是，一个成员的所有装饰的必须应用在文档顺序的第一个访问器上。因为装饰器应用于一个属性描述符时，它联合了get和set访问器，而不是分开声明的。
:::

访问器装饰器表达式会在运行时当作函数被调用，传入了下列3个参数：
- 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象
- 成员的名字
- 成员的**属性描述符**

如果访问器装饰器返回一个值，它会被用作方法的**属性描述符**

例子：
```ts
class Point {
    private _x: number;
    private _y: number;
    constructor(x: number, y: number) {
        this._x = x;
        this._y = y;
    }

    @configurable(false)
    get x() { return this._x; }

    @configurable(false)
    get y() { return this._y; }
}
```
可以通过如下函数的声明来定义`@configurable`装饰器：
```ts
function configurable(value: boolean) {
    return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
        descriptor.configurable = value;
    };
}
```
### 属性装饰器
属性装饰器需要紧靠在属性声明之前。

属性装饰器表达式会在运行时当作函数被调用，传入下面两个参数：
- 对于静态成员来说是类的构造函数，对于实例成员是类的原型对象
- 成员的名称
:::tip
属性描述符只能用于监视类中是否声明了某个名字的属性
:::
可以用其来记录这个属性的元数据，如下所示：
```ts
class Greeter {
    @format("Hello, %s")
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }
    greet() {
        let formatString = getFormat(this, "greeting");
        return formatString.replace("%s", this.greeting);
    }
}
```
然后定义`@format`装饰器和`getFormat`函数
```ts
import "reflect-metadata";

const formatMetadataKey = Symbol("format");

function format(formatString: string) {
    return Reflect.metadata(formatMetadataKey, formatString);
}

function getFormat(target: any, propertyKey: string) {
    return Reflect.getMetadata(formatMetadataKey, target, propertyKey);
}
```
这个`@format("Hello,%s")`装饰器是个**装饰器工厂**。当`@format("Hello, %s")`被调用时，它添加一条这个属性的元数据，通过`reflect-metadata`库里的`Reflect.metadata`函数。当`getFormat`被调用时，它读取格式的元数据。

### 参数装饰器
参数装饰器表达式会在运行时当作函数被调用，传入下面三个参数：
- 对于静态成员来说是类的构造函数，对于实例成员来说是类的原型对象
- 成员的名字
- 参数在函数参数列表中的索引
:::tip
参数装饰器只能用于监视一个方法的参数是否被传入
:::
参数装饰器的返回值会被忽略
```ts
class Greeter {
    greeting: string;

    constructor(message: string) {
        this.greeting = message;
    }

    @validate
    greet(@required name: string) {
        return "Hello " + name + ", " + this.greeting;
    }
}
```
定义两个装饰器`@required`和`@validate`
```ts
import "reflect-metadata";

const requiredMetadataKey = Symbol("required");

function required(target: Object, propertyKey: string | symbol, parameterIndex: number) {
    let existingRequiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyKey) || [];
    existingRequiredParameters.push(parameterIndex);
    Reflect.defineMetadata(requiredMetadataKey, existingRequiredParameters, target, propertyKey);
}

function validate(target: any, propertyName: string, descriptor: TypedPropertyDescriptor<Function>) {
    let method = descriptor.value;
    descriptor.value = function () {
        let requiredParameters: number[] = Reflect.getOwnMetadata(requiredMetadataKey, target, propertyName);
        if (requiredParameters) {
            for (let parameterIndex of requiredParameters) {
                if (parameterIndex >= arguments.length || arguments[parameterIndex] === undefined) {
                    throw new Error("Missing required argument.");
                }
            }
        }

        return method.apply(this, arguments);
    }
}
```
`@required`装饰器添加了元数据实体把参数标记为必需的。`@validate`装饰器把`great`方法包裹在一个函数里在调用原先的函数前验证函数参数。