# 对象的遍历

属性和原型链操作是对象操作中非常关键的组成部分，但只有遍历才能实现对象的完整访问能力。

单纯依靠暴露出来的属性访问语法和API，实际上是无法遍历对象的，只有引擎的底层才知道对象的结构。对象的内部属性中有这么一个`[[OwnPropertyKeys]]`，可以理解为一个数组，记录了对象的所有Key。

对象的遍历实际上是对键的遍历，因此离不开对`[[OwnPropertyKeys]]`的访问

可以把对象的遍历需求分为4个层次：

![image](./assets/%E5%AF%B9%E8%B1%A1%E9%81%8D%E5%8E%86%E9%80%BB%E8%BE%91.png)

## 遍历对象自身的可枚举数据

`Object.keys`，`Object.value`，`Object.entries` 是遍历对象自身属性的常用方法。但原型链上的属性是不会被纳入最终结果的。

```js
const obj = Object.create(
// 原型链不会被遍历
{age:12},
{
  name:{
    value:'foo',
    enumerable:true
  }
})

Object.keys(obj) // ["name"]
```
这三个函数的筛选逻辑本质是一样的，内部都是调用了一个`EnumerableOwnProperties()`的内部方法，只不过输出的数据不同，一个是所有的键，一个是所有的值，最后一个是键值。

这三个方法只能遍历到**可枚举**的属性，要使得某个键不出现在结果中，设置`enumerable`为 false

```js
const obj = Object.create(null,{
    name:{
        value:'foo',
        enumerable:true
    },
    age:{
        value:'foo',
        enumerable:false
    },
    [Symbol('job')]:{
        value:'teacher',
        enumerable:true
    }
})
 console.log(Object.keys(obj)) //["name"]
```
同时，它遍历不到`Symbol`类型的键

一句话：**Object.keys / values / entries 只会遍历出对象自身的，可枚举的，以字符串类型为键的属性。**

## 遍历对象自身的所有数据

等价于获取`[[OwnPropertyKeys]]`的内容

`Object.getOwnPropertyNames`可以用来获取其中的字符串键，`Object.getOwnPropertySymbols`用来获取其中的`Symbol`键，就相当于获取到`[[OwnPropertyKeys]]`完整内容。

```js
const obj = Object.create(null,{
    name:{
        value:'foo',
        enumerable:true
    },
    age:{
        value:'foo',
        enumerable:false
    },
    [Symbol('job')]:{
        value:'teacher',
        enumerable:true
    }
})

 console.log([
    ...Object.getOwnPropertyNames(obj),
    ...Object.getOwnPropertySymbols(obj)
 ]) // ["name","age","Symbol('job')"]
```
之所以要分为两个API，这是因为历史遗留问题，设计String的时候还没Symbol呢。

ES6之后，可以引入`Reflect.ownKeys`函数，它是实打实的返回就是`[[OwnPropertyKeys]]`的完整内容

```js
console.log( Reflect.ownKeys(obj) ) // ["name","age","Symbol('job')"]
```

## 遍历对象及原型链的所有可枚举数据
能够实现遍历原型链的现成方法，目前只有`for...in`一种，然而，它一是只能遍历可枚举属性，二是只能遍历字符串键的属性

```js
function initData(){
    return {
        name:'await',
        server_ip:"47.95.70.43"
    }
}

const pro = Object.create(null,{
  // 原型链上的属性会被遍历
    'pro-key':{
        value:'pro-value',
        writable:true,
        enumerable:true,
        configurable:true
    }
})

const ins = {
  // 会遍历到
    a:{
        value:'a',
        writable:false,
        enumerable:true,
        configurable:true
    },
  // 不可枚举遍历不到
    b:{
        value:'b',
        writable:true,
        enumerable:false,
        configurable:true
    },
  // Symbol也遍历不到
    [Symbol('b')]:{
        value:'Symbol-b',
        writable:false,
        enumerable:true,
        configurable:true
    },
}

const target = Object.create(pro,ins)

for(let key in target){
    console.log(key,target[key]) // a pro-key
}
```
如果想把`Symbol`包`括进来，甚至一些不可枚举的属性，只能自己手写代码了：
```js
function getExtendedKeys(obj){
    const visitedKeys = new Set()
    let current = obj

    while(current){
        const keys = Reflect.ownKeys(current)
        keys.forEach(k => visitedKeys.add(k))
        current = Object.getPrototypeOf(current)
    }

    return Array.from(visitedKeys)
}
```
其核心原理仍然是原型链遍历和属性遍历，幸运的是，现在有了`for...of`，真正实现了突破对象属性圈子的能力。

| 遍历方法 | 自身string属性 | 自身Symbol属性 | 原型上的属性 | 不可枚举属性 |
|-------|-------|-------|-------|-------|
| for...in | ✔ | ❌ | ✔ | ❌ |
| Object.keys/values/entries | ✔ | ❌ | ❌  | ❌ |
| Object.getOwnPropertyNames | ✔ | ❌ | ❌ | ✔ |
| Object.getOwnPropertySymbols | ❌ | ✔ | ✔ | ❌ |
| Reflect.ownKeys | ✔ | ✔ | ❌ | ✔|

:::tip 记住两个总要特征
1. 只有`for...in`能遍历到原型链上的属性；2. 带有`own`的都可以遍历到不可枚举
:::

## 完全自定义遍历数据
`for...of`不绑定任何的对象属性。每次遍历出什么数据，完全是自定义的。迭代器**iterator**正是`for...of`工作原理的本质所在。

### 迭代器？
可以认为迭代器就是一个interface，实现了这个Interface的对象，都可以被`for...of`消费。

有多种方式可以实现迭代器。

- 利用生成器函数，生成器函数始终返回一个迭代器对象
```js
function *range(start,end){
    for(let i = start ; i<=end; ++i){
        yield i
    }
}

for(const i of range(3,6)){
    console.log(i,'i') // 3,4,5,6
}
```
迭代器可以不通过`for...of`调用，它主要就包含一个`next`函数，返回的格式为：
```js
{
  value?:any;
  done?:boolean;
}
```
所谓遍历过程，本质就是一直调用`next`函数，直到`done`为true:
```js
let it = range(3,6), value, done

while(1){
  const ret = it.next()
  done = ret.done
  value = ret.value
  if(done) break;
}
```
- Symbol定义：实现一个`Symbol.iterator`，定义了这个键的对象，且值为一个生成器，那么这个对象就可以被遍历：
```js
class Range{
    constructor(start,end){
        this.start = start
        this.end = end
    }
    *[Symbol.iterator](){
        for(let i = this.start;i<=this.end;i++){
            yield i;
        }
    }
}
```
:::tip
之所以字符串，数组，Map，Set都可以在for...of中使用，就是因为它们在原型上都定义了`[Symbol.iterator]`属性
:::

- 遵循协议：去实现一个next方法和`[Symbol.iterator]()`接口
```js
function createRange(start,end){
    let current = start
    return {
        next(){
            const nextValue = current++
            return {
                value:nextValue,
                done:nextValue > end
            }
        },
        [Symbol.iterator](){
            return this
        }
    }
}
```
那么这三种迭代器，适合不同的场景：
- 第一种，生成器函数，适合简单的入参的，无额外数据字段的场景
- 二种，对象，适合需要进一步封装额外数据，增加内聚性的场景
- 第三种，迭代器模拟，是第二种的变种，适合不想用生成器的场景

### 异步遍历
下面这段代码不算异步遍历：
```js
for(const item of datas){
  await Promise.resolve(item).then(...)
}
```
事实上这其实是同步迭代数据，最后异步做结果处理。读取本质不是异步而是同步的。

实现方式可以通过异步递归来实现：
```js
class AsyncProducer{
    constructor(size){
        this.current = size
    }

    async produce(){
        return this.current--
    }
}

const producer = new AsyncProducer(5)

async function process(){
    const num = await producer.produce()

    if(num === 0) return

    await process()
}

process().finally(()=>console.log('all done'))
```
这样的代码实现并不是特别优雅，更好的方式是使用异步迭代语法：`for await...of`

`await`字样代表其必须在一个异步函数内部才能运行，而且与`Promise`脱不开关系，是`for...of`的超集。
```js
for await(const num of [1,2,3]){
	console.log(num) // 1 2 3
}
```
`for await ... of`会把迭代器返回的值用`Promise`包装一下，然后`resolve`的方式暴露出去。
这样就可以讲`Symbol.iterartor`改变成`Symbol.asyncIterator`