# 资源懒加载
前端体验优化的核心：**精简页面内容**

再多优化，都比不上从根源上精简页面的内容，减少加载的资源。所以为前端工程精简加载资源体积和资源数量的最佳解决方案：**懒加载各类资源**

**资源懒加载**一般应用于需要加载外部资源的元素，例如`<img>`，`<video>`，`<iframe>`，`<picture>`等，当懒加载目标元素在视口外时，**不加载**对应的资源。目标元素**接近或进入**视口时，才触发加载资源。

## 三类资源懒加载方案
以`<img>`元素为例，3类资源懒加载的核心原理与是实现，分别是：
- 监听滚动事件方案
- 浏览器 Intersection Observer API方案
- 浏览器原生懒加载方案

### 监听滚动事件方案
第一种实现方案是通过监听浏览器页面滚动事件`scroll`，动态计算视口内元素位置，从而判断懒加载目标元素，触发资源加载。

以图片元素懒加载为例，需要监听页面滚动事件，并计算出每张图片与视口顶部的相对距离。如果图片在视口内，就该加载图片，否则就不加载。

代码示例：
```js
// 1. 获取所有需要懒加载的图片元素
const lazyloadImages = document.querySelectorAll('[data-lazyload]');

// 2. 监听页面滚动事件
window.addEventListener('scroll', () => {
  lazyloadImages.forEach(img => {
    if (img.getAttribute('data-loaded')) {
      return;
    }
    // 3.  获取图片与视口顶部的相对距离
    const topPos = img.getBoundingClientRect().top;
    // 4. 与 视口高度（window.innerHeight）对比，判断是否在视口内
    if (topPos < window.innerHeight) {
      // 5. 如果图片在当前视口内，就加载该图片
      img.src = img.getAttribute('data-src');
      img.setAttribute('data-loaded', true)
    }
  });
});
```
对应的HTML代码是：
```html
<img data-lazyload data-src="/example-image.jpg" />
```
在这段代码中，首先获取所有需要懒加载的图片元素，通过`querySelectorAll`获取带有指定的**懒加载标记属性**`data-lazyload`的元素引用，这些图片初始化时没有设置`src`值，而真正的懒加载目标图片URL则保存在`data-src`属性中，这样就能实现初始化暂不加载图片，由代码逻辑控制图片何时加载。

监听页面滚动事件`window.addEventListener('scroll')`，在滚动事件的回调中，遍历所有需要懒加载的图片元素`lazyloadImages.forEach`

对于每个图片元素，首先检查其`data-loaded`属性是否为`true`，如果是，则说明已经加载过了，那么跳过这个元素

如果没有加载过这个游戏，就通过`getBoundingClientRect()`方法获取该图片距离视口viewport顶部的位置，并通过和当前视口高度`window.innerHeight`对比，判断该图片当前是否在视口内，即图片与视口顶部的距离，是否小于当前视口的高度。

最后，如果图片在视口内，就该图片的`src`属性设置为`data-src`属性的值，从而触发图片资源加载，并将`data-loaded`属性设置为`true`，表示该图片已经加载过了。

这样实现了对图片类资源的懒加载，初始化时暂不加载图片资源，减少加载资源数量和体积，提高初始化时渲染性能，当图片进入浏览器视口时，再真正触发加载。

实际应用时，应该对这一方案做更多细节上的优化：
- 设置图片默认的宽高，以避免懒加载完成后，页面高度变化，被判断为意外布局变化，影响CLS评分
- 添加图片未加载占位符和加载中动画，来改善用户等待加载时的视觉和体验
- 计算位置，判断目标元素是否出现在视口时，还要考虑水平方向上的页面滚动位置，计算`getBoundingClientRect()`返回的`top,bottom,left,right`4个方向相对视口位置
- 对`scroll`事件添加节流优先，降低触发回调函数的频率，避免影响页面渲染的FPS

依赖`scroll`事件，容易对页面渲染性能产生负面影响，这也是监听滚动事件方案的主要痛点

过低的`scroll`事件回调触发频率，会导致懒加载触发不灵敏

而过高的`scroll`事件回调触发频率，又会因为大量计算，导致JS执行耗时太长，阻塞了UI绘制，产生页面卡顿

为了解决这些痛点，浏览器平台的[Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)诞生了

### Intersection Observe 方案
第二类懒加载方案是使用[Intersection Observer API](https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API)，该API可用于监听元素距离视口位置，当元素进入视口时，触发指定回调函数，从而实现懒加载，无限滚动等功能。

这个API可以省略编写代码计算元素相对位置的逻辑，解决**JS监听滚动事件实现懒加载专案** 需要频繁计算元素位置的痛点，有助于提高懒加载的性能表现和用户体验

```js
// 创建 IntersectionObserver 实例
const observer = new IntersectionObserver(entries => {
  // 遍历所有观察的元素
  entries.forEach(entry => {
    // 如果该元素进入了视口，就加载该元素的图片
    if (entry.isIntersecting) {
      const img = entry.target;
      img.src = img.dataset.src;
      observer.unobserve(img);
    }
  });
});

const lazyImages = document.querySelectorAll('img.lazy');

// 开始监听所有需要懒加载的图片元素
lazyImages.forEach(img => {
  observer.observe(img);
});
```

在上述代码中，首先创建了一个`IntersectionObserver`实例`observer`，该实例可用于**监听多个元素**是否进入视口。

然后，获取所有需要懒加载的图片元素，分别调用`observe()`方法，开始监听每个图片元素

当某一个图片元素进入了视口时，创建实例时传入的第一个参数 —— 回调函数就会被触发

进入视口的每一个图片元素，都会生成一条重叠记录数据
**（IntersectionObserverEntry）**，成为回调函数第一个参数entries中的一个元素

**重叠记录数据（IntersectionObserverEntry）** 主要包含以下数据：

- `target`:对象值，监听目标元素的引用
- `isIntersecting`: 布尔值，表示目标元素是否和视口重叠，是否进入了视口

重叠记录数据示例:
```json
{
    boundingClientRect: DOMRectReadOnly {x: 107.1875, y: -172.8125, width: 300.015625, height: 500, top: -172.8125, …}
    intersectionRatio: 0.4854249954223633
    intersectionRect: DOMRectReadOnly {x: 107.1875, y: 84.46875, width: 300.015625, height: 242.71875, top: 84.46875, …}
    isIntersecting: false
    isVisible: false
    rootBounds: DOMRectReadOnly {x: 8, y: 84.46875, width: 483.203125, height: 583.21875, top: 84.46875, …}
    target: div.box
    time: 839005.1999998093
}
```
在回调函数中，我们可以遍历所有**重叠记录数据**，如果某一条**重叠记录数据**的 `isIntersecting` 属性为 `true`，就表示这条记录对应的元素进入了视口，可以通过`target`属性获取元素引用。

此时就可以将该元素的`src`属性设置为`data-src` 属性的值，触发`src`对应图片资源加载，实现懒加载的逻辑

最后，因为这个元素已经触发过了加载，还可以使用`unobserve()`方法停止观察该元素，避免重复触发回调函数，同时节省内存资源

:::tip
拓展知识：`IntersectionObserver`不仅可以监听**元素**和**视口**的重叠关系，还可以在初始化实例时，传入第二个参数`options`：
- 指定`root`，值为监视目标元素**父元素**的引用，从而监视任意父子元素的重叠关系。但前提是父元素必须是可以滚动的，例如设置了CSS样式：`overflow:scroll`
- 指定`threshold`，传入`[0,1.0]`区间内的数据，指定重叠判断的比例
:::
IntersectionObserver使用成本几乎为0的**浏览器原生懒加载方案**近年来顺势而生

### loading="lazy"
第三种懒加载方案是使用浏览器原生`loading="lazy"`属性，这个属性目前可以用于`<img>`和`<iframe>`2类元素。

只要元素添加了`lazyload`属性，浏览器就会为处理各种细节，实现懒加载效果，无需任何额外代码逻辑，使用成本非常低

示例:
```html
<img loading="lazy" src="example.jpg" alt="Example Image" />

<iframe loading="lazy" src="https://github.com/JuniorTour"></iframe>
```
上述代码示例中，和没有懒加载的`<img>`、`<iframe>`相比，唯一的区别就是多了`loading="lazy"`属性，其余的`src`、`alt`等属性没有任何改变，也不需要新增额外代码逻辑，就能实现目标元素在视口外不加载资源，进入视口时才触发加载资源的懒加载效果。

**但是兼容性不好评价哈~**

## 封装资源库
这个库主要基于用户的需求和使用方式来确定初始化的逻辑，从用户的角度出发，来设计工具代码的API。

用户使用懒加载库，核心的需求就是：简单易用地去实现资源懒加载。

具体到使用方式，应该主要是这2种：
- 为已经存在的DOM元素，增加懒加载逻辑
- 为新增的元素，例如组件动态渲染生成的DOM元素，增加懒加载逻辑
所以在设计的时候分别提供两个2API，满足用户的以上用法：
-`initLazyloadAll(options)`：初始化通用懒加载库，同时为已经存在的DOM元素，增加懒加载逻辑
-`lazyLoadAllInstance.update()`:调用已经初始化的懒加载库实例方法`update()`，为新增的元素，增加懒加载逻辑

比如使用方法：
```js
  const lazyLoadeAllInstance = window.LazyLoadAll.initLazyloadAll({
    // mode: MODES.scroll,
    // mode: MODES.intersectionObserver,
    once: true,
  });

  // 懒加载元素增减后，更新监视目标
  lazyLoadeAllInstance.update();
```
### class IntersectionLazyLoader
```js
// src\IntersectionLazyLoader.js
export default class IntersectionLazyLoader {
  observer = null;

  constructor(options) {
    this.init(options);
  }

  init({ onIntersectCb, once, ObserverOptions }) {
    if (!onIntersectCb) {
      console.warn(
        `initScrollLazyLoader have falsy onIntersectCb=${onIntersectCb} `,
      );
      return;
    }
    if (this.observer) {
      return;
    }

    this.observer = new IntersectionObserver((entries) => {
      // 遍历所有观察的元素
      entries.forEach((entry) => {
        // 如果该元素进入了视口，就执行该元素对应的回调
        if (entry.isIntersecting) {
          const ele = entry.target;
          onIntersectCb(ele);
          if (once) {
            this.removeTarget(ele);
          }
        }
      });
    }, ObserverOptions);
  }

  addTarget(ele) {
    if (!ele) {
      return;
    }
    this.observer.observe(ele);
  }

  removeTarget(ele) {
    if (!ele) {
      return;
    }
    this.observer.unobserve(ele);
  }
}
```
`IntersectionLazyLoader`类的3个方法，逻辑分别是：
- `init(options)`:初始化 `Intersection Observer API` 实例。同时指定回调函数，当目标元素，满足懒加载条件时(`entry.isIntersection === true`)，调用`onIntersectCb()`方法，执行真正的加载资源逻辑
- `addTarget(ele)`：对懒加载监视目标元素调用`observe(ele)`方法，开始监视
- `removeTarget(ele)`：对懒加载监视目标元素调用`unobserve(ele)`方法，停止监视

## class ScrollLazyLoader
```js
// src\ScrollLazyloader.js
function throttle(callback, limit) {
    // ... 通用节流方法
}

export default class ScrollLazyLoader {
  inited = false;
  targetEles = [];

  constructor(options) {
    this.init(options);
    this.inited = true;
  }

  runLoad({ onIntersectCb, once }) {
    this.targetEles.forEach((ele) => {
      // 获取图片与视口顶部的相对距离
      const topPos = ele.getBoundingClientRect().top;
      // 与 视口高度（window.innerHeight）对比，判断是否在视口内
      if (topPos < window.innerHeight) {
        // debugger;
        onIntersectCb(ele);
        if (once) {
          this.removeTarget(ele);
        }
      }
    });
  }

  init(options) {
    if (!options.onIntersectCb) {
      console.warn(
        `initScrollLazyLoader have falsy onIntersectCb=${options.onIntersectCb} `,
      );
      return;
    }
    if (this.inited) {
      return;
    }

    // 初始化时，运行一次runLoad()，
    // 从而实现页面刷新，滚动位置不变时，仍能触发懒加载
    this.runLoad(options);

    window.addEventListener(
      'scroll',
      throttle(() => {
        this.runLoad(options);
      }),
      200,
    );
  }

  addTarget(ele) {
    if (!ele) {
      return;
    }
    this.targetEles.push(ele);
  }

  removeTarget(ele) {
    if (!ele) {
      return;
    }
    this.targetEles.splice(this.targetEles.indexOf(ele), 1);
  }
}
```
`ScrollLazyLoader`类同样暴露3个方法，逻辑分别是：
- `init(options)`：开始监听页面`scroll`事件，同时指定回调函数，当目标元素满足懒加载条件时（`topPos < window.innerHeight`），调用`onIntersectCb()`方法，执行真正的加载资源逻辑。并添加节流处理`throttle()`，节省运行时开销
- `addTarget(ele)`：将懒加载监视目标元素，**添加**到类实例的`this.targetEles`属性，开始监视
- `removeTarget(ele)`:对懒加载监视目标元素，**移除**出类实例的`this.targetEles`属性，停止监视