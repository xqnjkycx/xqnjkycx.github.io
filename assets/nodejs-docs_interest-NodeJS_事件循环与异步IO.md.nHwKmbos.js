import{_ as s,c as i,o as a,U as n}from"./chunks/framework.qUHj8-gn.js";const l="/assets/事件循环示意图.BNkrAb_z.png",p="/assets/Node的异步循环流程.9kMqJEvz.png",F=JSON.parse('{"title":"事件循环与异步IO","description":"","frontmatter":{},"headers":[],"relativePath":"nodejs-docs/interest-NodeJS/事件循环与异步IO.md","filePath":"nodejs-docs/interest-NodeJS/事件循环与异步IO.md","lastUpdated":1709736681000}'),h={name:"nodejs-docs/interest-NodeJS/事件循环与异步IO.md"},k=n(`<h1 id="事件循环与异步io" tabindex="-1">事件循环与异步IO <a class="header-anchor" href="#事件循环与异步io" aria-label="Permalink to &quot;事件循环与异步IO&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">MDN</p><p>JavaScript有一个基于事件循环的并发模型，事件循环负责执行代码，收集和处理事件以及执行队列中的子任务。</p></div><p>但在Node中，<strong>Node.js的事件循环是自己实现的</strong>，而不是完全复刻V8已有的一套事件循环。</p><p>作为能跑后端服务的JavaScript运行时，必须要有处理系统事件的能力。比如去处理各种文件描述符对应的读写事件，用伪代码来描述就是：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(还有事件在监听){</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> events</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> 从监听中获取所有事件的信息</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> event</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> events){</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>一个<code>setTimeout</code>可以是一个Timer事件，一个文件读写是一个系统的<code>I/O</code>事件。而Node基于<strong>libuv</strong>完成了自己事件循环与异步I/O。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>libuv是一个聚焦于I/O的跨平台库。</p><p>它是一个非常符合Node.js自身需求的异步I/O库，连里面的 API 都是为 Node.js 的各种能力设计的。</p><p>其API也非常简单，主要是包含文件描述符的监听，读写，连接以及定时器。</p></div><h2 id="事件循环-异步i-o" tabindex="-1">事件循环 !== 异步I/O <a class="header-anchor" href="#事件循环-异步i-o" aria-label="Permalink to &quot;事件循环 !== 异步I/O&quot;">​</a></h2><p>事件循环本质上是一种并发模型，主要是一个死循环，并在循环中不断处理到来的事件。</p><p>而异步I/O事件只是事件循环中事件的一种，除此之外还有各种其他的事件，比如定时器事件也是一种事件，但它并不是异步I/O。</p><p>事件循环就是一个死循环，那么把它的逻辑按时序拉平，就是一条直线。而大多数事件都是阻塞在等待事件，这个时候并不消耗CPU，一旦事件在底层完成了，就进入死循环代码块中的下一步，即拿着通知的相应内容去做用户业务逻辑。</p><p>比如文件读取完成了，那么libuv的事件循环就会把对应信息给到等到这个事件的回调函数，而通常这个回调函数最终回一路调至到JavaScript，从而唤起JavaScript侧的文件读取的回调函数，其底层表现为：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename,(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 这里就是callback</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>代码里面读取某个文件，然后就调用libuv去读取，假设没有更多其他事件，那么底层就会等着读取完毕的事件，也就是说，底层代码阻塞在等待事件上，直到读取完成，有事件通知，才会进行最终的调用。</p><p>也就是说，每一次事件循环执行一次回调操作时，都说明某个事件触发了，那么这样一次操作就可以理解为一个<strong>tick</strong>。</p><p>比如：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">readFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  fs.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">writeFile</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(filename, content, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">err</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 假设这个 \`writeFile\` 写文件要持续 2 秒钟</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  });</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;timer done!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>通过画图可以将这段代码理解为 <img src="`+l+`" alt="image"></p><h2 id="node事件循环源码解读" tabindex="-1">Node事件循环源码解读 <a class="header-anchor" href="#node事件循环源码解读" aria-label="Permalink to &quot;Node事件循环源码解读&quot;">​</a></h2><p>可以看一下Node.js的源码是大致上怎么写的，每个版本都要差异，但是一般来说大差不差：</p><p>这段代码的目的是在libuv事件循环中运行不同的类型的任务，并在一定条件下退出循环：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1.do-while 是一个循环 如果more为true 且env没有stopping就一直执行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">do</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 2.每次循环开始前检查env是否停止，如果是就停止循环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is_stopping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 3.运行libuv事件循环，处理所有挂起的事件和回调函数，uv_run会一直运行</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 直到事件循环中没有活动事件或回调，或者被显示执行</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  uv_run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">event_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(), </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">UV_RUN_DEFAULT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is_stopping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 4.在libuv事件循环之后，需要处理一些其他平台相关的任务</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  platform</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">DrainTasks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isolate);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 5.检查libuv事件循环是否处于活跃状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  more </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv_loop_alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">event_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (more </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is_stopping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">continue</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 6.发出一个beforeExit事件，如果事件发出成功，则继续执行后续的代码</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 如果发送失败，就退出循环</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">EmitProcessBeforeExit</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(env).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IsNothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">())</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 7.创建一个JavaScript作用域对象，用于管理JS对象的生命周期</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    HandleScope </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">handle_scope</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(isolate);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">RunSnapshotSerializeCallback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">().</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">IsEmpty</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 8.再次检查libuv事件循环是否处于活跃状态</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  more </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv_loop_alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">event_loop</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">} </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (more </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> true</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">env</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">is_stopping</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">());</span></span></code></pre></div><p>其中<code>uv_run(env-&gt;event_loop(), UV_RUN_DEFAULT)</code>就是跑一轮事件循环。而其中的<code>UV_RUN_DEAFULT</code>代表执行事件循环监听的池子里面已经没有关心的事件正在等待了。</p><p>所以可以看到这段代码有两层循环，第一层在<code>uv_run()</code>里面实际的事件循环，把它简称为<strong>小循环</strong>。第二层在<code>do-while</code>，它是包在小循环外的一层<strong>大循环</strong>。</p><h3 id="大循环" tabindex="-1">大循环 <a class="header-anchor" href="#大循环" aria-label="Permalink to &quot;大循环&quot;">​</a></h3><p>在大循环中，首先是对<code>is_stopping()</code>的判断，一旦处于待停止状态，就立马结束事件循环。</p><p>第一次<code>uv_run()</code>之后，去跑V8 Platform中的一些任务，跑完之后，可能不太清楚有没有新的事件放进入，所以需要判断<code>uv_loop_alive()</code>现在是否alive，如果没有alive了，就需要做一些收尾工作，比如去执行<code>EmitProcessBeforeExit(env)</code>事件，若没有可以直接退出循环了，若有，说明有可能被丢入了新的事件比如<code>setTimeout</code>事件，如果有那么害得进入下一轮循环。</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>大循环的存在是为了保证小循环结束后，程序是真的要结束了，还是有可能再丢事件进去，重新来一轮小循环。</p></div><h3 id="小循环" tabindex="-1">小循环 <a class="header-anchor" href="#小循环" aria-label="Permalink to &quot;小循环&quot;">​</a></h3><p>小循环中就是<code>uv_run()</code>内部的内容了，源码如下:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">int </span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">uv_run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(uv_loop_t</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loop, uv_run_mode mode) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  int timeout;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  int r;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  int ran_pending;</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 1.判断是否有存活的事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__loop_alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">r)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 2.如果没有存活事件，更新loop的最后处理时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__update_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stop_flag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 3.更新loop的最后处理时间</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__update_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 4.执行定时事件，找出上一次更新的“loop最后处理时间”已过期的事件拿来处理</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_timers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 5.遍历执行I/O事件已结束（完成，失败）并丢进pending队列中等待执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ran_pending </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__run_pending</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 6.遍历并执行idle事件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_idle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 7.遍历并执行prepare事件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_prepare</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ((mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV_RUN_ONCE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> &amp;&amp;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">ran_pending) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV_RUN_DEFAULT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 8.获取尚未触发的离现在最近的定时器的时间间隔(uv_backend_time)</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 即事件循环到下一次循环的最长时间</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      timeout </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv_backend_timeout</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 9.监听等待I/O事件触发，并以上一步获取的时间间隔作为最大监听时间，若超时还没事件触发</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 则直接取消这次等待，因为时间到了还没事件触发，但定时器触发事件到了</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // libuv 就要停下来处理下一轮定时器</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__io_poll</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop, timeout);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__metrics_update_idle_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 10.遍历并复查check事件</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_check</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 11.执行一些收尾工作</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    uv__run_closing_handles</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 12.如果执行模式为\`UV_RUN_ONCE\`，即跑一个tick</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV_RUN_ONCE</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      uv__update_time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      uv__run_timers</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 13.重新遍历一遍是否有活跃的事件，因为上一轮结束之后监听被取消了</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    r </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> uv__loop_alive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(loop);</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV_RUN_ONCE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> mode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> UV_RUN_NOWAIT</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">      break</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (loop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stop_flag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    loop</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">stop_flag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> r;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可以看出<code>while</code>循环的退出条件就是“没有活跃事件”了，而且整个事件循环不处于<code>stop</code>状态，就是<code>loop-&gt;stop_flag == 0</code>。</p><p>结合着看，在大循环中，执行了<code>uv_run</code>进入小循环，且模式设置为<code>UV_RUN_DEFAULT</code>。不过Node.js中，对小循环的返回值没有采取判断，而是在 V8 Platform 跑了一遍任务之后，又通过<code>uv_loop_alive()</code>重新获取了一遍“是否有活跃事件”。</p><p>然而在大循环中经历了一轮小循环之后，可能活跃事件又出来了，所以又要跑一轮大循环，再大循环中进行新的小循环，如此反复</p><p>可以把上面的流程继续精简一下： <img src="`+p+'" alt="image"></p><p>可以看到一次小循环的执行顺序为：</p><ul><li>定时器</li><li>处于Pending态的 I/O 事件</li><li>Idle 事件</li><li>Prepare 事件</li><li>Poll I/O 事件</li><li>Check事件</li><li>收尾事件</li></ul><p>下面描述一下这些事件是什么？</p><h3 id="定时器" tabindex="-1">定时器 <a class="header-anchor" href="#定时器" aria-label="Permalink to &quot;定时器&quot;">​</a></h3><p>定义一个超时事件，到点触发。在每一个小轮回里都是优先被执行的，所谓“到点”，就是基于每次通过<code>uv__update_time</code>，把“当前事件”植入到<code>loop</code>的时间点</p><h3 id="pending态的i-o事件" tabindex="-1">Pending态的I/O事件 <a class="header-anchor" href="#pending态的i-o事件" aria-label="Permalink to &quot;Pending态的I/O事件&quot;">​</a></h3><p>在一般情况下，所有的I/O回调函数都会在Poll I/O后立即调用。</p><p>但是，依然存在一些情况，需要将这样的回调函数推迟到下一次循环迭代中调用。如果上一次循环延迟了任何I/O回调函数，则会在此时调用它。</p><p>比如说，当TCP进行连接时，发生了<code>ECONNEEREFUSED</code>错误时，就会需要延迟报错，将这个错误的处理放在<code>pending_queue</code>，等待下一次循环时，在定时器处理之后再处理这个Pending态的I/O错误。</p><h3 id="idle事件" tabindex="-1">Idle事件 <a class="header-anchor" href="#idle事件" aria-label="Permalink to &quot;Idle事件&quot;">​</a></h3><p>若事件循环中存在Idle事件，小轮回中会强行设置<code>timeout</code>为<code>0</code>，即不阻塞I/O等待，可以马上开始进入下一轮轮回。在Node18里，那就是<code>setImmediate</code>，<strong>之所以他能immediate，就是因为它通过一个空的Idle事件让小循环强制不等待I/O</strong>。</p><h3 id="prepare事件" tabindex="-1">Prepare事件 <a class="header-anchor" href="#prepare事件" aria-label="Permalink to &quot;Prepare事件&quot;">​</a></h3><p>准备事件与空转事件类似。它在一个小乘轮回中，刚刚晚于空转事件执行。与空转事件不同的是，它不阻塞 I/O，不会干涉 <code>timeout</code>。</p><h3 id="poll-i-o事件" tabindex="-1">Poll I/O事件 <a class="header-anchor" href="#poll-i-o事件" aria-label="Permalink to &quot;Poll I/O事件&quot;">​</a></h3><p>I/O等到有事件触发的时候，再去执行相应的回调函数。</p><h3 id="check事件" tabindex="-1">Check事件 <a class="header-anchor" href="#check事件" aria-label="Permalink to &quot;Check事件&quot;">​</a></h3><p>它与“准备事件”一前一后，围绕着 Poll I/O 事件。可理解为一个是为 I/O 事件做准备，另一个是为其做一些后续额外操作。</p><h3 id="收尾事件" tabindex="-1">收尾事件 <a class="header-anchor" href="#收尾事件" aria-label="Permalink to &quot;收尾事件&quot;">​</a></h3><p>例如一个句柄被 <code>uv_close()</code> 所关闭，且其存在关闭的回调，则会在该阶段被调用</p>',54),t=[k];function e(E,d,r,g,o,c){return a(),i("div",null,t)}const _=s(h,[["render",e]]);export{F as __pageData,_ as default};
