# 组件的实现原理
编写比较复杂的页面时，用来描述页面结构的虚拟 DOM 的代码量会变得越来越多，或者说页面模板会变得越来越大。这时，我们就需要组件化的能力。有了组件，我们就可以将一个大的页面拆分为多个部分，每一个部分都可以作为单独的组件，这些组件共同组成完整的页面。

## 渲染组件
从渲染器内部的实现来看，一个组件其实就是一个特殊类型的虚拟Dom节点。

例如可以使用`vnode.type`来区分每个虚拟节点数类型。比如`vnode.type`可以通过`div`来Dom元素，为`Fragment`来描述片段，为`Text`来描述文本。

```js
 // 该 vnode 用来描述普通标签
 const vnode = {
   type: 'div'
   // ...
 }

 // 该 vnode 用来描述片段
 const vnode = {
   type: Fragment
   // ...
 }

 // 该 vnode 用来描述文本节点
 const vnode = {
   type: Text
   // ...
 }
```
同理，也可以使用`vnode`来描述组件
```js
 // 该 vnode 用来描述组件，type 属性存储组件的选项对象
 const vnode = {
   type: MyComponent
   // ...
 }
```
当`vode`为一个object类型的时候就表明了可以去渲染组件了。

接下来需要做的事就是，设计组件在用户层面的接口，包括：用户应该如何去编写组件，组件对象应该包含哪些内容，组件可以拥有什么类型的能力。

**实际上，组件本身就是对页面内容的封装，用于描述页面内容的一部分。因此，一个组件必须包含一个渲染函数，即render函数，并且渲染函数的返回值应该是虚拟DOM。组件的渲染函数就是用来描述组件所渲染内容的接口：**

```js
 const MyComponent = {
   // 组件名称，可选
   name: 'MyComponent',
   // 组件的渲染函数，其返回值必须为虚拟 DOM
   render() {
     // 返回虚拟 DOM
     return {
       type: 'div',
       children: `我是文本内容`
     }
   }
}
```
有了最基本的组件结构之后，渲染器就可以做到渲染，而渲染器中真正完成组件渲染任务的是`mountComponent`函数，其具体实现如下：
```js
 function mountComponent(vnode, container, anchor) {
   const componentOptions = vnode.type
    const { render, data } = componentOptions
   // 调用 data 函数得到原始数据，并调用 reactive 函数将其包装为响应式数据
   const state = reactive(data())
   // 调用 render 函数时，将其 this 设置为 state，
   // 从而 render 函数内部可以通过 this 访问组件自身状态数据
   const subTree = render.call(state, state)
   patch(null, subTree, container, anchor)
 }
```
## 组件状态与自更新
```js
 const MyComponent = {
   name: 'MyComponent',
   // 用 data 函数来定义组件自身的状态
   data() {
     return {
       foo: 'hello world'
     }
   },
   render() {
     return {
       type: 'div',
       children: `foo 的值是: ${this.foo}` // 在渲染函数内使用组件状态
     }
 }
```
在上面这段代码中，可以发现`render`函数中的`this.foo`其实是访问不到组件对象内部的`data.foo`的，所以约定用户必须使用data函数来定义组件自身的状态，并将其内部的数据取出来做响应式`reactive(data)`，同时通过`render.call`来改变`this`的指向，指向`data`中的数据。

这就实现了组件自身状态的初始化：
- 通过组件的选项对象取得 data 函数并执行，然后调用 reactive 函数将 data 函数返回的状态包装为响应式数据
- 在调用 render 函数时，将其 this 的指向设置为响应式数据 state，同时将 state 作为 render 函数的第一个参数传递

并且为了，数据发生改变实现组件的自更新`render`，所以`render`需要被放入到副作用注册函数中去：
```js
 function mountComponent(vnode, container, anchor) {
   const componentOptions = vnode.type
    const { render, data } = componentOptions
   // 调用 data 函数得到原始数据，并调用 reactive 函数将其包装为响应式数据
   const state = reactive(data())
   // 注册为响应式副作用函数
   effectRegister(()=>{
      const subTree = render.call(state, state)
      patch(null, subTree, container, anchor)
   },{
     scheduler: queueJob
   })
 }
```
对于组件渲染的问题，由于渲染非常消耗性能，所以当多次修改响应式数据时，会导致多次执行渲染函数，这显然是没有必要的。 所以可以看到这里加入了在响应式中所讲的调度执行，当副作用函数需要重新执行时，不需要立即执行它，而是将其缓冲到一个微任务队列中，等到栈清空后，再将其从微任务队列中去除执行，这里放一下之前响应式相关文章中的实现代码：
```js
 // 任务缓存队列，用一个 Set 数据结构来表示，这样就可以自动对任务进行去重
 const queue = new Set()
 // 一个标志，代表是否正在刷新任务队列
 let isFlushing = false
 // 创建一个立即 resolve 的 Promise 实例
 const p = Promise.resolve()

 // 调度器的主要函数，用来将一个任务添加到缓冲队列中，并开始刷新队列
 function queueJob(job) {
   // 将 job 添加到任务队列 queue 中
   queue.add(job)
   // 如果还没有开始刷新队列，则刷新之
   if (!isFlushing) {
     // 将该标志设置为 true 以避免重复刷新
     isFlushing = true
     // 在微任务中刷新缓冲队列
     p.then(() => {
       try {
         // 执行任务队列中的任务
         queue.forEach(job => job())
       } finally {
         // 重置状态
         isFlushing = false
         queue.clear = 0
       }
     })
   }
 }
```
## 组件实例与组件生命周期
组件实例本质上就是一个状态集合，或者说是一个对象，它维护着组件运行过程中的所有信息，例如组件的生命周期函数，组件渲染的子树，组件是否被挂载，组件自身的状态（data）。

因此为了记录新旧节点并作更新，引入一个组件实例的概念，以及相关的状态信息进行保存：
```js
 function mountComponent(vnode, container, anchor) {
   const componentOptions = vnode.type
   const { render, data } = componentOptions

   const state = reactive(data())

   // 定义组件实例，一个组件实例本质上就是一个对象，它包含与组件有关的状态信息
   const instance = {
     // 组件自身的状态数据，即 data
     state,
     // 一个布尔值，用来表示组件是否已经被挂载，初始值为 false
     isMounted: false,
     // 组件所渲染的内容，即子树（subTree）
     subTree: null
   }

   // 将组件实例设置到 vnode 上，用于后续更新
   vnode.component = instance

   effect(() => {
     // 调用组件的渲染函数，获得子树
     const subTree = render.call(state, state)
     // 检查组件是否已经被挂载
     if (!instance.isMounted) {
       // 初次挂载，调用 patch 函数第一个参数传递 null
       patch(null, subTree, container, anchor)
       // 重点：将组件实例的 isMounted 设置为 true，这样当更新发生时就不会再次进行挂载操作，
       // 而是会执行更新
       instance.isMounted = true
     } else {
       // 当 isMounted 为 true 时，说明组件已经被挂载，只需要完成自更新即可，
       // 所以在调用 patch 函数时，第一个参数为组件上一次渲染的子树，
       // 意思是，使用新的子树与上一次渲染的子树进行打补丁操作
       patch(instance.subTree, subTree, container, anchor)
     }
     // 更新组件实例的子树
     instance.subTree = subTree
   }, { scheduler: queueJob })
 }
```
在这段代码中，使用一个对象来表示组件实例，该对象有三个属性：
- state：记录组件的状态数据，即data
- isMounted：一个布尔值，用来表示组件是否被挂载
- subTree：存储组件的渲染函数返回虚拟DOM，即组件的子树

有了上面这段实现之后，就可以在合适的时机调用组件对应的生命周期钩子函数，如下面的代码所示：
```js
 function mountComponent(vnode, container, anchor) {
   const componentOptions = vnode.type
   // 从组件选项对象中取得组件的生命周期函数
   const { render, data, beforeCreate, created, beforeMount, mounted, beforeUpdate, updated } = componentOptions

   // 在这里调用 beforeCreate 钩子
   beforeCreate && beforeCreate()

   const state = reactive(data())

   const instance = {
     state,
     isMounted: false,
     subTree: null
   }
   vnode.component = instance

   // 在这里调用 created 钩子
   created && created.call(state)

   effect(() => {
     const subTree = render.call(state, state)
     if (!instance.isMounted) {
       // 在这里调用 beforeMount 钩子
       beforeMount && beforeMount.call(state)
       patch(null, subTree, container, anchor)
       instance.isMounted = true
       // 在这里调用 mounted 钩子
       mounted && mounted.call(state)
     } else {
       // 在这里调用 beforeUpdate 钩子
       beforeUpdate && beforeUpdate.call(state)
       patch(instance.subTree, subTree, container, anchor)
       // 在这里调用 updated 钩子
       updated && updated.call(state)
     }
     instance.subTree = subTree
   }, { scheduler: queueJob })
 }
```
这其实就是生命周期函数的实现本质，从组件的选项对象中取得注册到组件的生命周期函数，然后在合适的时机调用它们，这其实就是生命周期的实现原理。

## props的实现
在虚拟Dom层面上，组件的props与普通HTML标签的属性差别不大。假设这个模板：
```html
<MyComponent title="A Big Title" :other="val" />
```
那么它的对应虚拟节点的结构如下：
```js
 const vnode = {
   type: MyComponent,
   props: {
     title: 'A big Title',
     other: this.val
   }
 }
```
从实现上来看，首先会在组件上属性传递props数据，并且要在组件内部代码中定义props数据
```js
 const MyComponent = {
   name: 'MyComponent',
   // 组件接收名为 title 的 props，并且该 props 的类型为 String
   props: {
     title: String
   },
   render() {
     return {
       type: 'div',
       children: `count is: ${this.title}` // 访问 props 数据
     }
   }
 }
```
所以对于一个组件来说，有两部分关于props的内容只需要关注两点：
- 为组件传递的props数据，即组件的vnode.props对象；
- 组件选项对象中的props选项，即MyComponent.props对象
结合这两个选项可以解析出组件渲染时需要用到的props数据，具体实现如下：
```js
 function mountComponent(vnode, container, anchor) {
   const componentOptions = vnode.type
   // 从组件选项对象中取出 props 定义，即 propsOption，一般用于定义props的类型
   const { render, data, props: propsOption /* 其他省略 */ } = componentOptions

   beforeCreate && beforeCreate()

   const state = reactive(data())
   // 调用 resolveProps 函数解析出最终的 props 数据与 attrs 数据
   const [props, attrs] = resolveProps(propsOption, vnode.props)

   const instance = {
     state,
     // 将解析出的 props 数据包装为 shallowReactive 并定义到组件实例上
     props: shallowReactive(props),
     isMounted: false,
     subTree: null
   }
   vnode.component = instance

   // 省略部分代码
 }
 // resolveProps 函数用于解析组件 props 和 attrs 数据
 function resolveProps(options, propsData) {
   const props = {}
   const attrs = {}
   // 遍历为组件传递的 props 数据
   for (const key in propsData) {
     if (key in options) {
       // 如果为组件传递的 props 数据在组件自身的 props 选项中有定义，则将其视为合法的 props
       props[key] = propsData[key]
     } else {
       // 否则将其作为 attrs
       attrs[key] = propsData[key]
     }
   }

   // 最后返回 props 与 attrs 数据
   return [ props, attrs ]
 }
```
在上面的代码段中，将组件选项中定义的MyComponent.props对象和组件传递的vnode.props对象结合，最终解析出了组件在渲染时需要使用的props和attrs数据。这里需要注意两点：
- 在Vue3中，没有定义在MyComponent.props选项中的props数据将存储到attrs对象中
- 上述实现中没有包含默认值，类型校验等内容的处理。这些内容也都是围绕MyComponent.props以及vnode.props这个对象展开的，实现起来并不复杂

## setup的实现
Vue3中的setup函数主要是用于配合组合式API。为用户提供一个地方，用于建立组合逻辑，创建响应式数据，创建通用函数，注册生命周期钩子等能力。

在组件的整个生命周期中，setup函数只会在被挂载时执行一次，它的返回值可以有两种情况。
- 返回的是一个函数，该函数作为组件的render函数
```js
 const Comp = {
   setup() {
     // setup 函数可以返回一个函数，该函数将作为组件的渲染函数
     return () => {
       return { type: 'div', children: 'hello' }
     }
   }
 }
```
这种方式常用于组件不是以模板来表达其渲染内容的情况。如果组件以模板来表达其渲染的内容，那么setup函数不可以再返回函数，否则会与模板编译生成的渲染函数发生冲突

- 返回一个对象，该对象中包含的数据将暴露给模板使用

```js
 const Comp = {
   setup() {
     const count = ref(0)
     // 返回一个对象，对象中的数据会暴露到渲染函数中
     return {
       count
     }
   },
   render() {
     // 通过 this 可以访问 setup 暴露出来的响应式数据
     return { type: 'div', children: `count is: ${this.count}` }
   }
 }
```
setup函数暴露的数据可以在渲染函数中通过this来访问。

另外，setup 函数接收两个参数。第一个参数是props数据对象，第二个参数也是一个对象，通常称为setupContext，如下面代码所示：
```js
const Comp = {
  props:{
    foo:String
  },
  setup(props,setupContext){
    props.foo // 访问传入的props数据
    // setupContext 中包含与组件接口相关的重要数据
    const { slots, emit, attrs, expose} = setupContext
  }
}
```
围绕这些能力可以尝试这么实现一个setup组件选项：
```js
   // 从组件选项中取出 setup 函数
   let { render, data, setup, /* 省略其他选项 */ } = componentOptions

   beforeCreate && beforeCreate()

   const state = data ? reactive(data()) : null
   const [props, attrs] = resolveProps(propsOption, vnode.props)

   const instance = {
     state,
     props: shallowReactive(props),
     isMounted: false,
     subTree: null
   }

   // setupContext
   const setupContext = { attrs,emit,slots }
   // 调用 setup 函数，将只读版本的 props 作为第一个参数传递，避免用户意外地修改 props 的值，
   // 将 setupContext 作为第二个参数传递
   const setupResult = setup(shallowReadonly(instance.props), setupContext)
   // setupState 用来存储由 setup 返回的数据
   let setupState = null
   // 如果 setup 函数的返回值是函数，则将其作为渲染函数
   if (typeof setupResult === 'function') {
     // 报告冲突
     if (render) console.error('setup 函数返回渲染函数，render 选项将被忽略')
     // 将 setupResult 作为渲染函数
     render = setupResult
   } else {
    // 如果 setup 的返回值不是函数，则作为数据状态赋值给 setupState
     setupState = setupResult
   }
```
:::tip
在这里，要注意正确处理setupState，由于用户定义的数据通过setupState存储，所以也要暴露到渲染环境中去
:::

## 组件时间与emit实现
emit用来触发组件的自定义事件：
```js
 const MyComponent = {
   name: 'MyComponent',
   setup(props, { emit }) {
     // 发射 change 事件，并传递给事件处理函数两个参数
     emit('change', 1, 2)

     return () => {
       return // ...
     }
   }
 }
```
当使用该组件时，可以监听由emit函数发射的自定义事件:
```html
<MyComponent @change="handler">
```
而这个模板对应的虚拟DOM为：
```js
const CompVNode = {
  type: MyComponent,
  props:{
    onChange:handler
  }
}
```
可以看到，自定义事件 change 被编译成名为 onChange 的属性，并存储在 props 数据对象中。这实际上是一种约定

可以看到，自定义事件 change 被编译成名为 onChange 的属性，并存储在 props 数据对象中。这实际上是一种约定

```js
 function mountComponent(vnode, container, anchor) {
   /** 省略部分代码 **/ 

   const instance = {
     state,
     props: shallowReactive(props),
     isMounted: false,
     subTree: null
  }

   // 定义 emit 函数，它接收两个参数
   // event: 事件名称
   // payload: 传递给事件处理函数的参数
   function emit(event, ...payload) {
     // 根据约定对事件名称进行处理，例如 change --> onChange
     const eventName = `on${event[0].toUpperCase() + event.slice(1)}`
     // 根据处理后的事件名称去 props 中寻找对应的事件处理函数
     const handler = instance.props[eventName]
     if (handler) {
       // 调用事件处理函数并传递参数
       handler(...payload)
     } else {
       console.error('事件不存在')
     }
   }

   // 将 emit 函数添加到 setupContext 中，用户可以通过 setupContext 取得 emit 函数
   const setupContext = { attrs, emit }

   // 省略部分代码
 }
```
整体上的实现不复杂，只需要实现一个 emit 函数并将其添加到`setupContext`对象中，这样用户就可以通过 setupContext 取得 emit 函数了。另外，当emit函数被调用时，会根据约定对事件名称进行转换，以便能够在props对象中找到对应的事件处理函数。最后，调用事件处理函数并透传参数即可。

还需要额外注意，在讲解props时提到，任何没有显式地声明为props的属性都会存储到 attrs 中。换句话，任何事件类型的props，即`onXxx`类的属性，都不会出现在props中。这导致无法根据事件名称在 instance.props 中找到对应的事件处理函数。

所以需要在解析props数据的时候对事件类型的props做特殊处理:

```js
01 function resolveProps(options, propsData) {
02   const props = {}
03   const attrs = {}
04   for (const key in propsData) {
05     // 以字符串 on 开头的 props，无论是否显式地声明，都将其添加到 props 数据中，而不是添加到 attrs 中
06     if (key in options || key.startsWith('on')) {
07       props[key] = propsData[key]
08     } else {
09       attrs[key] = propsData[key]
10     }
11   }
12
13   return [ props, attrs ]
14 }
```

## 插槽的工作原理
顾名思义，组件的插槽指组件会预留一个槽位。该槽位具体要渲染的内容由用户插入，如下面给出的MyComponent组件的模板所示:
```html
 <template>
   <header><slot name="header" /></header>
   <div>
     <slot name="body" />
   </div>
   <footer><slot name="footer" /></footer>
 </template>
```
当在父组件中使用`<MyComponent>`组件时，可以根据插槽的名字来插入自定义的内容
```html
 <MyComponent>
   <template #header>
     <h1>我是标题</h1>
   </template>
   <template #body>
     <section>我是内容</section>
   </template>
   <template #footer>
     <p>我是注脚</p>
   </template>
 </MyComponent>
```
上面这段父组件的模板会被编译成如下渲染函数:
```js
 // 父组件的渲染函数
 function render() {
     type: MyComponent,
     // 组件的 children 会被编译成一个对象
     children: {
       header() {
         return { type: 'h1', children: '我是标题' }
       },
       body() {
         return { type: 'section', children: '我是内容' }
       },
       footer() {
         return { type: 'p', children: '我是注脚' }
       }
     }
   }
 }
```
可以看到，组件模板中的插槽内容会被编译为插槽函数，而插槽函数的返回值就是具体的插槽内容。组件MyComponent的模板则会被编译为如下的渲染函数：
```js
 // MyComponent 组件模板的编译结果
 function render() {
   return [
     {
       type: 'header',
       children: [this.$slots.header()]
     },
     {
       type: 'body',
       children: [this.$slots.body()]
     },
     {
       type: 'footer',
       children: [this.$slots.footer()]
     }
   ]
 }
```
在运行时的实现，插槽就是依赖于`setupContext`中的slots对象：
```js
 function mountComponent(vnode, container, anchor) {
   // 省略部分代码

   // 直接使用编译好的 vnode.children 对象作为 slots 对象即可
   const slots = vnode.children || {}

   // 将 slots 对象添加到 setupContext 中
   const setupContext = { attrs, emit, slots }

 }
```
可以看到，最基本的 slots 的实现非常简单。只需要将编译好的 vnode.children 作为 slots 对象，然后将slots对象添加到`setupContext`对象中即可。

## 注册生命周期
在V3中，有一部分组合式API是用来注册生命周期钩子函数的，例如`onMounted`，`onUpdated`等，如下所示
```js
 import { onMounted } from 'vue'

 const MyComponent = {
    setup(){
     onMounted(() => {
       console.log('mounted 1')
     })
     // 可以注册多个
     onMounted(() => {
       console.log('mounted 2')
     })

     // ...
   }
 }
```
在setup函数中调用 onMounted 函数即可注册 mounted 生命周期钩子函数，并且可以通过多次调用onMounted函数来注册多个钩子函数，这些函数会在组件被挂载之后再执行。

这里的难点在于，在A组件的`setup`函数中调用`onMounted`函数会将该钩子函数注册到A组件上；而在 B 组件的 setup 函数中调用 onMounted 函数会将钩子函数注册到B组件上，这怎么实现呢？

实际上，需要维护一个变量 currentInstance，用它来存储当前组件实例，每当初始化组件并执行组件的 setup 函数之前，先将 currentInstance 设置为当前组件实例，再执行组件的 setup 函数，这样可以通过该变量来获取当前正在被初始化的组件实例，从而将那些通过 onMounted 函数注册的钩子函数于组件实例进行关联。

需要设计一个当前实例的维护方法
```js
 // 全局变量，存储当前正在被初始化的组件实例
 let currentInstance = null
 // 该方法接收组件实例作为参数，并将该实例设置为 currentInstance
 function setCurrentInstance(instance) {
   currentInstance = instance
 }
```
以及用来设置该变量的`setCurrentInstance`函数之后，就可以着手修改`mounteComponent`函数了：
```js
function mountComponent(vnode, container, anchor) {
   // 省略部分代码

   const instance = {
     state,
     props: shallowReactive(props),
     isMounted: false,
     subTree: null,
     slots,
     // 在组件实例中添加 mounted 数组，用来存储通过 onMounted 函数注册的生命周期钩子函数
     mounted: []
   }

   // 省略部分代码

   // setup
   const setupContext = { attrs, emit, slots }

   // 在调用 setup 函数之前，设置当前组件实例
   setCurrentInstance(instance)
   // 执行 setup 函数
   const setupResult = setup(shallowReadonly(instance.props), setupContext)
   // 在 setup 函数执行完毕之后，重置当前组件实例
   setCurrentInstance(null)

   // 省略部分代码
 }
```
对于组件实例的维护已经搞定了。接下来考虑`onMounted`函数本身的实现：
```js
 function onMounted(fn) {
   if (currentInstance) {
     // 将生命周期函数添加到 instance.mounted 数组中
     currentInstance.mounted.push(fn)
   } else {
     console.error('onMounted 函数只能在 setup 中调用')
   }
 }
```