import{_ as s,c as a,o as i,U as n}from"./chunks/framework.qUHj8-gn.js";const l="/assets/split-chunk-1.wNsxU3rf.png",t="/assets/chunk-split-1.s27t6Yui.png",y=JSON.parse('{"title":"代码分割","description":"","frontmatter":{},"headers":[],"relativePath":"bundle-tool-docs/vite/代码分割.md","filePath":"bundle-tool-docs/vite/代码分割.md","lastUpdated":1716128103000}'),e={name:"bundle-tool-docs/vite/代码分割.md"},p=n('<h1 id="代码分割" tabindex="-1">代码分割 <a class="header-anchor" href="#代码分割" aria-label="Permalink to &quot;代码分割&quot;">​</a></h1><p>在生产环境下，为了提高页面加载性能，构建工具一般将项目的代码打包（bundle）到一起，这样上线之后只需要请求少量的JS文件，大大减少了HTTP请求数量。</p><ul><li>bundle: 指的是整体的打包产物，包含JS和各种静态资源</li><li>chunk: 指的是打包后的JS产物，是bundle的子集</li><li>vender: 是指第三方包的打包产物，是一种特殊的chunk</li></ul><h2 id="代码分割解决了什么问题" tabindex="-1">代码分割解决了什么问题？ <a class="header-anchor" href="#代码分割解决了什么问题" aria-label="Permalink to &quot;代码分割解决了什么问题？&quot;">​</a></h2><p>在传统的单chunk打包模式下，当项目代码越来越大时，最后会导致浏览器下载一个巨大的文件，从页面加载性能的角度来说，主要会导致两个问题：</p><ul><li>无法做到<strong>按需加载</strong>，即使是当前页面不需要的代码也会进行加载</li><li>线上<strong>缓存复用率</strong>低下，改动一行代码会导致整个bundle产物缓存失效</li></ul><h3 id="按需加载" tabindex="-1">按需加载 <a class="header-anchor" href="#按需加载" aria-label="Permalink to &quot;按需加载&quot;">​</a></h3><p>一般而言，一个前端页面中的 JS 代码可以分为两个部分:<code>Initital Chunk</code> 和 <code>Async Chunk</code>，前者指页面首屏所需要的 JS 代码，而后者当前页面并不一定需要，一个典型的例子就是 路由组件，与当前路由无关的组件并不用加载。而项目被打包成单 <code>bundle</code> 之后，无论是<code>Initial Chunk</code>还是<code>Async Chunk</code>，都会打包进同一个产物，也就是说，浏览器加载产物代码的时候，会将两者一起加载，导致许多冗余的加载过程，从而影响页面性能。而通过<code>Code Splitting</code>我们可以将按需加载的代码拆分出单独的 <code>chunk</code>，这样应用在首屏加载时只需要加载<code>Initial Chunk</code>即可，避免了冗余的加载过程，使页面性能得到提升。</p><h3 id="缓存复用率" tabindex="-1">缓存复用率 <a class="header-anchor" href="#缓存复用率" aria-label="Permalink to &quot;缓存复用率&quot;">​</a></h3><p>对于线上站点来说，服务端一般在响应资源时加上一些HTTP响应头，最常见的响应头之一就是<code>cache-control</code>，它可以指定浏览器的<strong>强缓存</strong>，比如设置如下：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">cache-control: max-age=31536000</span></span></code></pre></div><p>这样表示资源过期时间为一年，在过期之前访问相同的<strong>资源url</strong>，浏览器直接利用本地缓存，并不用给服务端发送请求，这就降低了页面加载的网络开销。不过，在单chunk打包模式下，一旦有一行代码的变动，整个chunk的url地址都会变化：</p><p><img src="'+l+'" alt="image"></p><p>由于构建工具一般会根据产物的内容生产hash，一旦内容发生改变导致整个chunk产物的强缓存失效，所以单chunk打包模式下的缓存命中率极低，基本为0。</p><p>相反，经过代码分割之后，代码的改动只会影响部分的chunk哈希改动</p><p><img src="'+t+`" alt="image"></p><p>这样b c d三个产物的url没有发生变化，从而使浏览器复用本地的缓存策略，提升线上应用的加载性能。</p><h2 id="vite的分割" tabindex="-1">Vite的分割 <a class="header-anchor" href="#vite的分割" aria-label="Permalink to &quot;Vite的分割&quot;">​</a></h2><p>Vite的默认拆包的优势体现在于实现了CSS代码分割与业务代码，第三方库代码，动态import模块代码三者的分离，但是缺点比较明显，第三方库的打包产物容易变得比较臃肿，当一个打包文件超过<strong>500KB</strong>以上，Vite就会发出警告，希望使用Rollup中的拆包API<code>manualChunks</code></p><h2 id="自定义拆包策略" tabindex="-1">自定义拆包策略 <a class="header-anchor" href="#自定义拆包策略" aria-label="Permalink to &quot;自定义拆包策略&quot;">​</a></h2><p>针对更加细粒度的拆包，Vite底层的打包引擎Rollup提供了<code>manualChunks</code>，让开发者进行自定义拆包策略，它属于Vite配置的一部分，示例如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">	build:{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    rollupOptions:{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      output:{</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        manualChunks:{}</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p><code>manualChunks</code>主要有两者配置形式，可以配置为一个对象或者一个函数</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    rollupOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">      output</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // manualChunks 配置</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        manualChunks</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 将 React 相关库打包成单独的 chunk 中</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &#39;react-vendor&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;react-dom&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 将 Lodash 库的代码单独打包</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &#39;lodash&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;lodash-es&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">          // 将组件库的代码打包</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">          &#39;library&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;antd&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@arco-design/web-react&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">],</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样第三方库的大文件被拆分为了更小的chunk，这样第三方包在更新的时候，也只会更新其中一个chunk的url，更不是去全量更新，从而提升了第三方包产物的缓存命中率，每个chunk可能还是过大，可以考虑gzip来进行压缩。</p>`,25),h=[p];function k(d,c,o,r,E,u){return i(),a("div",null,h)}const m=s(e,[["render",k]]);export{y as __pageData,m as default};
