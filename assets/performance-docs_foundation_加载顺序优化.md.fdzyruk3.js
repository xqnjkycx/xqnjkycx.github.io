import{_ as s,c as i,o as a,U as t}from"./chunks/framework.qUHj8-gn.js";const p="/assets/同步解析.t4BP5Nq7.png",n="/assets/script放在最后的同步解析.zcTXmGKC.png",l="/assets/async解析流程.S4nOcn-9.png",h="/assets/defer解析流程.Ko_CzB-D.png",_=JSON.parse('{"title":"加载顺序优化","description":"","frontmatter":{},"headers":[],"relativePath":"performance-docs/foundation/加载顺序优化.md","filePath":"performance-docs/foundation/加载顺序优化.md","lastUpdated":1709740044000}'),e={name:"performance-docs/foundation/加载顺序优化.md"},k=t(`<h1 id="加载顺序优化" tabindex="-1">加载顺序优化 <a class="header-anchor" href="#加载顺序优化" aria-label="Permalink to &quot;加载顺序优化&quot;">​</a></h1><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>CSS和JS，都具有<strong>阻塞渲染</strong>的特性</p></div><h2 id="css的阻塞" tabindex="-1">CSS的阻塞 <a class="header-anchor" href="#css的阻塞" aria-label="Permalink to &quot;CSS的阻塞&quot;">​</a></h2><p>默认情况下，CSS是阻塞的资源。浏览器在构建CSSOM的过程中，<strong>不会渲染任何已处理的内容</strong>。即便DOM已经解析完成了，只要CSSOM没有完成，那么渲染整个事情就是不OK的</p><div class="tip custom-block"><p class="custom-block-title">TIP</p><p>这样避免了没有CSS的HTML页面丑陋无比地出现在用户的眼前</p></div><p>只有当开始解析 HTML 后，解析到link标签或者style标签时，CSS才登场，CSSOM的构建才正式开始，很多时候DOM不得不等待CSSOM，因此其实可以这么认为：</p><p><strong>CSS是阻塞渲染的资源。需要它尽早，也尽快地下载到客户端，以便缩短首次渲染的时间。</strong></p><p>而且很多团队都已经做到了尽早（将CSS放在head标签里面）和尽快（启用CDN实现静态资源加载速度的优化）。这个把“CSS往前放”的动作，基本上也是业内标准了。</p><h2 id="js的阻塞" tabindex="-1">JS的阻塞 <a class="header-anchor" href="#js的阻塞" aria-label="Permalink to &quot;JS的阻塞&quot;">​</a></h2><p><strong>JS引擎是独立于渲染引擎存在的</strong>。当HTML解析器遇到一个 <em>script</em> 标签时，它会暂停渲染过程，将控制权交给JS引擎。</p><p>JS引擎对内联的JS代码会直接执行，对外部JS文件还要先获取到脚本，再进行执行。等JS引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续CSSOM和DOM的构建。因此与其说JS把CSS和HTML阻塞了，不如说是JS引擎抢走了渲染引擎的控制权。</p><p>浏览器之所以让JS阻塞其它活动，是因为不知道JS会做什么改变，担心如果不阻止后续的操作，会造成混乱。</p><p>所以一般行业内，可以看到一般把 <em>script</em> 标签放在HTML的 <em>body</em> 最末尾。</p><h2 id="资源提示符优化" tabindex="-1">资源提示符优化 <a class="header-anchor" href="#资源提示符优化" aria-label="Permalink to &quot;资源提示符优化&quot;">​</a></h2><p>像async defer这样的关键字就被称为资源提示符。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> async</span><span style="--shiki-light:#B31D28;--shiki-dark:#FDAEB7;--shiki-light-font-style:italic;--shiki-dark-font-style:italic;"> /</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> defer</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><p>在不加资源提示符的前提下，先会解析dom元素，然后网络加载 <em>script</em> 脚本，然后执行脚本，接着继续解析dom元素，like this:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>在上面的代码片段中，当浏览器在主线程解析dom元素后，会切到网络线程里面去<code>fetch</code> js脚本，然后又回到主线程去执行脚本，然后继续解析dom元素。</p><p><img src="`+p+`" alt="image"></p><p>这样导致在请求网络脚本时出现了一个空窗期，并且可以发现卡住了dom解析流程。</p><p>所以一般写代码时，建议去将<em>script</em>标签放在最后:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">p</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p><img src="`+n+'" alt="image"></p><p>虽然这样并不会卡住浏览器的元素解析，但是依然出现了空窗期。</p><p>所以需要使用<em>async</em>和<em>defer</em>来优化这个过程</p><p>当使用<em>async</em>时，从远程加载js脚本并不会暂停执行dom元素渲染，而是异步加载脚本完成之后直接介入到主线程中去实现解析： <img src="'+l+'" alt="image"></p><p>而实现<em>defer</em>时，不仅不会暂停dom元素解析，并且还会等待主线程把dom元素解析完毕之后，才会执行请求好的js脚本。 <img src="'+h+'" alt="image"></p><hr><p>除了JS之外，还有<code>preload</code>和<code>prefetch</code>这两个提示符，它们可以放在任何的资源上，比如CSS文件，JS文件，图片资源等等。</p><p>它们的共同点在于只拿取资源但不解析执行资源，而且不会阻碍dom元素解析。可以用作缓存资源，省去了拿去资源的耗时，<code>preload</code>的优先级更高，它代表马上就要用到了，回立刻去请求资源。<code>prefetch</code>优先级较低，将会在浏览器空闲的时间去拿去资源。</p>',31),E=[k];function r(d,c,o,g,y,m){return a(),i("div",null,E)}const u=s(e,[["render",r]]);export{_ as __pageData,u as default};
